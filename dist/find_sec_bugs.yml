# yamllint disable
# rule-set version: v1.3.40
# yamllint enable
---
rules:
- id: "find_sec_bugs.HTTPONLY_COOKIE-1"
  languages:
  - "java"
  pattern-either:
  - patterns:
    - pattern: |
        javax.servlet.http.Cookie $C = new Cookie(..., ...);
        ...
        (HttpServletResponse $RESP).addCookie($C);
    - pattern-not-inside: |
        javax.servlet.http.Cookie $C = new Cookie(..., ...);
        ...
        $C.setHttpOnly(true);
        ...
        (HttpServletResponse $RESP).addCookie($C);
  - pattern: "(javax.servlet.http.Cookie $C).setHttpOnly(false);"
  message: |
    The `HttpOnly` attribute when set to `true` protects the cookie value from being accessed by
    client side JavaScript such
    as reading the `document.cookie` values. By enabling this protection, a website that is
    vulnerable to
    Cross-Site Scripting (XSS) will be able to block malicious scripts from accessing the cookie
    value from JavaScript.

    Example of protecting a `Cookie`:
    ```
    // Create an HttpOnly cookie.
    Cookie someCookie = new Cookie("SomeCookieName", "SomeValue");
    // Set HttpOnly flag to true
    someCookie.setHttpOnly(true);
    ```

    For more information see:
    https://jakarta.ee/specifications/servlet/4.0/apidocs/javax/servlet/http/cookie#setHttpOnly-boolean-

    Session cookies should be configured with the following security directives:

    - [HTTPOnly](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies#restrict_access_to_cookies)
    - [Secure](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies#restrict_access_to_cookies)
    - [SameSite](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie/SameSite)
  severity: "WARNING"
  metadata:
    shortDescription: "Sensitive cookie without 'HttpOnly' flag"
    category: "security"
    cwe: "CWE-1004"
    technology:
    - "java"
    primary_identifier: "find_sec_bugs.HTTPONLY_COOKIE-1"
    secondary_identifiers:
    - name: "Find Security Bugs-HTTPONLY_COOKIE"
      type: "find_sec_bugs_type"
      value: "HTTPONLY_COOKIE"
- id: "find_sec_bugs.INSECURE_COOKIE-1"
  languages:
  - "java"
  pattern-either:
  - patterns:
    - pattern: |
        javax.servlet.http.Cookie $C = new Cookie(..., ...);
        ...
        (HttpServletResponse $RESP).addCookie($C);
    - pattern-not-inside: |
        javax.servlet.http.Cookie $C = new Cookie(..., ...);
        ...
        $C.setSecure(true);
        ...
        (HttpServletResponse $RESP).addCookie($C);
  - pattern: "(javax.servlet.http.Cookie $C).setSecure(false);"
  message: |
    The `Secure` attribute when set to `true` protects the cookie value from being being
    transmitted over clear text
    communication paths such as HTTP. By enabling this protection, the cookie will only be sent
    over HTTPS.

    Example of protecting a `Cookie`:
    ```
    // Create an Secure cookie.
    Cookie someCookie = new Cookie("SomeCookieName", "SomeValue");
    // Set Secure flag to true
    someCookie.setSecure(true);
    ```

    For more information see:
    https://jakarta.ee/specifications/servlet/4.0/apidocs/javax/servlet/http/cookie#setSecure-boolean-

    Session cookies should be configured with the following security directives:

    - [HTTPOnly](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies#restrict_access_to_cookies)
    - [SameSite](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie/SameSite)
    - [Secure](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies#restrict_access_to_cookies)
  severity: "WARNING"
  metadata:
    shortDescription: "Sensitive cookie in HTTPS session without 'Secure' attribute"
    category: "security"
    cwe: "CWE-614"
    technology:
    - "java"
    primary_identifier: "find_sec_bugs.INSECURE_COOKIE-1"
    secondary_identifiers:
    - name: "Find Security Bugs-INSECURE_COOKIE"
      type: "find_sec_bugs_type"
      value: "INSECURE_COOKIE"
- id: "find_sec_bugs.COOKIE_PERSISTENT-1"
  languages:
  - "java"
  message: |
    Storing sensitive data in a persistent cookie for an extended period can lead to a breach of
    confidentiality or account compromise.
  metadata:
    category: "security"
    cwe: "CWE-614"
    shortDescription: "Sensitive Cookie in HTTPS Session Without 'Secure' Attribute"
    technology:
    - "java"
    primary_identifier: "find_sec_bugs.COOKIE_PERSISTENT-1"
    secondary_identifiers:
    - name: "Find Security Bugs-COOKIE_PERSISTENT"
      type: "find_sec_bugs_type"
      value: "COOKIE_PERSISTENT"
  patterns:
  - pattern-inside: |
      (javax.servlet.http.Cookie $C).setMaxAge($AGE);
  - metavariable-comparison:
      comparison: "$AGE >= 31536000"
      metavariable: "$AGE"
  severity: "WARNING"
- id: "find_sec_bugs.COOKIE_USAGE-1"
  languages:
  - "java"
  message: |
    The information stored in a custom cookie should not be sensitive or related to the session.
    In most cases, sensitive data should only be stored in session and referenced by the user's
    session cookie.
  metadata:
    category: "security"
    cwe: "CWE-614"
    shortDescription: "Sensitive Cookie in HTTPS Session Without 'Secure' Attribute"
    technology:
    - "java"
    primary_identifier: "find_sec_bugs.COOKIE_USAGE-1"
    secondary_identifiers:
    - name: "Find Security Bugs-COOKIE_USAGE"
      type: "find_sec_bugs_type"
      value: "COOKIE_USAGE"
  patterns:
  - pattern-inside: |
      $FUNC(..., HttpServletRequest $REQ, ...) {
        ...
      }
  - pattern-either:
    - patterns:
      - pattern-inside: |
          for (Cookie $C : $REQ.getCookies()) {
              ...
          }
      - pattern-either:
        - pattern: "$C.getName();"
        - pattern: "$C.getValue();"
        - pattern: "$C.getPath();"
    - pattern: "(Cookie $COOKIE).getName();"
    - pattern: "(Cookie $COOKIE).getValue();"
    - pattern: "(Cookie $COOKIE).getPath();"
  severity: "WARNING"
- id: "find_sec_bugs.HTTP_RESPONSE_SPLITTING-1"
  languages:
  - "java"
  mode: "taint"
  pattern-sanitizers:
  - patterns:
    - pattern-inside: |
        $STR.replaceAll("$REPLACE_CHAR", "$REPLACER");
        ...
    - pattern: "$STR"
    - metavariable-regex:
        metavariable: "$REPLACER"
        regex: ".*^(CRLF).*"
    - metavariable-regex:
        metavariable: "$REPLACE_CHAR"
        regex: "(*CRLF)"
  - pattern: "org.apache.commons.text.StringEscapeUtils.unescapeJava(...);"
  pattern-sinks:
  - pattern: "new javax.servlet.http.Cookie(\"$KEY\", ...);"
  - patterns:
    - pattern-inside: |
        $C = new javax.servlet.http.Cookie("$KEY", ...);
        ...
    - pattern: "$C.setValue(...);"
  pattern-sources:
  - pattern: "(javax.servlet.http.HttpServletRequest $REQ).getParameter(...);"
  message: |
    HTTP Response Splitting is a vulnerability where Carriage Return (CR `\r`) and Line Feed (LF
    `\n`)
    characters are introduced into an HTTP header from user-supplied input. By injecting the
    `\r\n`
    character sequence, an adversary could potentially modify how the response is interpreted by
    the
    client or any downstream caching services. This could allow an adversary to poison the cache
    data or execute Cross-Site Scripting (XSS) attacks.

    Some Java application servers such as [Apache Tomcat](https://tomcat.apache.org/) will
    disallow `\r\n`
    characters from being set in cookies. If your application server does not automatically
    provide this
    functionality, user-supplied input that is used in cookie keys or values must be validated.

    Example of validating cookies to only allow valid characters:
    ```
    // throws an IllegalArgumentException if the provided value contains invalid characters
    public void validateRfc6265CookieValue(String value) throws IllegalArgumentException {
        char[] chars = value.toCharArray();

        // iterate over every character
        for (int i = 0; i < chars.length; i++) {
            char c = chars[i];

            // check for any characters below 0x21 as well as: '"' ',' ';' '\' and 0x7f.
            if (c < 0x21 || c == '"' || c == ',' || c == ';' || c == '\\' || c == 0x7f) {
                throw new IllegalArgumentException("Invalid character in cookie detected:
    {0}".format(Integer.toString(c)));
            }
        }
    }
    ```

    Alternatively, you could use a string escape package such as
    [Apache Commons Text](https://commons.apache.org/proper/commons-text/) to escape the input:
    ```
    public String escapeValue(String value) {
      return StringEscapeUtils.escapeJava(value);
    }
    ```

    For more information on response splitting attacks see OWASP:
    https://owasp.org/www-community/attacks/HTTP_Response_Splitting
  severity: "WARNING"
  metadata:
    shortDescription: "Improper neutralization of CRLF sequences in HTTP headers ('HTTP
      Response Splitting')"
    category: "security"
    cwe: "CWE-113"
    technology:
    - "java"
    primary_identifier: "find_sec_bugs.HTTP_RESPONSE_SPLITTING-1"
    secondary_identifiers:
    - name: "Find Security Bugs-HTTP_RESPONSE_SPLITTING"
      type: "find_sec_bugs_type"
      value: "HTTP_RESPONSE_SPLITTING"
- id: "find_sec_bugs.HRS_REQUEST_PARAMETER_TO_COOKIE-1"
  languages:
  - "java"
  message: |
    This code constructs an HTTP Cookie using an untrusted HTTP parameter. If this cookie is added
    to an HTTP response, it will allow a HTTP response splitting vulnerability. See
    http://en.wikipedia.org/wiki/HTTP_response_splitting for more information.
  metadata:
    category: "security"
    cwe: "CWE-113"
    shortDescription: "Improper Neutralization of CRLF Sequences in HTTP Headers ('HTTP
      Response Splitting')"
    technology:
    - "java"
    primary_identifier: "find_sec_bugs.HRS_REQUEST_PARAMETER_TO_COOKIE-1"
    secondary_identifiers:
    - name: "Find Security Bugs-HRS_REQUEST_PARAMETER_TO_COOKIE"
      type: "find_sec_bugs_type"
      value: "HRS_REQUEST_PARAMETER_TO_COOKIE"
  mode: "taint"
  pattern-sanitizers:
  - patterns:
    - pattern-inside: |
        $STR.replaceAll("$REPLACE_CHAR", "$REPLACER");
        ...
    - pattern: "$STR"
    - metavariable-regex:
        metavariable: "$REPLACER"
        regex: ".*^(CRLF).*"
    - metavariable-regex:
        metavariable: "$REPLACE_CHAR"
        regex: "(*CRLF)"
  - pattern: "org.apache.commons.text.StringEscapeUtils.unescapeJava(...);"
  pattern-sinks:
  - pattern: "new javax.servlet.http.Cookie(\"$KEY\", ...);"
  - patterns:
    - pattern-inside: |
        $C = new javax.servlet.http.Cookie("$KEY", ...);
        ...
    - pattern: "$C.setValue(...);"
  pattern-sources:
  - pattern: "(javax.servlet.http.HttpServletRequest $REQ).getParameter(...);"
  severity: "ERROR"
- id: "find_sec_bugs.HRS_REQUEST_PARAMETER_TO_HTTP_HEADER-1"
  languages:
  - "java"
  mode: "taint"
  pattern-sanitizers:
  - patterns:
    - pattern-inside: |
        $STR.replaceAll("$REPLACE_CHAR", "$REPLACER");
        ...
    - pattern: "$STR"
    - metavariable-regex:
        metavariable: "$REPLACER"
        regex: ".*^(CRLF).*"
    - metavariable-regex:
        metavariable: "$REPLACE_CHAR"
        regex: "(*CRLF)"
  - pattern: "org.apache.commons.text.StringEscapeUtils.unescapeJava(...);"
  pattern-sinks:
  - pattern: "(javax.servlet.http.HttpServletResponse $RES).setHeader(\"$KEY\", ...);"
  - pattern: "(javax.servlet.http.HttpServletResponse $RES).addHeader(\"$KEY\", ...);"
  - pattern: "(javax.servlet.http.HttpServletResponseWrapper $WRP).setHeader(\"$KEY\",
      ...);"
  - pattern: "(javax.servlet.http.HttpServletResponseWrapper $WRP).addHeader(\"$KEY\",
      ...);"
  pattern-sources:
  - pattern: "(javax.servlet.http.HttpServletRequest $REQ).getParameter(...);"
  message: |
    HTTP Response Splitting is a vulnerability where Carriage Return (CR `\r`) and Line Feed (LF
    `\n`)
    characters are introduced into an HTTP header from user-supplied input. By injecting the
    `\r\n`
    character sequence, an adversary could potentially modify how the response is interpreted by
    the
    client or any down stream caching services. This could allow an adversary to poison the cache
    data or execute Cross-Site Scripting (XSS) attacks.

    Some Java application servers such as [Apache Tomcat](https://tomcat.apache.org/) will
    automatically encode
    characters from being set in response headers as a space `0x20` character. If your application
    server does
    not automatically provide this functionality, user-supplied input that is used in header keys
    or values must be
    validated.

    Example of validating headers to only allow valid characters:
    ```
    // throws an IllegalArgumentException if the provided value contains invalid characters
    public void validateHeader(String value) throws IllegalArgumentException {
        char[] chars = value.toCharArray();

        // iterate over every character
        for (int i = 0; i < chars.length; i++) {
            char c = chars[i];

            // check for any characters below 0x21 as well as: '"' ',' ';' '\' and 0x7f.
            if (c < 0x21 || c == '"' || c == ',' || c == ';' || c == '\\' || c == 0x7f) {
                throw new IllegalArgumentException("Invalid character in cookie detected:
    {0}".format(Integer.toString(c)));
            }
        }
    }
    ```

    Alternatively, you could use a string escape package such as
    [Apache Commons Text](https://commons.apache.org/proper/commons-text/) to escape the input:
    ```
    public String escapeValue(String value) {
      return StringEscapeUtils.escapeJava(value);
    }
    ```

    For more information on response splitting attacks see OWASP:
    https://owasp.org/www-community/attacks/HTTP_Response_Splitting
  severity: "ERROR"
  metadata:
    shortDescription: "Improper neutralization of CRLF sequences in HTTP headers ('HTTP
      Response Splitting')"
    category: "security"
    cwe: "CWE-113"
    technology:
    - "java"
    primary_identifier: "find_sec_bugs.HRS_REQUEST_PARAMETER_TO_HTTP_HEADER-1"
    secondary_identifiers:
    - name: "Find Security Bugs-HRS_REQUEST_PARAMETER_TO_HTTP_HEADER"
      type: "find_sec_bugs_type"
      value: "HRS_REQUEST_PARAMETER_TO_HTTP_HEADER"
- id: "find_sec_bugs.TRUST_BOUNDARY_VIOLATION-1"
  languages:
  - "java"
  message: |
    A trust boundary can be thought of as line drawn through a program. On one side
    of the line, data is untrusted. On the other side of the line, data is assumed
    to be trustworthy. The purpose of validation logic is to allow data to safely
    cross the trust boundary - to move from untrusted to trusted. A trust boundary
    violation occurs when a program blurs the line between what is trusted and what
    is untrusted. By combining trusted and untrusted data in the same data
    structure, it becomes easier for programmers to mistakenly trust unvalidated
    data.
  metadata:
    category: "security"
    cwe: "CWE-501"
    shortDescription: "Trust Boundary Violation"
    primary_identifier: "find_sec_bugs.TRUST_BOUNDARY_VIOLATION-1"
    secondary_identifiers:
    - name: "Find Security Bugs-TRUST_BOUNDARY_VIOLATION"
      type: "find_sec_bugs_type"
      value: "TRUST_BOUNDARY_VIOLATION"
  patterns:
  - pattern-either:
    - patterns:
      - pattern: "(HttpServletRequest $H). ... .setAttribute($ARG1, $ARG2);"
      - pattern-not: "(HttpServletRequest $H). ... .setAttribute(\"...\", \"...\");"
    - patterns:
      - pattern: "(HttpServletRequest $H). ... .putValue($ARG1, $ARG2);"
      - pattern-not: "(HttpServletRequest $H). ... .putValue(\"...\", \"...\");"
  severity: "WARNING"
- id: "find_sec_bugs.PERMISSIVE_CORS-1"
  languages:
  - "java"
  message: |
    Prior to HTML5, Web browsers enforced the Same Origin Policy which ensures that in order for
    JavaScript to access the contents of a Web page, both the JavaScript and the Web page must
    originate from the same domain. Without the Same Origin Policy, a malicious website could serve
    up JavaScript that loads sensitive information from other websites using a client's
    credentials, cull through it, and communicate it back to the attacker. HTML5 makes it possible
    for JavaScript to access data across domains if a new HTTP header called
    Access-Control-Allow-Origin is defined. With this header, a Web server defines which other
    domains are allowed to access its domain using cross-origin requests. However, caution should
    be taken when defining the header because an overly permissive CORS policy will allow a
    malicious application to communicate with the victim application in an inappropriate way,
    leading to spoofing, data theft, relay and other attacks.
  metadata:
    category: "security"
    cwe: "CWE-942"
    shortDescription: "Permissive Cross-domain Policy with Untrusted Domains"
    technology:
    - "java"
    primary_identifier: "find_sec_bugs.PERMISSIVE_CORS-1"
    secondary_identifiers:
    - name: "Find Security Bugs-PERMISSIVE_CORS"
      type: "find_sec_bugs_type"
      value: "PERMISSIVE_CORS"
  patterns:
  - pattern-either:
    - pattern: "(HttpServletResponse $RES).setHeader(\"$HEADER\", \"$VAL\")"
    - pattern: "(HttpServletResponse $RES).addHeader(\"$HEADER\", \"$VAL\")"
  - metavariable-regex:
      metavariable: "$HEADER"
      regex: "(?i)(Access-Control-Allow-Origin)"
  - metavariable-regex:
      metavariable: "$VAL"
      regex: "(\\*|null)"
  severity: "ERROR"
- id: "find_sec_bugs.PERMISSIVE_CORS-2"
  languages:
  - "java"
  mode: "taint"
  pattern-sources:
  - pattern: "(HttpServletRequest $REQ).getParamater(...)"
  pattern-sinks:
  - patterns:
    - pattern-either:
      - pattern: "(HttpServletResponse $RES).setHeader(\"$HEADER\", ...)"
      - pattern: "(HttpServletResponse $RES).addHeader(\"$HEADER\", ...)"
    - metavariable-regex:
        metavariable: "$HEADER"
        regex: "(?i)(Access-Control-Allow-Origin)"
  message: |
    This application potentially allows user-supplied input into the value of the
    `Access-Control-Allow-Origin` response header. This header is part of the
    [Cross-Origin Resource Sharing](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) CORS
    specification. By allowing user input to specify which domains can communicate with this
    server,
    an adversary could exploit a weakness in this server to force clients to send credentials (such
    as session
    identifiers) to the adversary's server.

    For the above attack to work, the application would need to suffer from an additional
    vulnerability,
    such as Cross-Site Scripting (XSS).

    To remediate this issue, do not use user-supplied information when calling
    `HttpServletResponse.setHeader` or `HttpServletResponse.addHeader`
    for the `Access-Control-Allow-Origin` header's value. Instead, hardcode the allowed domain(s)
    and reference them in a lookup
    table:
    Example allowing dynamic but safe domains in `Access-Control-Allow-Origin`:

    ```
      // this data should be in the class constructor or taken from a trusted datasource
      Map<String, String> allowedDomains = new HashMap();
      allowedDomains.put("sub1", "sub1.example.com");
      allowedDomains.put("sub2", "sub2.example.com");

      // extract the allowedDomain parameters value as a key to look up which domain to provide
    via the allowedDomains map
      // if not found, sets sub1 as the default
      String headerValue = allowedDomains.getOrDefault(request.getParameter("allowedDomain"),
    allowedDomains.get("sub1"));

      // add the header with our trusted sub1.example.com or sub2.example.com domains.
      response.addHeader("Access-Control-Allow-Origin", headerValue);
    }
    ```

    For more information on `Access-Control-Allow-Origin` see:
    https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Origin
  severity: "ERROR"
  metadata:
    shortDescription: "Permissive cross-domain policy with untrusted domains"
    cwe: "CWE-942"
    category: "security"
    technology:
    - "java"
    primary_identifier: "find_sec_bugs.PERMISSIVE_CORS-2"
    secondary_identifiers:
    - name: "Find Security Bugs-PERMISSIVE_CORS"
      type: "find_sec_bugs_type"
      value: "PERMISSIVE_CORS"
- id: "find_sec_bugs.BLOWFISH_KEY_SIZE-1"
  languages:
  - "java"
  patterns:
  - pattern-inside: |
      $KEYGEN = javax.crypto.KeyGenerator.getInstance("Blowfish", ...);
      ...
      $KEYGEN.init($KEY_SIZE);
  - metavariable-comparison:
      comparison: "$KEY_SIZE < 128"
      metavariable: "$KEY_SIZE"
  message: |
    The Blowfish encryption algorithm was meant as a drop-in replacement for DES and was created in
    1993. Smaller key sizes may make the ciphertext vulnerable to [birthday
    attacks](https://en.wikipedia.org/wiki/Birthday_attack). While no known attacks against
    Blowfish
    exist, it should never be used to encrypt files over 4GB in size. If possible consider
    using AES as the instance of `KeyGenerator` instead of Blowfish.

    To remediate the small key size, pass a value such as 256 to the `KeyGenerator.init(keySize)`
    method.

    Example setting a larger key size and changing to `KeyGenerator` to AES:
    ```
    public static void aesKeyGenerator() throws java.security.NoSuchAlgorithmException {
        // Use the AES algorithm for key generation
        KeyGenerator keyGenerator = KeyGenerator.getInstance("AES");

        // Set the key size here
        keyGenerator.init(256);

        // get the raw bytes of the key
        byte[] key = keyGenerator.generateKey().getEncoded();

        // pass the key bytes to create a SecretKeySpec
        SecretKeySpec secretKeySpec = new SecretKeySpec(key, "AES");
    }
    ```

    Example setting a larger key size for Blowfish:
    ```
    public static void blowFishKeyGenerator() throws java.security.NoSuchAlgorithmException {
        // Use the Blowfish algorithm for key generation
        KeyGenerator keyGenerator = KeyGenerator.getInstance("Blowfish");

        // Set the key size here
        keyGenerator.init(256);

        // get the raw bytes of the key
        byte[] key = keyGenerator.generateKey().getEncoded();

        // pass the key bytes to create a SecretKeySpec
        SecretKeySpec secretKeySpec = new SecretKeySpec(key, "Blowfish");
    }
    ```

    For more information on Java Cryptography see:
    https://docs.oracle.com/en/java/javase/15/security/java-cryptography-architecture-jca-reference-guide.html
  severity: "WARNING"
  metadata:
    category: "security"
    shortDescription: "Inadequate encryption strength"
    cwe: "CWE-326"
    technology:
    - "java"
    primary_identifier: "find_sec_bugs.BLOWFISH_KEY_SIZE-1"
    secondary_identifiers:
    - name: "Find Security Bugs-BLOWFISH_KEY_SIZE"
      type: "find_sec_bugs_type"
      value: "BLOWFISH_KEY_SIZE"
- id: "find_sec_bugs.DES_USAGE-1"
  languages:
  - "java"
  patterns:
  - pattern-inside: |-
      javax.crypto.Cipher.getInstance("$ALG")
  - metavariable-regex:
      metavariable: "$ALG"
      regex: "^(DES)/.*"
  message: |
    DES, TripleDES and RC2 are all considered broken or insecure cryptographic algorithms.
    Newer algorithms  apply message integrity to validate ciphertext has not been tampered
    with. Consider using `ChaCha20Poly1305` instead as it is easier and faster than the
    alternatives such as `AES-256-GCM`.

    For older applications that don't have support for `ChaCha20Poly1305`,
    `AES-256-GCM` is recommended, however it has many drawbacks:
    - Slower than `ChaCha20Poly1305`.
    - Catastrophic failure if nonce values are reused.

    Example using `ChaCha20Poly1305`:
    ```
    public encrypt() throws Exception {
        chaChaEncryption("Secret text to encrypt".getBytes(StandardCharsets.UTF_8));
    }

    public SecureRandom getSecureRandomDRBG() throws NoSuchAlgorithmException {
        // Use DRBG according to
    http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-90Ar1.pdf
        return SecureRandom.getInstance("DRBG",
                // Security strength in bits (default is 128)
                DrbgParameters.instantiation(256,
                    // Set prediction resistance and re-seeding
                    DrbgParameters.Capability.PR_AND_RESEED,
                    // Set the personalization string (optional, not necessary)
                    "some_personalization_string".getBytes()
                )
        );
    }

    public Cipher getChaCha20Poly1305(int mode, byte[] ivKey, byte[] secretKey) throws
    NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException,
    InvalidAlgorithmParameterException  {
        // Get a DRBG random number generator instance
        SecureRandom random = getSecureRandomDRBG();
        // Create a ChaCha20-Poly1305 cipher instance
        Cipher chaChaCipher = Cipher.getInstance("ChaCha20-Poly1305/None/NoPadding");
        // Create our parameterSpec using our ivKey
        AlgorithmParameterSpec parameterSpec = new IvParameterSpec(ivKey);
        // Create a SecretKeySpec using our secretKey
        SecretKeySpec secretKeySpec = new SecretKeySpec(secretKey, "ChaCha20");
        // Initialize and return the cipher for the provided mode
        chaChaCipher.init(mode, secretKeySpec, parameterSpec, random);
        return chaChaCipher;
    }

    public void chaChaEncryption(byte[] plainText) throws NoSuchAlgorithmException,
    NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException {
        // Get a DRBG random number generator instance
        SecureRandom random = getSecureRandomDRBG();
        // Create secretKey
        byte[] secretKey = new byte[32];
        random.nextBytes(secretKey);
        // Create an IV Key
        byte[] ivKey = new byte[12];
        random.nextBytes(ivKey);

        // Create a chaCha encryption cipher instance
        Cipher chaChaEncryptor = getChaCha20Poly1305(Cipher.ENCRYPT_MODE, ivKey, secretKey);

        // Encrypt the text using ChaCha20Poly1305
        byte[] cipherText = null;
        try {
            cipherText = chaChaEncryptor.doFinal(plainText);
        } catch (IllegalBlockSizeException | BadPaddingException e) {
            System.out.println("failed to encrypt text");
            return;
        }
        System.out.println("encrypted: " + Base64.getEncoder().encodeToString(cipherText));

         // Create a chaCha decryption cipher instance
        Cipher chaChaDecryptor = getChaCha20Poly1305(Cipher.DECRYPT_MODE, ivKey, secretKey);

        // Decrypt the text
        byte[] decryptedText = null;
        try {
            decryptedText = chaChaDecryptor.doFinal(cipherText);
        } catch (IllegalBlockSizeException | BadPaddingException e) {
            System.out.println("failed to decrypt text");
            return;
        }
        System.out.println("decrypted: " + new String(decryptedText, StandardCharsets.UTF_8));
    }
    ```

    For more information on Java Cryptography see:
    https://docs.oracle.com/en/java/javase/15/security/java-cryptography-architecture-jca-reference-guide.html
  severity: "WARNING"
  metadata:
    shortDescription: "Inadequate encryption strength"
    category: "security"
    cwe: "CWE-326"
    technology:
    - "java"
    primary_identifier: "find_sec_bugs.DES_USAGE-1"
    secondary_identifiers:
    - name: "Find Security Bugs-DES_USAGE"
      type: "find_sec_bugs_type"
      value: "DES_USAGE"
- id: "find_sec_bugs.TDES_USAGE-1"
  languages:
  - "java"
  patterns:
  - pattern-inside: |-
      javax.crypto.Cipher.getInstance("$ALG")
  - metavariable-regex:
      metavariable: "$ALG"
      regex: "^(DESede)/.*"
  message: |
    DES, TripleDES and RC2 are all considered broken or insecure cryptographic algorithms.
    Newer algorithms  apply message integrity to validate ciphertext has not been tampered
    with. Consider using `ChaCha20Poly1305` instead as it is easier and faster than the
    alternatives such as `AES-256-GCM`.

    For older applications that don't have support for `ChaCha20Poly1305`,
    `AES-256-GCM` is recommended, however it has many drawbacks:
    - Slower than `ChaCha20Poly1305`.
    - Catastrophic failure if nonce values are reused.

    Example using `ChaCha20Poly1305`:
    ```
    public encrypt() throws Exception {
        chaChaEncryption("Secret text to encrypt".getBytes(StandardCharsets.UTF_8));
    }

    public SecureRandom getSecureRandomDRBG() throws NoSuchAlgorithmException {
        // Use DRBG according to
    http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-90Ar1.pdf
        return SecureRandom.getInstance("DRBG",
                // Security strength in bits (default is 128)
                DrbgParameters.instantiation(256,
                    // Set prediction resistance and re-seeding
                    DrbgParameters.Capability.PR_AND_RESEED,
                    // Set the personalization string (optional, not necessary)
                    "some_personalization_string".getBytes()
                )
        );
    }

    public Cipher getChaCha20Poly1305(int mode, byte[] nonceKey, byte[] secretKey) throws
    NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException,
    InvalidAlgorithmParameterException  {
        // Get a DRBG random number generator instance
        SecureRandom random = getSecureRandomDRBG();
        // Create a ChaCha20-Poly1305 cipher instance
        Cipher chaChaCipher = Cipher.getInstance("ChaCha20-Poly1305/None/NoPadding");
        // Create our parameterSpec using our nonceKey
        AlgorithmParameterSpec parameterSpec = new IvParameterSpec(nonceKey);
        // Create a SecretKeySpec using our secretKey
        SecretKeySpec secretKeySpec = new SecretKeySpec(secretKey, "ChaCha20");
        // Initialize and return the cipher for the provided mode
        chaChaCipher.init(mode, secretKeySpec, parameterSpec, random);
        return chaChaCipher;
    }

    public void chaChaEncryption(byte[] plainText) throws NoSuchAlgorithmException,
    NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException {
        // Get a DRBG random number generator instance
        SecureRandom random = getSecureRandomDRBG();
        // Create secretKey
        byte[] secretKey = new byte[32];
        random.nextBytes(secretKey);
        // Create an IV nonceKey
        byte[] nonceKey = new byte[12];
        random.nextBytes(nonceKey);
        // Create a chaCha encryption cipher instance
        Cipher chaChaEncryptor = getChaCha20Poly1305(Cipher.ENCRYPT_MODE, nonceKey, secretKey);
        // Encrypt the text using ChaCha20Poly1305
        byte[] cipherText = null;
        try {
            cipherText = chaChaEncryptor.doFinal(plainText);
        } catch (IllegalBlockSizeException | BadPaddingException e) {
            System.out.println("failed to encrypt text");
            return;
        }
        System.out.println("encrypted: " + Base64.getEncoder().encodeToString(cipherText));
        // Create a chaCha decryption cipher instance
        Cipher chaChaDecryptor = getChaCha20Poly1305(Cipher.DECRYPT_MODE, nonceKey, secretKey);
        // Decrypt the text
        byte[] decryptedText = null;
        try {
            decryptedText = chaChaDecryptor.doFinal(cipherText);
        } catch (IllegalBlockSizeException | BadPaddingException e) {
            System.out.println("failed to decrypt text");
            return;
        }
        System.out.println("decrypted: " + new String(decryptedText, StandardCharsets.UTF_8));
    }
    ```

    For more information on Java Cryptography see:
    https://docs.oracle.com/en/java/javase/15/security/java-cryptography-architecture-jca-reference-guide.html
  severity: "WARNING"
  metadata:
    shortDescription: "Use of a broken or risky cryptographic algorithm"
    category: "security"
    cwe: "CWE-327"
    technology:
    - "java"
    primary_identifier: "find_sec_bugs.TDES_USAGE-1"
    secondary_identifiers:
    - name: "Find Security Bugs-TDES_USAGE"
      type: "find_sec_bugs_type"
      value: "TDES_USAGE"
- id: "find_sec_bugs.ECB_MODE-1"
  languages:
  - "java"
  patterns:
  - pattern-inside: |-
      javax.crypto.Cipher.getInstance("...")
  - pattern-regex: "(AES|DES(ede)?)(/ECB/*)"
  message: |
    Cryptographic algorithms provide many different modes of operation, only some of which provide
    message integrity. Without message integrity it could be possible for an adversary to attempt
    to tamper with the ciphertext which could lead to compromising the encryption key. Newer
    algorithms
    apply message integrity to validate ciphertext has not been tampered with.

    Instead of using an algorithm that requires configuring a cipher mode, an algorithm
    that has built-in message integrity should be used. Consider using `ChaCha20Poly1305` or
    `AES-256-GCM` instead.

    For older applications that don't have support for `ChaCha20Poly1305`, `AES-256-GCM` is
    recommended, however it has many drawbacks:
      - Slower than `ChaCha20Poly1305`.
      - Catastrophic failure if nonce values are reused.

    Example using `ChaCha20Poly1305`:
    ```
    public encrypt() throws Exception {
        chaChaEncryption("Secret text to encrypt".getBytes(StandardCharsets.UTF_8));
    }

    public SecureRandom getSecureRandomDRBG() throws NoSuchAlgorithmException {
        // Use DRBG according to
    http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-90Ar1.pdf
        return SecureRandom.getInstance("DRBG",
                // Security strength in bits (default is 128)
                DrbgParameters.instantiation(256,
                    // Set prediction resistance and re-seeding
                    DrbgParameters.Capability.PR_AND_RESEED,
                    // Set the personalization string (optional, not necessary)
                    "some_personalization_string".getBytes()
                )
        );
    }

    public Cipher getChaCha20Poly1305(int mode, byte[] ivKey, byte[] secretKey) throws
    NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException,
    InvalidAlgorithmParameterException  {
        // Get a DRBG random number generator instance
        SecureRandom random = getSecureRandomDRBG();
        // Create a ChaCha20-Poly1305 cipher instance
        Cipher chaChaCipher = Cipher.getInstance("ChaCha20-Poly1305/None/NoPadding");
        // Create our parameterSpec using our ivKey
        AlgorithmParameterSpec parameterSpec = new IvParameterSpec(ivKey);
        // Create a SecretKeySpec using our secretKey
        SecretKeySpec secretKeySpec = new SecretKeySpec(secretKey, "ChaCha20");
        // Initialize and return the cipher for the provided mode
        chaChaCipher.init(mode, secretKeySpec, parameterSpec, random);
        return chaChaCipher;
    }

    public void chaChaEncryption(byte[] plainText) throws NoSuchAlgorithmException,
    NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException {
        // Get a DRBG random number generator instance
        SecureRandom random = getSecureRandomDRBG();
        // Create secretKey
        byte[] secretKey = new byte[32];
        random.nextBytes(secretKey);
        // Create an IV Key
        byte[] ivKey = new byte[12];
        random.nextBytes(ivKey);

        // Create a chaCha encryption cipher instance
        Cipher chaChaEncryptor = getChaCha20Poly1305(Cipher.ENCRYPT_MODE, ivKey, secretKey);

        // Encrypt the text using ChaCha20Poly1305
        byte[] cipherText = null;
        try {
            cipherText = chaChaEncryptor.doFinal(plainText);
        } catch (IllegalBlockSizeException | BadPaddingException e) {
            System.out.println("failed to encrypt text");
            return;
        }
        System.out.println("encrypted: " + Base64.getEncoder().encodeToString(cipherText));

         // Create a chaCha decryption cipher instance
        Cipher chaChaDecryptor = getChaCha20Poly1305(Cipher.DECRYPT_MODE, ivKey, secretKey);

        // Decrypt the text
        byte[] decryptedText = null;
        try {
            decryptedText = chaChaDecryptor.doFinal(cipherText);
        } catch (IllegalBlockSizeException | BadPaddingException e) {
            System.out.println("failed to decrypt text");
            return;
        }
        System.out.println("decrypted: " + new String(decryptedText, StandardCharsets.UTF_8));
    }
    ```

    For more information on Java Cryptography see:
    https://docs.oracle.com/en/java/javase/15/security/java-cryptography-architecture-jca-reference-guide.html
  severity: "ERROR"
  metadata:
    shortDescription: "Use of a broken or risky cryptographic algorithm"
    category: "security"
    cwe: "CWE-327"
    technology:
    - "java"
    primary_identifier: "find_sec_bugs.ECB_MODE-1"
    secondary_identifiers:
    - name: "Find Security Bugs-ECB_MODE"
      type: "find_sec_bugs_type"
      value: "ECB_MODE"
- id: "find_sec_bugs.CIPHER_INTEGRITY-1"
  languages:
  - "java"
  patterns:
  - pattern-inside: |-
      javax.crypto.Cipher.getInstance("...")
  - pattern-either:
    - pattern-regex: "(/CBC/PKCS5Padding)"
    - pattern-regex: "(AES|DES(ede)?)(/ECB/*)"
  - pattern-not-regex: ".*/(CCM|CWC|OCB|EAX|GCM)/.*"
  - pattern-not-regex: "^(RSA)/.*"
  - pattern-not-regex: "^(ECIES)$"
  message: |
    Cryptographic algorithms provide many different modes of operation, only some of which provide
    message integrity. Without message integrity it could be possible for an adversary to attempt
    to tamper with the ciphertext which could lead to compromising the encryption key. Newer
    algorithms
    apply message integrity to validate ciphertext has not been tampered with.

    Instead of using an algorithm that requires configuring a cipher mode, an algorithm
    that has built-in message integrity should be used. Consider using `ChaCha20Poly1305` or
    `AES-256-GCM` instead.

    For older applications that don't have support for `ChaCha20Poly1305`, `AES-256-GCM` is
    recommended, however it has many drawbacks:
      - Slower than `ChaCha20Poly1305`.
      - Catastrophic failure if nonce values are reused.

    Example using `ChaCha20Poly1305`:
    ```
    public encrypt() throws Exception {
        chaChaEncryption("Secret text to encrypt".getBytes(StandardCharsets.UTF_8));
    }

    public SecureRandom getSecureRandomDRBG() throws NoSuchAlgorithmException {
    // Use DRBG according to
    http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-90Ar1.pdf
        return SecureRandom.getInstance("DRBG",
                // Security strength in bits (default is 128)
                DrbgParameters.instantiation(256,
                    // Set prediction resistance and re-seeding
                    DrbgParameters.Capability.PR_AND_RESEED,
                    // Set the personalization string (optional, not necessary)
                    "some_personalization_string".getBytes()
                )
        );
    }

    public Cipher getChaCha20Poly1305(int mode, byte[] ivKey, byte[] secretKey) throws
    NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException,
    InvalidAlgorithmParameterException  {
        // Get a DRBG random number generator instance
        SecureRandom random = getSecureRandomDRBG();
        // Create a ChaCha20-Poly1305 cipher instance
        Cipher chaChaCipher = Cipher.getInstance("ChaCha20-Poly1305/None/NoPadding");
        // Create our parameterSpec using our ivKey
        AlgorithmParameterSpec parameterSpec = new IvParameterSpec(ivKey);
        // Create a SecretKeySpec using our secretKey
        SecretKeySpec secretKeySpec = new SecretKeySpec(secretKey, "ChaCha20");
        // Initialize and return the cipher for the provided mode
        chaChaCipher.init(mode, secretKeySpec, parameterSpec, random);
        return chaChaCipher;
    }

    public void chaChaEncryption(byte[] plainText) throws NoSuchAlgorithmException,
    NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException {
        // Get a DRBG random number generator instance
        SecureRandom random = getSecureRandomDRBG();
        // Create secretKey
        byte[] secretKey = new byte[32];
        random.nextBytes(secretKey);
        // Create an IV Key
        byte[] ivKey = new byte[12];
        random.nextBytes(ivKey);

        // Create a chaCha encryption cipher instance
        Cipher chaChaEncryptor = getChaCha20Poly1305(Cipher.ENCRYPT_MODE, ivKey, secretKey);

        // Encrypt the text using ChaCha20Poly1305
        byte[] cipherText = null;
        try {
            cipherText = chaChaEncryptor.doFinal(plainText);
        } catch (IllegalBlockSizeException | BadPaddingException e) {
            System.out.println("failed to encrypt text");
            return;
        }
        System.out.println("encrypted: " + Base64.getEncoder().encodeToString(cipherText));

         // Create a chaCha decryption cipher instance
        Cipher chaChaDecryptor = getChaCha20Poly1305(Cipher.DECRYPT_MODE, ivKey, secretKey);

        // Decrypt the text
        byte[] decryptedText = null;
        try {
            decryptedText = chaChaDecryptor.doFinal(cipherText);
        } catch (IllegalBlockSizeException | BadPaddingException e) {
            System.out.println("failed to decrypt text");
            return;
        }
        System.out.println("decrypted: " + new String(decryptedText, StandardCharsets.UTF_8));
    }
    ```

    For more information on Java Cryptography see:
    https://docs.oracle.com/en/java/javase/15/security/java-cryptography-architecture-jca-reference-guide.html
  severity: "ERROR"
  metadata:
    shortDescription: "Use of a broken or risky cryptographic algorithm"
    category: "security"
    cwe: "CWE-327"
    technology:
    - "java"
    primary_identifier: "find_sec_bugs.CIPHER_INTEGRITY-1"
    secondary_identifiers:
    - name: "Find Security Bugs-CIPHER_INTEGRITY"
      type: "find_sec_bugs_type"
      value: "CIPHER_INTEGRITY"
- id: "find_sec_bugs.PADDING_ORACLE-1"
  languages:
  - "java"
  patterns:
  - pattern-inside: |-
      javax.crypto.Cipher.getInstance("...")
  - pattern-regex: "(/CBC/PKCS5Padding)"
  - pattern-not-regex: "^(RSA)/.*"
  - pattern-not-regex: "^(ECIES)$"
  message: |
    Cryptographic block ciphers can be configured to pad individual blocks if there is not enough
    input data to match the size of the block. This specific mode of CBC used in combination with
    PKCS5Padding is susceptible to padding oracle attacks. An adversary could potentially decrypt
    the message if the system exposed the difference between plaintext with invalid padding or
    valid padding. The distinction between valid and invalid padding is usually revealed through
    distinct error messages being returned for each condition.

    Consider switching to a more secure cipher that doesn't require padding and builds in message
    authentication integrity directly into the algorithm.

    Consider using `ChaCha20Poly1305` or
    `AES-256-GCM` instead.

    For older applications that don't have support for `ChaCha20Poly1305`, `AES-256-GCM` is
    recommended, however it has many drawbacks:
      - Slower than `ChaCha20Poly1305`.
      - Catastrophic failure if nonce values are reused.

    Example using `ChaCha20Poly1305`:
    ```
    public encrypt() throws Exception {
        chaChaEncryption("Secret text to encrypt".getBytes(StandardCharsets.UTF_8));
    }

    public SecureRandom getSecureRandomDRBG() throws NoSuchAlgorithmException {
        // Use DRBG according to
    http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-90Ar1.pdf
        return SecureRandom.getInstance("DRBG",
                // Security strength in bits (default is 128)
                DrbgParameters.instantiation(256,
                    // Set prediction resistance and re-seeding
                    DrbgParameters.Capability.PR_AND_RESEED,
                    // Set the personalization string (optional, not necessary)
                    "some_personalization_string".getBytes()
                )
        );
    }

    public Cipher getChaCha20Poly1305(int mode, byte[] ivKey, byte[] secretKey) throws
    NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException,
    InvalidAlgorithmParameterException  {
        // Get a DRBG random number generator instance
        SecureRandom random = getSecureRandomDRBG();
        // Create a ChaCha20-Poly1305 cipher instance
        Cipher chaChaCipher = Cipher.getInstance("ChaCha20-Poly1305/None/NoPadding");
        // Create our parameterSpec using our ivKey
        AlgorithmParameterSpec parameterSpec = new IvParameterSpec(ivKey);
        // Create a SecretKeySpec using our secretKey
        SecretKeySpec secretKeySpec = new SecretKeySpec(secretKey, "ChaCha20");
        // Initialize and return the cipher for the provided mode
        chaChaCipher.init(mode, secretKeySpec, parameterSpec, random);
        return chaChaCipher;
    }

    public void chaChaEncryption(byte[] plainText) throws NoSuchAlgorithmException,
    NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException {
        // Get a DRBG random number generator instance
        SecureRandom random = getSecureRandomDRBG();
        // Create secretKey
        byte[] secretKey = new byte[32];
        random.nextBytes(secretKey);
        // Create an IV Key
        byte[] ivKey = new byte[12];
        random.nextBytes(ivKey);

        // Create a chaCha encryption cipher instance
        Cipher chaChaEncryptor = getChaCha20Poly1305(Cipher.ENCRYPT_MODE, ivKey, secretKey);

        // Encrypt the text using ChaCha20Poly1305
        byte[] cipherText = null;
        try {
            cipherText = chaChaEncryptor.doFinal(plainText);
        } catch (IllegalBlockSizeException | BadPaddingException e) {
            System.out.println("failed to encrypt text");
            return;
        }
        System.out.println("encrypted: " + Base64.getEncoder().encodeToString(cipherText));

         // Create a chaCha decryption cipher instance
        Cipher chaChaDecryptor = getChaCha20Poly1305(Cipher.DECRYPT_MODE, ivKey, secretKey);

        // Decrypt the text
        byte[] decryptedText = null;
        try {
            decryptedText = chaChaDecryptor.doFinal(cipherText);
        } catch (IllegalBlockSizeException | BadPaddingException e) {
            System.out.println("failed to decrypt text");
            return;
        }
        System.out.println("decrypted: " + new String(decryptedText, StandardCharsets.UTF_8));
    }
    ```

    For more information on padding oracle attacks see:
    https://en.wikipedia.org/wiki/Padding_oracle_attack

    For more information on Java Cryptography see:
    https://docs.oracle.com/en/java/javase/15/security/java-cryptography-architecture-jca-reference-guide.html
  severity: "ERROR"
  metadata:
    shortDescription: "Use of a broken or risky cryptographic algorithm"
    category: "security"
    cwe: "CWE-327"
    technology:
    - "java"
    primary_identifier: "find_sec_bugs.PADDING_ORACLE-1"
    secondary_identifiers:
    - name: "Find Security Bugs-PADDING_ORACLE"
      type: "find_sec_bugs_type"
      value: "PADDING_ORACLE"
- id: "find_sec_bugs.CUSTOM_MESSAGE_DIGEST-1"
  languages:
  - "java"
  patterns:
  - pattern: |
      class $CLAZZ extends java.security.MessageDigest {
        ...
      }
  message: |
    The application was found implementing a custom `java.security.MessageDigest`. It is
    strongly recommended that a standard Digest algorithm be chosen instead as implementing
    a digest by hand is error-prone. The National Institute of Standards and
    Technology (NIST) recommends the use of SHA-224, SHA-256, SHA-384, SHA-512, SHA-512/224, or
    SHA-512/256.

    Example of creating a SHA-384 hash:
    ```
    // Create a MessageDigest using the SHA-384 algorithm
    MessageDigest sha384Digest = MessageDigest.getInstance("SHA-384");
    // Call update with your data
    sha384Digest.update(input);
    // Only call digest once all data has been fed into the update sha384digest instance
    byte[] output = sha384Digest.digest();
    // output base64 encoded version of the hash
    System.out.println("hash: " + Base64.getEncoder().encodeToString(output));
    ```
  severity: "WARNING"
  metadata:
    shortDescription: "Use of a broken or risky cryptographic algorithm"
    category: "security"
    cwe: "CWE-327"
    technology:
    - "java"
    primary_identifier: "find_sec_bugs.CUSTOM_MESSAGE_DIGEST-1"
    secondary_identifiers:
    - name: "Find Security Bugs-CUSTOM_MESSAGE_DIGEST"
      type: "find_sec_bugs_type"
      value: "CUSTOM_MESSAGE_DIGEST"
- id: "find_sec_bugs.DEFAULT_HTTP_CLIENT-1"
  patterns:
  - pattern: "new org.apache.http.impl.client.DefaultHttpClient(...);"
  message: |
    DefaultHttpClient with default constructor is not compatible with TLS 1.2
  languages:
  - "java"
  severity: "WARNING"
  metadata:
    shortDescription: "Inadequate encryption strength"
    category: "security"
    cwe: "CWE-326"
    technology:
    - "java"
    primary_identifier: "find_sec_bugs.DEFAULT_HTTP_CLIENT-1"
    secondary_identifiers:
    - name: "Find Security Bugs-DEFAULT_HTTP_CLIENT"
      type: "find_sec_bugs_type"
      value: "DEFAULT_HTTP_CLIENT"
- id: "find_sec_bugs.HAZELCAST_SYMMETRIC_ENCRYPTION-1"
  languages:
  - "java"
  patterns:
  - pattern: "new com.hazelcast.config.SymmetricEncryptionConfig()"
  message: |
    The network communications for Hazelcast is configured to use a deprecated symmetric cipher.
    Consider using TLS/SSL when establishing communications across the Hazelcast cluster.

    For more information on configuring TLS/SSL for Hazelcast see:
    https://docs.hazelcast.com/imdg/4.2/security/tls-ssl
  severity: "WARNING"
  metadata:
    shortDescription: "Inadequate encryption strength"
    category: "security"
    cwe: "CWE-326"
    technology:
    - "java"
    primary_identifier: "find_sec_bugs.HAZELCAST_SYMMETRIC_ENCRYPTION-1"
    secondary_identifiers:
    - name: "Find Security Bugs-HAZELCAST_SYMMETRIC_ENCRYPTION"
      type: "find_sec_bugs_type"
      value: "HAZELCAST_SYMMETRIC_ENCRYPTION"
- id: "find_sec_bugs.RSA_KEY_SIZE-1"
  languages:
  - "java"
  patterns:
  - pattern-either:
    - patterns:
      - pattern-inside: |
          $GEN = KeyPairGenerator.getInstance($ALG, ...);
          ...
      - pattern-either:
        - pattern: "$VAR.initialize($SIZE, ...);"
        - pattern: "new java.security.spec.RSAKeyGenParameterSpec($SIZE,...);"
      - metavariable-comparison:
          comparison: "$SIZE < 2048"
          metavariable: "$SIZE"
      - metavariable-regex:
          metavariable: "$ALG"
          regex: "\"(RSA|DSA)\""
  message: |
    The application is generating an RSA key that is less than the recommended 2048 bits.
    The National Institute of Standards and Technology (NIST) deprecated signing Digital
    Certificates that contained RSA Public Keys of 1024 bits in December 2010. While
    1024-bit RSA keys have not been factored yet, advances in compute may make it possible
    in the near future.

    Consider upgrading to the newer asymmetric algorithm such as `Ed25519` which handles
    the complexities of generating key pairs and choosing correct key sizes for you:
    ```
    public static KeyPair generateEd25519() throws NoSuchAlgorithmException {
        // Choose Ed25519 for KeyPairGenerator Instance
        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance("Ed25519");
        // Generate a KeyPair and return
        return keyPairGenerator.generateKeyPair();
    }
    ```

    Otherwise use a key size greater than 2048 when generating RSA keys:
    ```
    public static KeyPair generateRSA() throws NoSuchAlgorithmException {
        // Choose RSA for KeyPairGenerator Instance
        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance("RSA");
        // Initialize with 2048 key size
        keyPairGenerator.initialize(2048);
        // Generate a KeyPair and return
        return keyPairGenerator.generateKeyPair();
    }
    ```

    For more information on Ed25519 see: http://ed25519.cr.yp.to/

    For more information on Java Cryptography see:
    https://docs.oracle.com/en/java/javase/15/security/java-cryptography-architecture-jca-reference-guide.html
  metadata:
    shortDescription: "Inadequate encryption strength"
    category: "security"
    cwe: "CWE-326"
    primary_identifier: "find_sec_bugs.RSA_KEY_SIZE-1"
    secondary_identifiers:
    - name: "Find Security Bugs-RSA_KEY_SIZE"
      type: "find_sec_bugs_type"
      value: "RSA_KEY_SIZE"
  severity: "WARNING"
- id: "find_sec_bugs.NULL_CIPHER-1"
  languages:
  - "java"
  pattern: "new javax.crypto.NullCipher()"
  message: |
    The application was found creating a `NullCipher` instance. `NullCipher` implements the
    `Cipher` interface by returning ciphertext identical to the supplied plaintext. This means
    any data passed to the `doFinal(...)` or `update(...)` methods will not actually encrypt
    the input.

    Remove the NullCipher reference and replace with a legitimate `Cipher` instance such as
    `ChaCha20-Poly1305`

    Example using `ChaCha20Poly1305`:
    ```
    public encrypt() throws Exception {
        chaChaEncryption("Secret text to encrypt".getBytes(StandardCharsets.UTF_8));
    }

    public SecureRandom getSecureRandomDRBG() throws NoSuchAlgorithmException {
        // Use DRBG according to
    http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-90Ar1.pdf
        return SecureRandom.getInstance("DRBG",
                // Security strength in bits (default is 128)
                DrbgParameters.instantiation(256,
                    // Set prediction resistance and re-seeding
                    DrbgParameters.Capability.PR_AND_RESEED,
                    // Set the personalization string (optional, not necessary)
                    "some_personalization_string".getBytes()
                )
        );
    }

    public Cipher getChaCha20Poly1305(int mode, byte[] ivKey, byte[] secretKey) throws
    NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException,
    InvalidAlgorithmParameterException  {
        // Get a DRBG random number generator instance
        SecureRandom random = getSecureRandomDRBG();
        // Create a ChaCha20-Poly1305 cipher instance
        Cipher chaChaCipher = Cipher.getInstance("ChaCha20-Poly1305/None/NoPadding");
        // Create our parameterSpec using our ivKey
        AlgorithmParameterSpec parameterSpec = new IvParameterSpec(ivKey);
        // Create a SecretKeySpec using our secretKey
        SecretKeySpec secretKeySpec = new SecretKeySpec(secretKey, "ChaCha20");
        // Initialize and return the cipher for the provided mode
        chaChaCipher.init(mode, secretKeySpec, parameterSpec, random);
        return chaChaCipher;
    }

    public void chaChaEncryption(byte[] plainText) throws NoSuchAlgorithmException,
    NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException {
        // Get a DRBG random number generator instance
        SecureRandom random = getSecureRandomDRBG();
        // Create secretKey
        byte[] secretKey = new byte[32];
        random.nextBytes(secretKey);
        // Create an IV Key
        byte[] ivKey = new byte[12];
        random.nextBytes(ivKey);

        // Create a chaCha encryption cipher instance
        Cipher chaChaEncryptor = getChaCha20Poly1305(Cipher.ENCRYPT_MODE, ivKey, secretKey);

        // Encrypt the text using ChaCha20Poly1305
        byte[] cipherText = null;
        try {
            cipherText = chaChaEncryptor.doFinal(plainText);
        } catch (IllegalBlockSizeException | BadPaddingException e) {
            System.out.println("failed to encrypt text");
            return;
        }
        System.out.println("encrypted: " + Base64.getEncoder().encodeToString(cipherText));

         // Create a chaCha decryption cipher instance
        Cipher chaChaDecryptor = getChaCha20Poly1305(Cipher.DECRYPT_MODE, ivKey, secretKey);

        // Decrypt the text
        byte[] decryptedText = null;
        try {
            decryptedText = chaChaDecryptor.doFinal(cipherText);
        } catch (IllegalBlockSizeException | BadPaddingException e) {
            System.out.println("failed to decrypt text");
            return;
        }
        System.out.println("decrypted: " + new String(decryptedText, StandardCharsets.UTF_8));
    }
    ```

    For more information on Java Cryptography see:
    https://docs.oracle.com/en/java/javase/15/security/java-cryptography-architecture-jca-reference-guide.html
  severity: "WARNING"
  metadata:
    shortDescription: "Use of a broken or risky cryptographic algorithm"
    category: "security"
    cwe: "CWE-327"
    technology:
    - "java"
    primary_identifier: "find_sec_bugs.NULL_CIPHER-1"
    secondary_identifiers:
    - name: "Find Security Bugs-NULL_CIPHER"
      type: "find_sec_bugs_type"
      value: "NULL_CIPHER"
- id: "find_sec_bugs.RSA_NO_PADDING-1"
  languages:
  - "java"
  patterns:
  - pattern: "javax.crypto.Cipher.getInstance($ALG,...);"
  - metavariable-regex:
      metavariable: "$ALG"
      regex: ".*NoPadding.*"
  message: |
    The software uses the RSA algorithm but does not incorporate Optimal Asymmetric
    Encryption Padding (OAEP). By not enabling padding, the algorithm maybe vulnerable
    to [chosen plaintext attacks](https://en.wikipedia.org/wiki/Chosen-plaintext_attack).

    To enable OAEP mode, pass `RSA/ECB/OAEPWithSHA-256AndMGF1Padding` to the `Cipher.getInstance`
    method.

    Example encrypting and decrypting a message using RSA with OAEP:
    ```
    public static void encryptWithRSA() throws InvalidKeyException, NoSuchAlgorithmException,
    NoSuchPaddingException, IllegalBlockSizeException, BadPaddingException {
        // Generate an RSA Public and Private Key Pair
        KeyPair keyPair = generateRSAKeys();
        // Create a Cipher instance using RSA, ECB with OAEP
        Cipher rsaEncryptor = Cipher.getInstance("RSA/ECB/OAEPWithSHA-256AndMGF1Padding");
        // Initialize to ENCRYPT_MODE with the public key
        rsaEncryptor.init(Cipher.ENCRYPT_MODE, keyPair.getPublic());
        // Encrypt our secret message
        byte[] cipherText = rsaEncryptor.doFinal("Some secret
    message".getBytes(StandardCharsets.UTF_8));

        // Create a Cipher instance using RSA, ECB with OAEP
        Cipher rsaDecryptor = Cipher.getInstance("RSA/ECB/OAEPWithSHA-256AndMGF1Padding");
        // Initialize to DECRYPT_MODE with the private key
        rsaDecryptor.init(Cipher.DECRYPT_MODE, keyPair.getPrivate());
        // Decrypt the secret message
        byte[] plainText = rsaDecryptor.doFinal(cipherText);
        // Debug output
        System.out.println(new String(plainText));
    }
    ```
    More information on Optimal asymmetric encryption padding:
    https://en.wikipedia.org/wiki/Optimal_asymmetric_encryption_padding

    For more information on Java Cryptography see:
    https://docs.oracle.com/en/java/javase/15/security/java-cryptography-architecture-jca-reference-guide.html
  metadata:
    shortDescription: "Use of RSA algorithm without OAEP"
    category: "security"
    cwe: "CWE-780"
    primary_identifier: "find_sec_bugs.RSA_NO_PADDING-1"
    secondary_identifiers:
    - name: "Find Security Bugs-RSA_NO_PADDING"
      type: "find_sec_bugs_type"
      value: "RSA_NO_PADDING"
  severity: "WARNING"
- id: "find_sec_bugs.WEAK_MESSAGE_DIGEST_MD5-1.WEAK_MESSAGE_DIGEST_SHA1-1"
  languages:
  - "java"
  patterns:
  - pattern-either:
    - pattern: "MessageDigest.getInstance($ALG, ...)"
    - pattern: "Signature.getInstance($ALG, ...)"
  - metavariable-regex:
      metavariable: "$ALG"
      regex: ".*(MD5|MD4|MD2|SHA1|SHA-1).*"
  message: |
    The application was found using an insecure or risky digest or signature algorithm. Both MD5
    and SHA1 hash algorithms have been found to be vulnerable to producing collisions.
    This means
    that two different values, when hashed, can lead to the same hash value. If the application is
    trying
    to use these hash methods for storing passwords, then it is recommended to switch to a
    password hashing
    algorithm such as Argon2id or PBKDF2.
    strongly recommended that a standard Digest algorithm be chosen instead as implementing
    a digest by hand is error-prone.

    Example of creating a SHA-384 hash:
    ```
    // Create a MessageDigest using the SHA-384 algorithm
    MessageDigest sha384Digest = MessageDigest.getInstance("SHA-384");
    // Call update with your data
    sha384Digest.update(input);
    // Only call digest once all data has been fed into the update sha384digest instance
    byte[] output = sha384Digest.digest();
    // output base64 encoded version of the hash
    System.out.println("hash: " + Base64.getEncoder().encodeToString(output));
    ```

    For more information on secure password storage see OWASP:
    https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html
  severity: "WARNING"
  metadata:
    shortDescription: "Use of a broken or risky cryptographic algorithm (SHA1/MD5)"
    category: "security"
    cwe: "CWE-327"
    technology:
    - "java"
    primary_identifier: "find_sec_bugs.WEAK_MESSAGE_DIGEST_MD5-1.WEAK_MESSAGE_DIGEST_SHA1-1"
    secondary_identifiers:
    - name: "Find Security Bugs-WEAK_MESSAGE_DIGEST_MD5"
      type: "find_sec_bugs_type"
      value: "WEAK_MESSAGE_DIGEST_MD5"
    - name: "Find Security Bugs-WEAK_MESSAGE_DIGEST_SHA1"
      type: "find_sec_bugs_type"
      value: "WEAK_MESSAGE_DIGEST_SHA1"
- id: "find_sec_bugs.SSL_CONTEXT-1"
  languages:
  - "java"
  patterns:
  - pattern-either:
    - pattern: "new org.apache.http.impl.client.DefaultHttpClient();"
    - pattern: "javax.net.ssl.SSLContext.getInstance(\"SSL\");"
  message: |
    The `org.apache.http.impl.client.DefaultHttpClient` and `javax.net.ssl.SSLContext.getInstance`
    object instances do not verify the hostnames upon connection.

    This allows for an adversary who is in between the application and the target host to intercept
    potentially sensitive information or transmit malicious data.

    Do not use the `org.apache.http.impl.client.DefaultHttpClient();` as it is deprecated. Instead
    use the new `java.net.http.HttpClient` that was introduced in Java 9.

    Example connecting to a host that will automatically do TLS validation:
    ```
    // Create a new java.net.http.HttpClient
    HttpClient httpClient = HttpClient.newHttpClient();
    // Create a HttpRequest builder
    HttpRequest request = HttpRequest.newBuilder()
            // Create a URI for a website which requires TLS
            .uri(URI.create("https://www.example.com/"))
            // Build the request
            .build();

    // Use the httpClient to send the request and use an HttpResponse.BodyHandlers String type
    HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());
    // Debug print
    System.out.println(response);
    ```
  metadata:
    shortDescription: "Improper certificate validation"
    category: "security"
    cwe: "CWE-295"
    primary_identifier: "find_sec_bugs.SSL_CONTEXT-1"
    secondary_identifiers:
    - name: "Find Security Bugs-SSL_CONTEXT"
      type: "find_sec_bugs_type"
      value: "SSL_CONTEXT"
  severity: "WARNING"
- id: "find_sec_bugs.SSL_CONTEXT-2"
  languages:
  - "java"
  patterns:
  - pattern-either:
    - pattern-inside: |
        import javax.net.ssl.*;
        ...
    - pattern-inside: |
        import javax.net.ssl.SSLContext;
        ...
  - pattern-either:
    - pattern-inside: |
        SSLContext.getInstance("$UNSAFE_VERSION");
    - pattern-inside: |
        SSLContext.getInstance(...);
        ...
        $ENGINE.setEnabledProtocols(new String[]{...,"$UNSAFE_VERSION",...});
  - pattern-not-inside: |
      $C = SSLContext.getInstance(...);
      ...
      $ENGINE.setEnabledProtocols(new String[]{...,"TLSv1.2",...});
  - pattern-not-inside: |
      $C = SSLContext.getInstance(...);
      ...
      $ENGINE.setEnabledProtocols(new String[]{...,"TLSv1.3",...});
  - pattern-not-inside: |
      $C = SSLContext.getInstance(...);
      ...
      $ENGINE.setEnabledProtocols(new String[]{...,"DTLSv1.2",...});
  - pattern-not-inside: |
      $C = SSLContext.getInstance(...);
      ...
      $ENGINE.setEnabledProtocols(new String[]{...,"DTLSv1.3",...});
  - metavariable-regex:
      metavariable: "$UNSAFE_VERSION"
      regex: "^(TLS|(D)?TLSv1.(0|1))$"
  message: |
    The application was found enabling insecure TLS protocol versions. When enabling protocol
    versions for an `SSLContext`, only the following versions should be allowed:
    - TLSv1.2
    - TLSv1.3
    - DTLSv1.2
    - DTLSv1.3

    To mitigate potential security risks, it is strongly advised to enforce TLS 1.2 as the minimum
    protocol version and disallow older versions such as TLS 1.0. Do note that newer versions of
    Java do not even support TLS 1.0 and will throw `NoSuchAlgorithmException`. Versions of TLS
    prior to 1.2 could expose the connection to downgrade attacks, where an adversary intercepts
    the
    connection and alters the requested protocol version to be a less secure one.

    In many scenarios, relying on the default system configuration does not meet compliance
    standards. This is due to the application being deployed across diverse systems with varying
    configurations and Java versions. While the default value may be secure on modern and
    up-to-date systems, it may not hold true for older systems. Consequently, it is highly
    recommended to explicitly define a secure configuration in all cases.

    Example configuring an SSLContext with TLSv1.2:
    ```
    // Create an SSLContext with TLSv1.2 explicitly
    SSLContext tlsContext = SSLContext.getInstance("TLSv1.2"); // or TLSv1.3, DTLSv1.2, DTLSv1.3

    // Alternatively, set the enabled protocols
    SSLContext serverSslContext = SSLContext.getInstance("TLS");
    SSLEngine serverEngine = serverSslContext.createSSLEngine();
    // Calling setEnabledProtocols will override the original context's configured protocol version
    serverEngine.setEnabledProtocols(new String[]{ "TLSv1.2" });
    ```

    For more information on `SSLContext` see:
    - https://docs.oracle.com/en/java/javase/11/docs/api/java.base/javax/net/ssl/SSLContext.html

    For more information on MiTM attacks see:
    - https://owasp.org/www-community/attacks/Manipulator-in-the-middle_attack
  metadata:
    shortDescription: "Inadequate encryption strength"
    category: "security"
    cwe: "CWE-326"
    primary_identifier: "find_sec_bugs.SSL_CONTEXT-2"
    secondary_identifiers:
    - name: "Find Security Bugs-SSL_CONTEXT"
      type: "find_sec_bugs_type"
      value: "SSL_CONTEXT"
  severity: "WARNING"
- id: "find_sec_bugs.SPRING_CSRF_PROTECTION_DISABLED-1"
  languages:
  - "java"
  pattern-either:
  - pattern: "(org.springframework.security.config.annotation.web.builders.HttpSecurity
      $H). ... .csrf().disable();"
  - pattern: "(org.springframework.security.config.annotation.web.configurers.CsrfConfigurer<HttpSecurity>
      $C).disable();"
  message: |
    The application fails to protect against Cross-Site Request Forgery (CSRF)
    due to disabling Spring's CSRF protection features.

    The vulnerability can be exploited by an adversary creating a link or form on a third
    party site and tricking an authenticated victim to access them.

    To remediate this issue, remove the call to `HttpSecurity.csrf().disable()` or remove
    the custom `CsrfConfigurer`.

    For more information on CSRF protection in Spring see:
    https://docs.spring.io/spring-security/reference/servlet/exploits/csrf.html#servlet-csrf

    Additionally, consider setting all session cookies to have the `SameSite=Strict` attribute.
    It should be noted that this may impact usability when sharing links across other mediums.
    It is recommended that a two cookie based approach is taken, as outlined in the
    [Top level
    navigations](https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis-08#section-8.8.2)
    section
    of the SameSite RFC.

    For more information on CSRF see OWASP's guide:
    https://owasp.org/www-community/attacks/csrf
  metadata:
    shortDescription: "Cross-Site Request Forgery (CSRF)"
    category: "security"
    cwe: "CWE-352"
    primary_identifier: "find_sec_bugs.SPRING_CSRF_PROTECTION_DISABLED-1"
    secondary_identifiers:
    - name: "Find Security Bugs-SPRING_CSRF_PROTECTION_DISABLED"
      type: "find_sec_bugs_type"
      value: "SPRING_CSRF_PROTECTION_DISABLED"
  severity: "WARNING"
- id: "find_sec_bugs.SERVLET_PARAMETER-1.SERVLET_CONTENT_TYPE-1.SERVLET_SERVER_NAME-1.SERVLET_SESSION_ID-1.SERVLET_QUERY_STRING-1.SERVLET_HEADER-1.SERVLET_HEADER_REFERER-1.SERVLET_HEADER_USER_AGENT-1"
  languages:
  - "java"
  message: |
    The Servlet can read GET and POST parameters from various methods. The
    value obtained should be considered unsafe."
  metadata:
    category: "security"
    cwe: "CWE-20"
    shortDescription: "Improper Input Validation"
    primary_identifier: "find_sec_bugs.SERVLET_PARAMETER-1.SERVLET_CONTENT_TYPE-1.SERVLET_SERVER_NAME-1.SERVLET_SESSION_ID-1.SERVLET_QUERY_STRING-1.SERVLET_HEADER-1.SERVLET_HEADER_REFERER-1.SERVLET_HEADER_USER_AGENT-1"
    secondary_identifiers:
    - name: "Find Security Bugs-SERVLET_PARAMETER"
      type: "find_sec_bugs_type"
      value: "SERVLET_PARAMETER"
    - name: "Find Security Bugs-SERVLET_CONTENT_TYPE"
      type: "find_sec_bugs_type"
      value: "SERVLET_CONTENT_TYPE"
    - name: "Find Security Bugs-SERVLET_SERVER_NAME"
      type: "find_sec_bugs_type"
      value: "SERVLET_SERVER_NAME"
    - name: "Find Security Bugs-SERVLET_SESSION_ID"
      type: "find_sec_bugs_type"
      value: "SERVLET_SESSION_ID"
    - name: "Find Security Bugs-SERVLET_QUERY_STRING"
      type: "find_sec_bugs_type"
      value: "SERVLET_QUERY_STRING"
    - name: "Find Security Bugs-SERVLET_HEADER"
      type: "find_sec_bugs_type"
      value: "SERVLET_HEADER"
    - name: "Find Security Bugs-SERVLET_HEADER_REFERER"
      type: "find_sec_bugs_type"
      value: "SERVLET_HEADER_REFERER"
    - name: "Find Security Bugs-SERVLET_HEADER_USER_AGENT"
      type: "find_sec_bugs_type"
      value: "SERVLET_HEADER_USER_AGENT"
  mode: "taint"
  pattern-sinks:
  - pattern-either:
    - pattern: "\"...\" + $PAR"
    - pattern: "$PAR + \"...\""
  pattern-sources:
  - pattern-either:
    - pattern: "(javax.servlet.http.HttpServletRequest $REQ).getContentType(...)"
    - pattern: "(javax.servlet.http.HttpServletRequest $REQ).getServerName(...)"
    - pattern: "(javax.servlet.http.HttpServletRequest $REQ).getRequestedSessionId(...)"
    - pattern: "(javax.servlet.http.HttpServletRequest $REQ).getParameterValues(...)"
    - pattern: "(javax.servlet.http.HttpServletRequest $REQ).getParameterMap(...)"
    - pattern: "(javax.servlet.http.HttpServletRequest $REQ).getParameterNames(...)"
    - pattern: "(javax.servlet.http.HttpServletRequest $REQ).getParameter(...)"
  severity: "WARNING"
- id: "find_sec_bugs.JAXRS_ENDPOINT-1"
  languages:
  - "java"
  message: |
    This method is part of a REST Web Service (JSR311). The security of this web service should be
    analyzed; Authentication, if enforced, should be tested. Access control, if enforced, should be
    tested. The inputs should be tracked for potential vulnerabilities. The communication should
    ideally be over SSL.
  metadata:
    category: "security"
    cwe: "CWE-20"
    shortDescription: "Improper Input Validation"
    technology:
    - "java"
    primary_identifier: "find_sec_bugs.JAXRS_ENDPOINT-1"
    secondary_identifiers:
    - name: "Find Security Bugs-JAXRS_ENDPOINT"
      type: "find_sec_bugs_type"
      value: "JAXRS_ENDPOINT"
  mode: "taint"
  pattern-sanitizers:
  - patterns:
    - pattern-inside: |
        $STR.replaceAll("$REPLACE_CHAR", "$REPLACER");
        ...
    - pattern: "$STR"
    - metavariable-regex:
        metavariable: "$REPLACER"
        regex: ".*^(CRLF).*"
    - metavariable-regex:
        metavariable: "$REPLACE_CHAR"
        regex: "(*CRLF)"
  - pattern: "org.apache.commons.text.StringEscapeUtils.unescapeJava(...);"
  pattern-sinks:
  - pattern: "return ...;"
  pattern-sources:
  - patterns:
    - pattern-inside: |
        @javax.ws.rs.Path("...")
        $TYPE $FUNC(..., $VAR, ...) {
          ...
        }
    - pattern: "$VAR"
  severity: "WARNING"
- id: "find_sec_bugs.JAXWS_ENDPOINT-1"
  languages:
  - "java"
  message: |
    This method is part of a SOAP Web Service (JSR224). The security of this web service should be
    analyzed; Authentication, if enforced, should be tested. Access control, if enforced, should be
    tested. The inputs should be tracked for potential vulnerabilities. The communication should
    ideally be over SSL.
  metadata:
    category: "security"
    cwe: "CWE-20"
    owasp: "A7:2017-Cross-Site Scripting (XSS)"
    shortDescription: "Improper Input Validation"
    technology:
    - "java"
    primary_identifier: "find_sec_bugs.JAXWS_ENDPOINT-1"
    secondary_identifiers:
    - name: "Find Security Bugs-JAXWS_ENDPOINT"
      type: "find_sec_bugs_type"
      value: "JAXWS_ENDPOINT"
  mode: "taint"
  pattern-sanitizers:
  - patterns:
    - pattern-inside: |
        $STR.replaceAll("$REPLACE_CHAR", "$REPLACER");
        ...
    - pattern: "$STR"
    - metavariable-regex:
        metavariable: "$REPLACER"
        regex: ".*^(CRLF).*"
    - metavariable-regex:
        metavariable: "$REPLACE_CHAR"
        regex: "(*CRLF)"
  - pattern: "org.apache.commons.text.StringEscapeUtils.unescapeJava(...);"
  pattern-sinks:
  - pattern: "return ...;"
  pattern-sources:
  - patterns:
    - pattern-inside: |
        @javax.jws.WebMethod(...)
        $TYPE $FUNC(..., $VAR, ...) {
          ...
        }
    - pattern: "$VAR"
  severity: "INFO"
- id: "find_sec_bugs.UNENCRYPTED_SOCKET-1.UNENCRYPTED_SERVER_SOCKET-1"
  languages:
  - "java"
  message: |
    Beyond using an SSL socket, you need to make sure your use of SSLSocketFactory
    does all the appropriate certificate validation checks to make sure you are not
    subject to man-in-the-middle attacks. Please read the OWASP Transport Layer
    Protection Cheat Sheet for details on how to do this correctly.
  metadata:
    cwe: "CWE-319"
    shortDescription: "Cleartext Transmission of Sensitive Information"
    primary_identifier: "find_sec_bugs.UNENCRYPTED_SOCKET-1.UNENCRYPTED_SERVER_SOCKET-1"
    secondary_identifiers:
    - name: "Find Security Bugs-UNENCRYPTED_SOCKET"
      type: "find_sec_bugs_type"
      value: "UNENCRYPTED_SOCKET"
    - name: "Find Security Bugs-UNENCRYPTED_SERVER_SOCKET"
      type: "find_sec_bugs_type"
      value: "UNENCRYPTED_SERVER_SOCKET"
  patterns:
  - pattern: "new java.net.Socket(...)"
  severity: "WARNING"
- id: "find_sec_bugs.UNVALIDATED_REDIRECT-1.URL_REWRITING-1"
  languages:
  - "java"
  message: |
    Unvalidated redirects occur when an application redirects a user to a
    destination URL specified by a user supplied parameter that is not validated.
    Such vulnerabilities can be used to facilitate phishing attacks.
  metadata:
    category: "security"
    cwe: "CWE-601"
    shortDescription: "URL Redirection to Untrusted Site ('Open Redirect')"
    primary_identifier: "find_sec_bugs.UNVALIDATED_REDIRECT-1.URL_REWRITING-1"
    secondary_identifiers:
    - name: "Find Security Bugs-UNVALIDATED_REDIRECT"
      type: "find_sec_bugs_type"
      value: "UNVALIDATED_REDIRECT"
    - name: "Find Security Bugs-URL_REWRITING"
      type: "find_sec_bugs_type"
      value: "URL_REWRITING"
  patterns:
  - pattern-either:
    - patterns:
      - pattern: "(HttpServletResponse $REQ).sendRedirect(...)"
      - pattern-not: "(HttpServletResponse $REQ).sendRedirect(\"...\")"
    - patterns:
      - pattern: "(HttpServletResponse $REQ).addHeader(...)"
      - pattern-not: "(HttpServletResponse $REQ).addHeader(\"...\", \"...\")"
    - patterns:
      - pattern: "(HttpServletResponse $REQ).encodeURL(...)"
      - pattern-not: "(HttpServletResponse $REQ).encodeURL(\"...\")"
    - patterns:
      - pattern: "(HttpServletResponse $REQ).encodeRedirectUrl(...)"
      - pattern-not: "(HttpServletResponse $REQ).encodeRedirectUrl(\"...\")"
  severity: "ERROR"
- id: "find_sec_bugs.WEAK_HOSTNAME_VERIFIER-1.WEAK_TRUST_MANAGER-1"
  languages:
  - "java"
  message: |
    Either the `HostnameVerifier` has been set to always return `true` or the `X509TrustManager`
    has
    been configured to return null, or both. This effectively disables the validation of server or
    client certificates.

    This allows for an adversary who is in between the application and the target host to intercept
    potentially sensitive information or transmit malicious data.

    It is recommended to not override the default `HostnameVerifiers`.

    Consider using the default `TrustManager` instead of implementing a custom one. If you must
    override
    the default verification process, implement proper TrustManager verification for
    `checkServerTrusted` and
    `checkClientTrusted` by throwing `CertificateException` if the certificate is invalid.

    Example using the built in `TrustManagerFactory` to manage validating certificate chains:
    ```
    // Use the default TrustManagerFactory
    TrustManagerFactory trustManagerFactory =
    TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
    // Use default system KeyStore, alternatively pass in your own keystore.
    trustManagerFactory.init((KeyStore) null);
    // Create SSLContext for TLS connections
    SSLContext tlsContext = SSLContext.getInstance("TLS");
    // Initialize the tlsContext with our trust manager and a SecureRandom number generator.
    tlsContext.init(null, trustManagerFactory.getTrustManagers(), new SecureRandom());
    ```

    For more information on TLS security see OWASP:
    https://cheatsheetseries.owasp.org/cheatsheets/Transport_Layer_Protection_Cheat_Sheet.html
  metadata:
    shortDescription: "Improper certificate validation"
    category: "security"
    cwe: "CWE-295"
    primary_identifier: "find_sec_bugs.WEAK_HOSTNAME_VERIFIER-1.WEAK_TRUST_MANAGER-1"
    secondary_identifiers:
    - name: "Find Security Bugs-WEAK_HOSTNAME_VERIFIER"
      type: "find_sec_bugs_type"
      value: "WEAK_HOSTNAME_VERIFIER"
    - name: "Find Security Bugs-WEAK_TRUST_MANAGER"
      type: "find_sec_bugs_type"
      value: "WEAK_TRUST_MANAGER"
  patterns:
  - pattern-either:
    - patterns:
      - pattern-inside: |
          class $V implements HostnameVerifier {
            ...
          }
      - pattern-inside: |
          public boolean verify(...) {
            ...
          }
      - pattern: "return true;"
    - patterns:
      - pattern-inside: |
          class $V implements X509TrustManager {
            ...
          }
      - pattern-either:
        - pattern: "public void checkClientTrusted(...) {}"
        - pattern: "public void checkServerTrusted(...) {}"
        - pattern: |
            public X509Certificate[] getAcceptedIssuers() {
              ...
              return null;
            }
  severity: "WARNING"
- id: "find_sec_bugs.FILE_UPLOAD_FILENAME-1"
  languages:
  - "java"
  message: |
    The filename provided by the FileUpload API can be tampered with by the client to reference
    unauthorized files. The provided filename should be properly validated to ensure it's properly
    structured, contains no unauthorized path characters (e.g., / \), and refers to an authorized
    file.
  metadata:
    category: "security"
    cwe: "CWE-22"
    shortDescription: "Improper Limitation of a Pathname to a Restricted Directory
      ('Path Traversal')"
    technology:
    - "java"
    primary_identifier: "find_sec_bugs.FILE_UPLOAD_FILENAME-1"
    secondary_identifiers:
    - name: "Find Security Bugs-FILE_UPLOAD_FILENAME"
      type: "find_sec_bugs_type"
      value: "FILE_UPLOAD_FILENAME"
  patterns:
  - pattern-inside: |
      $FUNC(..., HttpServletRequest $REQ, ... ) {
        ...
        $FILES = (ServletFileUpload $SFU).parseRequest($REQ);
        ...
      }
  - pattern-inside: |
      for(FileItem $ITEM : $FILES) {
        ...
      }
  - pattern: "$ITEM.getName()"
  severity: "ERROR"
- id: "find_sec_bugs.WEAK_FILENAMEUTILS-1"
  languages:
  - "java"
  message: |
    A file is opened to read its content. The filename comes from an input
    parameter. If an unfiltered parameter is passed to this file API, files from an
    arbitrary filesystem location could be read.
  metadata:
    category: "security"
    cwe: "CWE-22"
    shortDescription: "Improper Limitation of a Pathname to a Restricted Directory
      ('Path Traversal')"
    technology:
    - "java"
    primary_identifier: "find_sec_bugs.WEAK_FILENAMEUTILS-1"
    secondary_identifiers:
    - name: "Find Security Bugs-WEAK_FILENAMEUTILS"
      type: "find_sec_bugs_type"
      value: "WEAK_FILENAMEUTILS"
  patterns:
  - pattern-inside: |
      import static org.apache.commons.io.FilenameUtils;
      ...
  - pattern-either:
    - pattern: "normalize(...)"
    - pattern: "getExtension(...)"
    - pattern: "isExtensions(...)"
    - pattern: "getName(...)"
    - pattern: "getBaseName(...)"
    - pattern: "org.apache.commons.io.FilenameUtils.normalize(...)"
    - pattern: "org.apache.commons.io.FilenameUtils.getExtension(...)"
    - pattern: "org.apache.commons.io.FilenameUtils.isExtensions(...)"
    - pattern: "org.apache.commons.io.FilenameUtils.getName(...)"
    - pattern: "org.apache.commons.io.FilenameUtils.getBaseName(...)"
  severity: "ERROR"
- id: "find_sec_bugs.STRUTS_FORM_VALIDATION-1"
  languages:
  - "java"
  message: |
    Form inputs should have minimal input validation. Preventive validation helps
    provide defense in depth against a variety of risks.
  metadata:
    category: "security"
    cwe: "CWE-20"
    shortDescription: "Improper Input Validation"
    primary_identifier: "find_sec_bugs.STRUTS_FORM_VALIDATION-1"
    secondary_identifiers:
    - name: "Find Security Bugs-STRUTS_FORM_VALIDATION"
      type: "find_sec_bugs_type"
      value: "STRUTS_FORM_VALIDATION"
  patterns:
  - pattern-inside: |
      class $CLASS extends $SC {
        ...
      }
  - metavariable-regex:
      metavariable: "$SC"
      regex: "(ActionForm|ValidatorForm)"
  - pattern-not: "public void validate() { ... }"
  severity: "WARNING"
- id: "find_sec_bugs.AWS_QUERY_INJECTION-1"
  languages:
  - "java"
  message: |
    Constructing SimpleDB queries containing user input can allow an attacker to view unauthorized
    records.
  metadata:
    category: "security"
    cwe: "CWE-943"
    shortDescription: "Improper Neutralization of Special Elements in Data Query Logic"
    technology:
    - "java"
    primary_identifier: "find_sec_bugs.AWS_QUERY_INJECTION-1"
    secondary_identifiers:
    - name: "Find Security Bugs-AWS_QUERY_INJECTION"
      type: "find_sec_bugs_type"
      value: "AWS_QUERY_INJECTION"
  mode: "taint"
  pattern-sinks:
  - patterns:
    - pattern-either:
      - pattern-inside: |
          $REQ = new SelectRequest($QUERY, ...);
          ...
          $DB.select($REQ);
      - pattern-inside: |
          $DB.select(new SelectRequest($QUERY,...));
      - pattern-inside: |
          $DB.select((SelectRequest $SR).withSelectExpression($QUERY,...));
    - pattern: "$QUERY"
    - metavariable-pattern:
        metavariable: "$DB"
        pattern-either:
        - pattern: "(AmazonSimpleDB $DB)"
        - pattern: "(AmazonSimpleDBClient $DB)"
  pattern-sources:
  - patterns:
    - pattern-inside: |
        $FUNC(..., $VAR, ...) {
          ...
        }
    - pattern: "$VAR"
  - patterns:
    - pattern-inside: |
        $FUNC(...) {
          ...
          $VAR = ... + $X;
          ...
        }
    - pattern: "$VAR"
  severity: "ERROR"
- id: "find_sec_bugs.BEAN_PROPERTY_INJECTION-1"
  languages:
  - "java"
  message: |
    An attacker can set arbitrary bean properties that can compromise system integrity. An
    attacker can leverage this functionality to access special bean properties like
    class.classLoader that will allow them to override system properties and potentially execute
    arbitrary code.
  metadata:
    category: "security"
    cwe: "CWE-15"
    shortDescription: "External Control of System or Configuration Setting"
    technology:
    - "java"
    primary_identifier: "find_sec_bugs.BEAN_PROPERTY_INJECTION-1"
    secondary_identifiers:
    - name: "Find Security Bugs-BEAN_PROPERTY_INJECTION"
      type: "find_sec_bugs_type"
      value: "BEAN_PROPERTY_INJECTION"
  patterns:
  - pattern-inside: |-
      $TYPE $FUNC(..., HttpServletRequest $REQ, ...) { ... }
  - pattern-either:
    - pattern: |
        $MAP.put(..., $REQ.getParameter(...));
        ...
        $BEAN_UTIL.populate(..., $MAP);
    - pattern: |
        while (...) {
            ...
            $MAP.put(..., $REQ.getParameterValues(...));
        }
        ...
        $BEAN_UTIL.populate(..., $MAP);
  - metavariable-pattern:
      metavariable: "$BEAN_UTIL"
      pattern-either:
      - pattern: "(BeanUtilsBean $B)"
      - pattern: "new BeanUtilsBean()"
      - pattern: "org.apache.commons.beanutils.BeanUtils"
  severity: "ERROR"
- id: "find_sec_bugs.CRLF_INJECTION_LOGS-1"
  languages:
  - "java"
  patterns:
  - pattern-either:
    - pattern: |
        $TAINTED = (HttpServletRequest $REQ).getParameter(...);
        ...
        $LOGGER.$METHOD(...,$TAINTED,...);
    - pattern: |
        $TAINTED = (HttpServletRequest $REQ).getParameter(...);
        ...
        $VAR = String.Format(..., $TAINTED,...);
        ...
        $LOGGER.$METHOD(...,$VAR,...);
    - pattern: |
        $TAINTED = (HttpServletRequest $REQ).getParameter(...);
        ...
        $LOGGER.$METHOD(...,String.Format(..., $TAINTED,...),...);
    - pattern: |
        $TAINTED = (HttpServletRequest $REQ).getParameter(...);
        ...
        $VAR = ... + $TAINTED + ...;
        ...
        $LOGGER.$METHOD(...,$VAR,...);
    - pattern: |
        $TAINTED = (HttpServletRequest $REQ).getParameter(...);
        ...
        $LOGGER.$METHOD(...,... + $TAINTED + ...,...);
  - metavariable-regex:
      metavariable: "$METHOD"
      regex: "(log|logp|logrb|entering|exiting|fine|finer|finest|info|debug|trace|warn|warning|config|error|severe)"
  - metavariable-pattern:
      metavariable: "$LOGGER"
      pattern-either:
      - pattern: "(Logger $LOG)"
      - pattern: "org.pmw.tinylog.Logger"
      - pattern: "org.apache.log4j.Logger"
      - pattern: "org.apache.logging.log4j.Logger"
      - pattern: "org.slf4j.Logger"
      - pattern: "org.apache.commons.logging.Log"
      - pattern: "java.util.logging.Logger"
  message: |
    The application was found to take data from user input and output it into a logger method.
    When data from
    an untrusted source is sent to a logger without validation, an attacker could forge log
    entries
    or include malicious content. If the log file is processed automatically, the attacker can
    render the file unusable by corrupting the format of the file or injecting unexpected
    characters. An attacker may also inject code or other commands into the log file and take
    advantage of a vulnerability in the log processing utility (e.g. command injection or XSS).

    To mitigate this issue, encode values that come from user input with a package such as
    [Apache Commons Text](https://commons.apache.org/proper/commons-text/) to escape the input:
    ```
    public String escapeValue(String value) {
      return StringEscapeUtils.escapeJava(value);
    }
    ```

    For more information on log injection see OWASP:
    https://owasp.org/www-community/attacks/Log_Injection
  severity: "ERROR"
  metadata:
    shortDescription: "Improper neutralization of CRLF sequences ('CRLF Injection')"
    category: "security"
    cwe: "CWE-93"
    technology:
    - "java"
    primary_identifier: "find_sec_bugs.CRLF_INJECTION_LOGS-1"
    secondary_identifiers:
    - name: "Find Security Bugs-CRLF_INJECTION_LOGS"
      type: "find_sec_bugs_type"
      value: "CRLF_INJECTION_LOGS"
- id: "find_sec_bugs.COMMAND_INJECTION-1"
  languages:
  - "java"
  pattern-either:
  - patterns:
    - pattern-inside: |
        $FUNC(...,String $PARAM, ...) {
          ...
        }
    - pattern-either:
      - pattern: "(Runtime $R).exec(<...$PARAM...>,...);"
      - patterns:
        - pattern-either:
          - pattern: |
              $CMDARR = new String[]{"$SHELL",...,<...$PARAM...>,...};
              ...
              (Runtime $R).exec($CMDARR,...);
          - pattern: |
              String[] $CMDARR = {"$SHELL",...,<...$PARAM...>,...};
              ...
              (Runtime $R).exec($CMDARR,...);
          - pattern: "(Runtime $R).exec(new String[]{\"$SHELL\",...,<...$PARAM...>,...},
              ...);"
          - pattern: "(Runtime $R).exec(java.util.String.format(\"...\", ...,<...$PARAM...>,...));"
          - pattern: "(Runtime $R).exec((String $A) + (String $B));"
        - metavariable-regex:
            metavariable: "$SHELL"
            regex: "(/.../)?(sh|bash|ksh|csh|tcsh|zsh)$"
    - pattern-not: "(Runtime $R).exec(\"...\",\"...\",\"...\",...);"
    - pattern-not: |
        (Runtime $R).exec(new String[]{"...","...","...",...},...);
  - patterns:
    - pattern-inside: |
        $FUNC(...,String $PARAM, ...) {
          ...
        }
    - pattern-either:
      - pattern: "(ProcessBuilder $PB).command(<...$PARAM...>,...);"
      - patterns:
        - pattern-inside: |-
            $VAL = <...$PARAM...>; ...
        - pattern: "(ProcessBuilder $PB).command(<...$VAL...>,...);"
      - patterns:
        - pattern-either:
          - pattern: "(ProcessBuilder $PB).command(\"$SHELL\",...,<...$PARAM...>,...);"
          - pattern: |
              $CMDARR = java.util.Arrays.asList("$SHELL",...,<...$PARAM...>,...);
              ...
              (ProcessBuilder $PB).command($CMDARR,...);
          - pattern: "(ProcessBuilder $PB).command(java.util.Arrays.asList(\"$SHELL\",...,<...$PARAM...>,...),...);"
          - pattern: "(ProcessBuilder $PB).command(java.util.String.format(\"...\",
              ...,<...$PARAM...>,...));"
          - pattern: "(ProcessBuilder $PB).command((String $A) + (String $B));"
        - metavariable-regex:
            metavariable: "$SHELL"
            regex: "(/.../)?(sh|bash|ksh|csh|tcsh|zsh)$"
    - pattern-not: "(ProcessBuilder $PB).command(\"...\",\"...\",\"...\",...);"
    - pattern-not: |
        (ProcessBuilder $PB).command(java.util.Arrays.asList("...","...","...",...));
  message: |
    OS command injection is a critical vulnerability that can lead to a full system
    compromise as it may allow an adversary to pass in arbitrary commands or arguments
    to be executed.

    User input should never be used in constructing commands or command arguments
    to functions which execute OS commands. This includes filenames supplied by
    user uploads or downloads.

    Ensure your application does not:

    - Use user-supplied information in the process name to execute.
    - Use user-supplied information in an OS command execution function which does
    not escape shell meta-characters.
    - Use user-supplied information in arguments to OS commands.

    The application should have a hardcoded set of arguments that are to be passed
    to OS commands. If filenames are being passed to these functions, it is
    recommended that a hash of the filename be used instead, or some other unique
    identifier. It is strongly recommended that a native library that implements
    the same functionality be used instead of using OS system commands, due to the
    risk of unknown attacks against third party commands.

    When specifying the OS command, ensure the application uses the full path
    information, otherwise the OS may attempt to look up which process to execute
    and could be vulnerable to untrusted search path vulnerabilities (CWE-426).

    Example of safely executing an OS command:
    ```
    public static void executeCommand(String userFileData) throws java.io.IOException {
        // Generate a random filename, do not use user input
        String fileName = UUID.randomUUID().toString();
        // Create a Buffered/FileWriter
        BufferedWriter writer = new BufferedWriter(new FileWriter(fileName));
        // Write the user content to our random file
        writer.write(userFileData);
        // Close the file to flush contents
        writer.close();
        // Create the process builder with a hardcoded path to the binary, and our randomly
    generated filename
        ProcessBuilder processBuilder = new ProcessBuilder("/opt/app/path", fileName);
        // Start the process
        Process process = processBuilder.start();
        // Handle/redirect output of process here
        // ...
    }
    ```

    For more information on OS command injection, see OWASP's guide:
    https://cheatsheetseries.owasp.org/cheatsheets/OS_Command_Injection_Defense_Cheat_Sheet.html
  severity: "WARNING"
  metadata:
    shortDescription: "Improper neutralization of special elements used in an OS command
      ('OS Command Injection')"
    category: "security"
    cwe: "CWE-78"
    technology:
    - "java"
    primary_identifier: "find_sec_bugs.COMMAND_INJECTION-1"
    secondary_identifiers:
    - name: "Find Security Bugs-COMMAND_INJECTION"
      type: "find_sec_bugs_type"
      value: "COMMAND_INJECTION"
- id: "find_sec_bugs.CUSTOM_INJECTION-1"
  languages:
  - "java"
  patterns:
  - pattern-either:
    - pattern: |
        $QUERY = ... + $VAR + ...;
        ...
        $ST.executeQuery($QUERY);
    - pattern: |
        $QUERY = ... + $VAR ;
        ...
        $ST.executeQuery($QUERY);
    - pattern: |
        $QUERY = String.format("...",...,$VAR,...);
        ...
        $ST.executeQuery($QUERY);
    - pattern: "$ST.executeQuery((StringBuilder $SB).toString());"
    - pattern: "$ST.executeQuery(... + $VAR + ...);"
    - pattern: "$ST.executeQuery(... + $VAR);"
    - pattern: "$ST.executeQuery(...,String.format(\"...\",...,$VAR,...), ...);"
  - metavariable-pattern:
      metavariable: "$ST"
      pattern-either:
      - pattern: "(java.sql.Statement $ST)"
      - pattern: "(org.apache.turbine.om.peer.BasePeer $ST)"
  message: |
    SQL Injection is a critical vulnerability that can lead to data or system compromise. By
    dynamically generating SQL query strings, user input may be able to influence the logic of
    the SQL statement. This could lead to an adversary accessing information they should
    not have access to, or in some circumstances, being able to execute OS functionality or code.

    Replace all dynamically generated SQL queries with parameterized queries. In situations where
    dynamic queries must be created, never use direct user input, but instead use a map or
    dictionary of valid values and resolve them using a user-supplied key.

    For example, some database drivers do not allow parameterized queries for `>` or `<` comparison
    operators. In these cases, do not use a user supplied `>` or `<` value, but rather have the
    user
    supply a `gt` or `lt` value. The alphabetical values are then used to look up the `>` and `<`
    values to be used in the construction of the dynamic query. The same goes for other queries
    where
    column or table names are required but cannot be parameterized.

    Example using `PreparedStatement` queries:
    ```
    // Some userInput
    String userInput = "someUserInput";
    // Your connection string
    String url = "...";
    // Get a connection from the DB via the DriverManager
    Connection conn = DriverManager.getConnection(url);
    // Create a prepared statement
    PreparedStatement st = conn.prepareStatement("SELECT name FROM table where name=?");
    // Set each parameters value by the index (starting from 1)
    st.setString(1, userInput);
    // Execute query and get the result set
    ResultSet rs = st.executeQuery();
    // Iterate over results
    while (rs.next()) {
        // Get result for this row at the provided column number (starting from 1)
        String result = rs.getString(1);
        // ...
    }
    // Close the ResultSet
    rs.close();
    // Close the PreparedStatement
    st.close();
    ```

    For more information on SQL Injection see OWASP:
    https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html
  severity: "WARNING"
  metadata:
    shortDescription: "Improper neutralization of special elements used in an SQL
      command ('SQL Injection')"
    category: "security"
    cwe: "CWE-89"
    technology:
    - "java"
    primary_identifier: "find_sec_bugs.CUSTOM_INJECTION-1"
    secondary_identifiers:
    - name: "Find Security Bugs-CUSTOM_INJECTION"
      type: "find_sec_bugs_type"
      value: "CUSTOM_INJECTION"
- id: "find_sec_bugs.CUSTOM_INJECTION-2"
  languages:
  - "java"
  message: |
    The method identified is susceptible to injection. The input should be validated and properly
    escaped.
  metadata:
    category: "security"
    cwe: "CWE-89"
    shortDescription: "Improper Neutralization of Special Elements used in an SQL
      Command ('SQL Injection')"
    technology:
    - "java"
    primary_identifier: "find_sec_bugs.CUSTOM_INJECTION-2"
    secondary_identifiers:
    - name: "Find Security Bugs-CUSTOM_INJECTION"
      type: "find_sec_bugs_type"
      value: "CUSTOM_INJECTION"
  patterns:
  - pattern-not-inside: |
      final String $VAR = ...;
  - pattern-either:
    - pattern: |
        "$SQL_STR" + ...
    - pattern: "String.format(\"$SQL_STR\", ...)"
    - pattern: |
        "$SQL_STR".concat(...)
    - pattern: "(StringBuilder $BUILDER). ... .append(\"$SQL_STR\")"
    - patterns:
      - pattern-inside: |
          StringBuilder $BUILDER = new StringBuilder("$SQL_STR");
          ...
      - pattern: "$BUILDER.append(...)"
    - patterns:
      - pattern-inside: |
          $QUERY = "$SQL_STR";
          ...
      - pattern: "$QUERY += ..."
  - metavariable-regex:
      metavariable: "$SQL_STR"
      regex: "(?i)(select|insert|create|update|alter|delete|drop)\\b"
  severity: "WARNING"
- id: "find_sec_bugs.EL_INJECTION-1"
  languages:
  - "java"
  message: |
    An expression is built with a dynamic value. The source of the value(s) should be verified to
    avoid that unfiltered values fall into this risky code evaluation.
  metadata:
    category: "security"
    cwe: "CWE-94"
    shortDescription: "Improper Control of Generation of Code ('Code Injection')"
    technology:
    - "java"
    primary_identifier: "find_sec_bugs.EL_INJECTION-1"
    secondary_identifiers:
    - name: "Find Security Bugs-EL_INJECTION"
      type: "find_sec_bugs_type"
      value: "EL_INJECTION"
  patterns:
  - pattern-inside: |
      $FUNC(..., String $EXPR, ...) {
        ...
        ELContext $CTX = ...;
        ...
      }
  - pattern-either:
    - pattern: "(ExpressionFactory $EXP).createValueExpression((ELContext $CTX), $EXPR,
        ...)"
    - pattern: "(ExpressionFactory $EXP).createMethodExpression((ELContext $CTX),
        $EXPR, ...)"
  severity: "WARNING"
- id: "find_sec_bugs.REQUESTDISPATCHER_FILE_DISCLOSURE-1.STRUTS_FILE_DISCLOSURE-1.SPRING_FILE_DISCLOSURE-1"
  languages:
  - "java"
  mode: "taint"
  pattern-sinks:
  - patterns:
    - pattern: "new org.springframework.web.servlet.ModelAndView($FST);"
    - pattern: "$FST"
  - patterns:
    - pattern: "new org.springframework.web.servlet.ModelAndView($FST, $SND);"
    - pattern: "$FST"
  - patterns:
    - pattern: "new org.springframework.web.servlet.ModelAndView($FST, $SND, $TRD);"
    - pattern: "$FST"
  - patterns:
    - pattern: "new org.apache.struts.action.ActionForward($FST)"
    - pattern: "$FST"
  - patterns:
    - pattern: "new org.apache.struts.action.ActionForward($FST, $SND)"
    - pattern: "$FST"
  - patterns:
    - pattern: "new org.apache.struts.action.ActionForward($FST, $SND, $TRD)"
    - pattern: "$SND"
  - patterns:
    - pattern: "new org.apache.struts.action.ActionForward($FST, $SND, $TRD)"
    - pattern: "$TRD"
  - patterns:
    - pattern-inside: |
        $ACTION = new org.apache.struts.action.ActionForward();
        ...
    - pattern: "$ACTION.setPath(...)"
  - patterns:
    - pattern-inside: |
        $MVC = new org.springframework.web.servlet.ModelAndView();
        ...
    - pattern: "$MVC.setViewName(...);"
  - patterns:
    - pattern-inside: |
        $REQ = $HTTP.getRequestDispatcher(...);
        ...
    - pattern-either:
      - pattern: "$REQ.include($FST, $SND)"
      - pattern: "$REQ.forward($FST, $SND)"
  pattern-sources:
  - pattern: "(javax.servlet.http.HttpServletRequest $VAR).getParameter(...)"
  message: |
    The `org.springframework.web.servlet.ModelAndView` class and
    `HttpRequest.getRequestDispatcher()`'s `include` and `forward` methods may
    potentially allow access to restricted files if called with user-supplied input.

    For Spring MVC, the ModelAndView class looks up a view by name to resolve a `.jsp`
    file. If this view name comes from user-supplied input, it could be abused to attempt
    to return a JSP view that the user should not have access to.

    The `HttpRequest.getRequestDispatcher()`'s `include` and `forward` methods will return
    any file that is resolvable within the web application context. This includes the `web.xml`
    file, any compiled classes, `jsp` files, and additional JAR or WAR libraries that are
    accessible.

    Never pass user-supplied input directly to any of these methods. Use a lookup table or
    hardcode
    which views or paths the user should be directed to. Another option is to use a simple HTTP
    redirect by returning an empty response body with a 301 status code and a `Location` redirect
    header. In Java servlets, this can be done by using the `response.sendRedirect(...)` method.

    Example using a lookup table to resolve a view from a Spring MVC application:
    ```
    @RequestMapping(value="/mvc", method=RequestMethod.GET)
    public ModelAndView mvc(HttpServletRequest request, HttpServletResponse response, Model model)
     {
      // Create a look up table or pull from a data source
      HashMap<String, String> lookupTable = new HashMap<>();
      lookupTable.put("key1", "view1");
      lookupTable.put("key2", "view2");
      // Get user input
      String userInput = request.getParameter("key");
      // Look up view from the user input
      String viewValue = lookupTable.getOrDefault(userInput, userInput);
      // return the new model and view
      return new ModelAndView(viewValue);
    }
    ```

    Example using a redirect instead of a `RequestDispatcher`:
    ```
    // Create a look up table or pull from a data source
    HashMap<String, String> lookupTable = new HashMap<>();
    lookupTable.put("key1", "/Resource1");
    lookupTable.put("key2", "/Resource2");
    // Get user input
    String userInput = request.getParameter("key");
    // Look up resource to redirect to from the user input
    String redirectValue = lookupTable.getOrDefault(userInput, "/Resource1");
    // Redirect the user
    response.sendRedirect(redirectValue);
    ```
  metadata:
    shortDescription: "Files or directories accessible to external parties"
    category: "security"
    cwe: "CWE-552"
    primary_identifier: "find_sec_bugs.REQUESTDISPATCHER_FILE_DISCLOSURE-1.STRUTS_FILE_DISCLOSURE-1.SPRING_FILE_DISCLOSURE-1"
    secondary_identifiers:
    - name: "Find Security Bugs-REQUESTDISPATCHER_FILE_DISCLOSURE"
      type: "find_sec_bugs_type"
      value: "REQUESTDISPATCHER_FILE_DISCLOSURE"
    - name: "Find Security Bugs-STRUTS_FILE_DISCLOSURE"
      type: "find_sec_bugs_type"
      value: "STRUTS_FILE_DISCLOSURE"
    - name: "Find Security Bugs-SPRING_FILE_DISCLOSURE"
      type: "find_sec_bugs_type"
      value: "SPRING_FILE_DISCLOSURE"
  severity: "ERROR"
- id: "find_sec_bugs.HTTP_PARAMETER_POLLUTION-1"
  languages:
  - "java"
  mode: "taint"
  pattern-sources:
  - pattern: "(HttpServletRequest $REQ).getParameter(...)"
  pattern-sanitizers:
  - pattern: "java.net.URLEncoder.encode(...)"
  - pattern: "com.google.common.net.UrlEscapers.urlPathSegmentEscaper().escape(...)"
  pattern-sinks:
  - pattern: "new org.apache.http.client.methods.HttpGet(...)"
  - pattern: "new org.apache.commons.httpclient.methods.GetMethod(...)"
  - pattern: "(org.apache.commons.httpclient.methods.GetMethod $GM).setQueryString(...)"
  message: |
    The application was found including unvalidated user input into a URL, which could lead to
    HTTP Parameter Pollution (HPP) or worse, Server Side Request Forgery (SSRF). This could
    allow an adversary to override the value of a URL or a request parameter.  HTTP Parameter
    Pollution
    (HPP) attacks consist of injecting encoded query string delimiters into other existing
    parameters. If a web
    application does not properly sanitize the user input, an adversary may modify the logic of
    these
    requests to other applications.

    To remediate this issue, never allow user input directly into creation of a URL or URL
    parameter. Consider
    using a map to look up user-supplied information and return exact values to be used in the
    generation of
    requests.

    Example using a map to look up a key to be used in a HTTP request:
    ```
    HashMap<String, String> lookupTable = new HashMap<>();
    lookupTable.put("key1", "value1");
    lookupTable.put("key2", "value2");
    String userInput = request.getParameter("key");

    // Create a CloseableHttpClient, ideally any requests issued should be done
    // out-of-band from the servlet request itself (such as using a separate thread/scheduler
    system)
    try (final CloseableHttpClient httpClient = HttpClients.createDefault()) {
        // Lookup the value from our user input from our lookupTable
        String value = lookupTable.getOrDefault(userInput, "value1");
        // Construct the url, with the hardcoded url and only pass in the value from the
    lookupTable,
        // not direct user input
        final HttpGet httpget = new HttpGet("https://example.com/getId?key="+value);
        // Execute the request
        CloseableHttpResponse clientResponse = httpClient.execute(httpget);
        // Read the response
        byte[] responseData = clientResponse.getEntity().getContent().readAllBytes();
        // Handle the response
        // ...
    }
    ```

    If using a map is not possible, the user-supplied input must be encoded prior to use, and
    never allow full
    URLs:
    ```
    // Get user input
    String userInput = request.getParameter("key");
    // Encode the string using java.net.URLEncoder with the UTF-8 character set
    String encodedString = java.net.URLEncoder.encode(userInput, StandardCharsets.UTF_8);
    // Create a CloseableHttpClient, ideally any requests issued should be done
    // out-of-band from the servlet request itself (such as using a separate thread/scheduler
    system)
    try (final CloseableHttpClient httpClient = HttpClients.createDefault()) {
      // Construct the url, with the hardcoded url and only pass in the encoded value, never a
    full URL
      final HttpGet httpget = new HttpGet("https://example.com/getId?key="+encodedString);
      // Execute the request
      CloseableHttpResponse clientResponse = httpClient.execute(httpget);
      // Read the response
      byte[] responseData = clientResponse.getEntity().getContent().readAllBytes();
      // handle the response
    }
    ```

    For more information on SSRF see OWASP:
    https://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html

    For more information on HTTP Parameter Pollution see:
    https://en.wikipedia.org/wiki/HTTP_parameter_pollution
  severity: "ERROR"
  metadata:
    shortDescription: "Improper neutralization of argument delimiters in a command
      ('Argument Injection')"
    category: "security"
    cwe: "CWE-88"
    technology:
    - "java"
    primary_identifier: "find_sec_bugs.HTTP_PARAMETER_POLLUTION-1"
    secondary_identifiers:
    - name: "Find Security Bugs-HTTP_PARAMETER_POLLUTION"
      type: "find_sec_bugs_type"
      value: "HTTP_PARAMETER_POLLUTION"
- id: "find_sec_bugs.LDAP_INJECTION-1"
  languages:
  - "java"
  mode: "taint"
  pattern-sinks:
  - pattern: "javax.naming.ldap.LdapName(...)"
  - pattern: "(javax.naming.directory.Context $C).lookup(...)"
  - pattern: "(javax.naming.Context $C).lookup(...)"
  - patterns:
    - pattern-inside: |-
        (java.util.Properties $P).put($KEY, $VAL)
    - pattern-not-inside: |
        $FUNC(..., $VAL, ...) {
          ...
        }
    - pattern: "$VAL"
  - patterns:
    - pattern-inside: |-
        (com.unboundid.ldap.sdk.LDAPConnection $C).search($QUERY, ...)
    - pattern: "$QUERY"
  - patterns:
    - pattern-either:
      - pattern: "$CTX.lookup(...)"
      - patterns:
        - pattern-inside: |-
            $CTX.search($QUERY, ...)
        - pattern: "$QUERY"
      - patterns:
        - pattern-inside: |-
            $CTX.search($NAME, $FILTER, ...)
        - pattern: "$FILTER"
    - metavariable-pattern:
        metavariable: "$CTX"
        pattern-either:
        - pattern: "(javax.naming.directory.DirContext $C)"
        - pattern: "(javax.naming.directory.InitialDirContext $IDC)"
        - pattern: "(javax.naming.ldap.LdapContext $LC)"
        - pattern: "(javax.naming.event.EventDirContext $EDC)"
        - pattern: "(com.sun.jndi.ldap.LdapCtx $LC)"
  - patterns:
    - pattern-either:
      - patterns:
        - pattern-inside: |-
            $CTX.list($QUERY, ...)
        - pattern: "$QUERY"
      - patterns:
        - pattern-inside: |-
            $CTX.lookup($QUERY, ...)
        - pattern: "$QUERY"
      - patterns:
        - pattern-inside: |-
            $CTX.search($QUERY, ...)
        - pattern: "$QUERY"
      - patterns:
        - pattern-inside: |-
            $CTX.search($NAME, $FILTER, ...)
        - pattern: "$FILTER"
    - metavariable-pattern:
        metavariable: "$CTX"
        pattern-either:
        - pattern: "(org.springframework.ldap.core.LdapTemplate $LT)"
        - pattern: "(org.springframework.ldap.core.LdapOperations $LO)"
  pattern-sources:
  - patterns:
    - pattern-inside: |
        $FUNC(..., $VAR, ...) {
          ...
        }
    - pattern: "$VAR"
  - patterns:
    - pattern-inside: |
        $FUNC(..., $X, ...) {
          ...
          $VAR = ... + $X;
          ...
        }
    - pattern: "$VAR"
  message: |
    LDAP injection attacks exploit LDAP queries to influence how data is returned by
    the LDAP server.

    Later versions of Java's `InitialDirContext.search` introduced a four argument method, one of
    which is the `filterArg` parameter. The `filterArg` will be automatically encoded when
    querying
    the LDAP server. If this method signature is not available, the application must encode the
    LDAP strings manually.

    More details on the four argument `search` method can be found here:
    https://docs.oracle.com/en/java/javase/20/docs/api/java.naming/javax/naming/directory/InitialDirContext.html#search(javax.naming.Name,java.lang.String,java.lang.Object[],javax.naming.directory.SearchControls)

    To encode the string manually, it is recommended that all input passed to LDAP querying
    systems
    encode the following values:

    - Any occurrence of the null character must be escaped as “\00”.
    - Any occurrence of the open parenthesis character must be escaped as “\28”.
    - Any occurrence of the close parenthesis character must be escaped as “\29”.
    - Any occurrence of the asterisk character must be escaped as “\2a”.
    - Any occurrence of the backslash character must be escaped as “\5c”.

    Example function that safely encodes user-supplied input to be used in an LDAP query.
    ```
    public static String encodeLDAPString(String input) {
      // Note the \ character is replaced first
      CharSequence[] chars = new CharSequence[] { "\\", "\0", "(", ")", "*" };
      CharSequence[] encoded = new CharSequence[] { "\\5c", "\\00", "\\28", "\\29", "\\2a" };
      // Iterate over each character sequence, replacing the raw value with an encoded version of
    it
      for (int i = 0; i < chars.length; i++)
      {
          // re-assign to input
          input = input.replace(chars[i], encoded[i]);
      }
      // return our modified input string
      return input;
    }
    ```

    Example code that using the `filterArgs` parameter which automatically encodes for us:
    ```
    // Create a properties to hold the ldap connection details
    Properties props = new Properties();
    // Use the com.sun.jndi.ldap.LdapCtxFactory factory provider
    props.put(Context.INITIAL_CONTEXT_FACTORY, "com.sun.jndi.ldap.LdapCtxFactory");
    // The LDAP server URL
    props.put(Context.PROVIDER_URL, "ldap://ldap.example.org:3889");
    // User details for the connection
    props.put(Context.SECURITY_PRINCIPAL, "cn=admin,dc=example,dc=org");
    // LDAP account password
    String ldapAccountPassword = getAccountPasswordFromSecureStoreOrKMS();
    // Pass in the LDAP password
    props.put(Context.SECURITY_CREDENTIALS, ldapAccountPassword);

    // Create the LDAPContext
    InitialDirContext ldapContext = new InitialDirContext(props);
    // Example using SUBTREE_SCOPE SearchControls
    SearchControls searchControls = new SearchControls();
    searchControls.setSearchScope(SearchControls.SUBTREE_SCOPE);

    // Get user input for query
    String userQuery = someUserInput;
    // Use searchArguments to hold the user-supplied input
    Object[] searchArguments = new Object[]{userQuery};
    // Hardcode the BaseDN, use the {0} format specifier to use the searchArguments array value,
    and pass in the search controls.
    // searchArguments automatically encode
    NamingEnumeration answer = ldapContext.search("dc=example,dc=org", "(cn={0})",
    searchArguments, searchControls);
    // Process the response answer
    while (answer.hasMoreElements()) {
      ...
    }
    ```

    For more information on LDAP Injection see OWASP:
    https://cheatsheetseries.owasp.org/cheatsheets/LDAP_Injection_Prevention_Cheat_Sheet.html
  severity: "WARNING"
  metadata:
    shortDescription: "Improper neutralization of special elements used in an LDAP
      query ('LDAP Injection')"
    category: "security"
    cwe: "CWE-90"
    technology:
    - "java"
    primary_identifier: "find_sec_bugs.LDAP_INJECTION-1"
    secondary_identifiers:
    - name: "Find Security Bugs-LDAP_INJECTION"
      type: "find_sec_bugs_type"
      value: "LDAP_INJECTION"
- id: "find_sec_bugs.OGNL_INJECTION-1"
  languages:
  - "java"
  mode: "taint"
  pattern-sources:
  - patterns:
    - pattern-inside: |
        $FUNC(..., $VAR, ...) {
          ...
        }
    - metavariable-pattern:
        metavariable: "$VAR"
        pattern-either:
        - pattern: "(String $S)"
        - pattern: "(Map<String, ?> $M)"
        - pattern: "(Map<String, String> $M)"
        - pattern: "(Map<String, Object> $M)"
    - pattern: "$VAR"
  pattern-sinks:
  - patterns:
    - pattern-inside: |-
        com.opensymphony.xwork2.util.TextParseUtil.translateVariables($VAL, ...)
    - pattern: "$VAL"
  - patterns:
    - pattern-inside: |-
        com.opensymphony.xwork2.util.TextParseUtil.translateVariablesCollection($VAL, ...)
    - pattern: "$VAL"
  - pattern: "com.opensymphony.xwork2.util.TextParseUtil.shallBeIncluded(...)"
  - pattern: "com.opensymphony.xwork2.util.TextParseUtil.commaDelimitedStringToSet(...)"
  - patterns:
    - pattern-inside: |-
        (com.opensymphony.xwork2.util.TextParser $P).evaluate($VAR, $VAL, ...)
    - pattern: "$VAL"
  - patterns:
    - pattern-inside: |-
        (com.opensymphony.xwork2.util.OgnlTextParser $P).evaluate($VAR, $VAL, ...)
    - pattern: "$VAL"
  - pattern: "(com.opensymphony.xwork2.ognl.OgnlReflectionProvider $P).getGetMethod($CLZ,
      ...)"
  - pattern: "(com.opensymphony.xwork2.ognl.OgnlReflectionProvider $P).getSetMethod($CLZ,
      ...)"
  - pattern: "(com.opensymphony.xwork2.ognl.OgnlReflectionProvider $P).getField($CLZ,
      ...)"
  - patterns:
    - pattern-inside: |-
        (com.opensymphony.xwork2.ognl.OgnlReflectionProvider $P).setProperties($MAP, ...)
    - pattern: "$MAP"
  - patterns:
    - pattern-inside: |-
        (com.opensymphony.xwork2.ognl.OgnlReflectionProvider $P).setProperty($VAL, ...)
    - pattern: "$VAL"
  - patterns:
    - pattern-inside: |-
        (com.opensymphony.xwork2.ognl.OgnlReflectionProvider $P).getValue($VAL, ...)
    - pattern: "$VAL"
  - patterns:
    - pattern-inside: |-
        (com.opensymphony.xwork2.ognl.OgnlReflectionProvider $P).setValue($VAL, ...)
    - pattern: "$VAL"
  - pattern: "(com.opensymphony.xwork2.util.reflection.ReflectionProvider $P).getGetMethod($CLZ,
      ...)"
  - pattern: "(com.opensymphony.xwork2.util.reflection.ReflectionProvider $P).getSetMethod($CLZ,
      ...)"
  - pattern: "(com.opensymphony.xwork2.util.reflection.ReflectionProvider $P).getField($CLZ,
      ...)"
  - patterns:
    - pattern-inside: |-
        (com.opensymphony.xwork2.util.reflection.ReflectionProvider $P).setProperties($MAP, ...)
    - pattern: "$MAP"
  - patterns:
    - pattern-inside: |-
        (com.opensymphony.xwork2.util.reflection.ReflectionProvider $P).setProperty($VAR, ...)
    - pattern: "$VAR"
  - patterns:
    - pattern-inside: |-
        (com.opensymphony.xwork2.util.reflection.ReflectionProvider $P).getValue($VAR, ...)
    - pattern: "$VAR"
  - patterns:
    - pattern-inside: |-
        (com.opensymphony.xwork2.util.reflection.ReflectionProvider $P).setValue($VAR, ...)
    - pattern: "$VAR"
  - patterns:
    - pattern-inside: |-
        (com.opensymphony.xwork2.ognl.OgnlUtil $P).setProperties($MAP, ...)
    - pattern: "$MAP"
  - patterns:
    - pattern-inside: |-
        (com.opensymphony.xwork2.ognl.OgnlUtil $P).setProperty($VAR, ...)
    - pattern: "$VAR"
  - patterns:
    - pattern-inside: |-
        (com.opensymphony.xwork2.ognl.OgnlUtil $P).getValue($VAR, ...)
    - pattern: "$VAR"
  - patterns:
    - pattern-inside: |-
        (com.opensymphony.xwork2.ognl.OgnlUtil $P).setValue($VAR, ...)
    - pattern: "$VAR"
  - patterns:
    - pattern-inside: |-
        (com.opensymphony.xwork2.ognl.OgnlUtil $P).callMethod($VAR, ...)
    - pattern: "$VAR"
  - patterns:
    - pattern-inside: |-
        (com.opensymphony.xwork2.ognl.OgnlUtil $P).compile($VAR, ...)
    - pattern: "$VAR"
  - pattern: "(org.apache.struts2.util.VelocityStrutsUtil $P).evaluate(...)"
  - pattern: "org.apache.struts2.util.StrutsUtil.findString(...)"
  - pattern: "org.apache.struts2.util.StrutsUtil.findValue(..., $VAL)"
  - pattern: "org.apache.struts2.util.StrutsUtil.getText(...)"
  - pattern: "org.apache.struts2.util.StrutsUtil.translateVariables(...)"
  - patterns:
    - pattern-inside: |-
        org.apache.struts2.util.StrutsUtil.makeSelectList($VAR, ...)
    - pattern: "$VAR"
  - patterns:
    - pattern-inside: |-
        (org.apache.struts2.views.jsp.ui.OgnlTool $T).findValue($VAR, ...)
    - pattern: "$VAR"
  - pattern: "(com.opensymphony.xwork2.util.ValueStack $V).findString(...)"
  - patterns:
    - pattern-inside: |-
        (com.opensymphony.xwork2.util.ValueStack $V).findValue($VAR, ...)
    - pattern: "$VAR"
  - patterns:
    - pattern-inside: |-
        (com.opensymphony.xwork2.util.ValueStack $V).setValue($VAR, ...)
    - pattern: "$VAR"
  - patterns:
    - pattern-inside: |-
        (com.opensymphony.xwork2.util.ValueStack $V).setParameter($VAR, ...)
    - pattern: "$VAR"
  message: |
    The Object Graph Navigation Language (OGNL) is an expression language that allows access to
    Java objects and properties stored in an ActionContext. Usage of these low-level
    functions is discouraged because they can effectively execute strings as code, leading to
    remote code execution vulnerabilities. Consider using struts tags when processing
    user-supplied input and templates.

    Much like the Struts security guide recommending to not use raw `${}` EL expressions,
    do not call or use the following OGNL packages with user-supplied input:

    - `com.opensymphony.xwork2.ognl`
    - `com.opensymphony.xwork2.util`
    - `com.opensymphony.xwork2.util.reflection`
    - `org.apache.struts2.util.StrutsUtil`

    For more information on Struts2 security see:
    https://struts.apache.org/security/#do-not-use-incoming-untrusted-user-input-in-forced-expression-evaluation
  severity: "WARNING"
  metadata:
    shortDescription: "Expression injection (OGNL)"
    category: "security"
    cwe: "CWE-917"
    technology:
    - "java"
    primary_identifier: "find_sec_bugs.OGNL_INJECTION-1"
    secondary_identifiers:
    - name: "Find Security Bugs-OGNL_INJECTION"
      type: "find_sec_bugs_type"
      value: "OGNL_INJECTION"
- id: "find_sec_bugs.PATH_TRAVERSAL_IN-1"
  languages:
  - "java"
  message: |
    A file is opened to read its content. The filename comes from an input parameter. If an
    unfiltered parameter is passed to this file API, files from an arbitrary filesystem location
    could be read. This rule identifies potential path traversal vulnerabilities. In many cases,
    the constructed file path cannot be controlled by the user.
  metadata:
    category: "security"
    cwe: "CWE-22"
    shortDescription: "Improper Limitation of a Pathname to a Restricted Directory
      ('Path Traversal')"
    technology:
    - "java"
    primary_identifier: "find_sec_bugs.PATH_TRAVERSAL_IN-1"
    secondary_identifiers:
    - name: "Find Security Bugs-PATH_TRAVERSAL_IN"
      type: "find_sec_bugs_type"
      value: "PATH_TRAVERSAL_IN"
  mode: "taint"
  pattern-sanitizers:
  - pattern: "org.apache.commons.io.FilenameUtils.getName(...)"
  pattern-sinks:
  - patterns:
    - pattern-inside: |
        $U = new java.net.URI($VAR)
    - pattern-either:
      - pattern-inside: |-
          new java.io.File($U)
      - pattern-inside: |-
          java.nio.file.Paths.get($U)
    - pattern: "$VAR"
  - patterns:
    - pattern-inside: |-
        new java.io.RandomAccessFile($INPUT,...)
    - pattern: "$INPUT"
  - pattern: "new java.io.FileReader(...)"
  - pattern: "new javax.activation.FileDataSource(...)"
  - pattern: "new java.io.FileInputStream(...)"
  - patterns:
    - pattern-either:
      - pattern-inside: |-
          new java.io.File(...,(String $VAR), ...)
      - pattern-inside: |-
          java.nio.file.Paths.get(...,(String $VAR),...)
      - pattern-inside: |-
          java.io.File.createTempFile(...,(String $VAR), ...)
      - pattern-inside: |-
          java.io.File.createTempDirectory(...,(String $VAR),...)
      - pattern-inside: |-
          java.nio.file.Files.createTempFile(..., (String $VAR), ...)
      - pattern-inside: |-
          java.nio.file.Files.createTempDirectory(..., (String $VAR), ...)
    - pattern: "$VAR"
  pattern-sources:
  - patterns:
    - pattern-inside: |
        $FUNC(String[] $ARGS) {
          ...
        }
    - pattern: "$ARGS[$IDX]"
  - patterns:
    - pattern-inside: |
        $FUNC(..., String $VAR, ...) {
          ...
        }
    - pattern: "$VAR"
  severity: "ERROR"
- id: "find_sec_bugs.PATH_TRAVERSAL_OUT-1.PATH_TRAVERSAL_OUT-1"
  languages:
  - "java"
  message: |
    A file is opened to write to its contents. The filename comes from an input parameter. If an
    unfiltered parameter is passed to this file API, files at an arbitrary filesystem location
    could be modified. This rule identifies potential path traversal vulnerabilities. In many
    cases, the constructed file path cannot be controlled by the user.
  metadata:
    category: "security"
    cwe: "CWE-22"
    shortDescription: "Improper Limitation of a Pathname to a Restricted Directory
      ('Path Traversal')"
    technology:
    - "java"
    primary_identifier: "find_sec_bugs.PATH_TRAVERSAL_OUT-1.PATH_TRAVERSAL_OUT-1"
    secondary_identifiers:
    - name: "Find Security Bugs-PATH_TRAVERSAL_OUT"
      type: "find_sec_bugs_type"
      value: "PATH_TRAVERSAL_OUT"
  mode: "taint"
  pattern-sanitizers:
  - pattern: "org.apache.commons.io.FilenameUtils.getName(...)"
  pattern-sinks:
  - patterns:
    - pattern-inside: |-
        new java.io.FileWriter($PATH, ...)
    - pattern: "$PATH"
  - patterns:
    - pattern-inside: |-
        new java.io.FileOutputStream($PATH, ...)
    - pattern: "$PATH"
  pattern-sources:
  - patterns:
    - pattern-inside: |
        $FUNC(String[] $ARGS) {
          ...
        }
    - pattern: "$ARGS[$IDX]"
  - patterns:
    - pattern-inside: |
        $FUNC(..., String $VAR, ...) {
          ...
        }
    - pattern: "$VAR"
  severity: "ERROR"
- id: "find_sec_bugs.PT_ABSOLUTE_PATH_TRAVERSAL-1"
  languages:
  - "java"
  mode: "taint"
  pattern-sanitizers:
  - pattern: "org.apache.commons.io.FilenameUtils.getName(...)"
  pattern-sinks:
  - patterns:
    - pattern-inside: |
        $U = new java.net.URI($VAR)
    - pattern-either:
      - pattern-inside: |-
          new java.io.File($U)
      - pattern-inside: |-
          java.nio.file.Paths.get($U)
    - pattern: "$VAR"
  - patterns:
    - pattern-inside: |-
        new java.io.RandomAccessFile($INPUT,...)
    - pattern: "$INPUT"
  - pattern: "new java.io.FileReader(...)"
  - pattern: "new javax.activation.FileDataSource(...)"
  - pattern: "new java.io.FileInputStream(...)"
  - pattern: "new java.io.File(...)"
  - pattern: "java.nio.file.Paths.get(...)"
  - pattern: "java.io.File.createTempFile(...)"
  - pattern: "java.io.File.createTempDirectory(...)"
  - pattern: "java.nio.file.Files.createTempFile(...)"
  - pattern: "java.nio.file.Files.createTempDirectory(...)"
  - patterns:
    - pattern: "$SRC.$METHOD(...)"
    - metavariable-pattern:
        metavariable: "$SRC"
        pattern-either:
        - pattern: "getClass()"
        - pattern: "getClass().getClassLoader()"
        - pattern: "(ClassLoader $C)"
        - pattern: "(Class $C)"
        - pattern: "$CLZ.getClassLoader()"
    - metavariable-pattern:
        metavariable: "$METHOD"
        pattern-either:
        - pattern: "getResourceAsStream"
        - pattern: "getResource"
  - patterns:
    - pattern-inside: |-
        new java.io.FileWriter($PATH, ...)
    - pattern: "$PATH"
  - patterns:
    - pattern-inside: |-
        new java.io.FileOutputStream($PATH, ...)
    - pattern: "$PATH"
  pattern-sources:
  - pattern: "(HttpServletRequest $REQ).getParameter(...)"
  - patterns:
    - pattern-inside: |-
        $FUNC(..., @RequestParam $TYPE $REQ, ...) {...}
    - focus-metavariable: "$REQ"
  message: |
    The application dynamically constructs file or path information. If the path
    information comes from user input, it could be abused to read sensitive files,
    access other users' data, or aid in exploitation to gain further system access.

    User input should never be used in constructing paths or files for interacting
    with the filesystem. This includes filenames supplied by user uploads or downloads.
    If possible, consider hashing user input or replacing it with unique values and
    use `Path.resolve` to resolve and validate the path information
    prior to processing any file functionality.

    Example using `Path.resolve` and not allowing direct user input:
    ```
    // Class to store our user data along with a randomly generated file name
    public static class UserData {
        private String userFileNameUnsafe;
        private String fileName;
        public UserData(String userFileName) {
            this.userFileNameUnsafe = userFileName;
            // Generate a random ID for the filename
            this.fileName = UUID.randomUUID().toString();
        }
        public String getUserFileNameUnsafe() { return userFileNameUnsafe; };
        public String getFileName() { return fileName; };
    }

    public static void main(String[] args) throws Exception {
        // User input, saved only as a reference
        UserData userData = new UserData("..\\test.txt");
        // Restrict all file processing to this directory only
        String base = "/var/app/restricted";
        Path basePath = Paths.get(base);
        // Resolve the full path, but only use our random generated filename
        Path fullPath = basePath.resolve(userData.getFileName());
        // verify the path is contained within our basePath
        if (!fullPath.startsWith(base)) {
            throw new Exception("Invalid path specified!");
        }
        // process / work with file
    }
    ```

    For more information on path traversal issues see OWASP:
    https://owasp.org/www-community/attacks/Path_Traversal
  severity: "WARNING"
  metadata:
    shortDescription: "Improper limitation of a pathname to a restricted directory
      ('Path Traversal')"
    category: "security"
    cwe: "CWE-22"
    technology:
    - "java"
    primary_identifier: "find_sec_bugs.PT_ABSOLUTE_PATH_TRAVERSAL-1"
    secondary_identifiers:
    - name: "Find Security Bugs-PT_ABSOLUTE_PATH_TRAVERSAL"
      type: "find_sec_bugs_type"
      value: "PT_ABSOLUTE_PATH_TRAVERSAL"
- id: "find_sec_bugs.PT_RELATIVE_PATH_TRAVERSAL-1"
  languages:
  - "java"
  message: |
    "The software uses an HTTP request parameter to construct a pathname that should be within a
    restricted directory, but it does not properly neutralize sequences such as ".." that can
    resolve to a location that is outside of that directory. See
    http://cwe.mitre.org/data/definitions/23.html for more information."
  metadata:
    category: "security"
    cwe: "CWE-22"
    shortDescription: "Improper Limitation of a Pathname to a Restricted Directory
      ('Path Traversal')"
    technology:
    - "java"
    primary_identifier: "find_sec_bugs.PT_RELATIVE_PATH_TRAVERSAL-1"
    secondary_identifiers:
    - name: "Find Security Bugs-PT_RELATIVE_PATH_TRAVERSAL"
      type: "find_sec_bugs_type"
      value: "PT_RELATIVE_PATH_TRAVERSAL"
  mode: "taint"
  pattern-sanitizers:
  - pattern: "org.apache.commons.io.FilenameUtils.getName(...)"
  pattern-sinks:
  - patterns:
    - pattern-inside: |
        $U = new java.net.URI($VAR)
    - pattern-either:
      - pattern-inside: |-
          new java.io.File($U)
      - pattern-inside: |-
          java.nio.file.Paths.get($U)
    - pattern: "$VAR"
  - patterns:
    - pattern-inside: |-
        new java.io.RandomAccessFile($INPUT,...)
    - pattern: "$INPUT"
  - pattern: "new java.io.FileReader(...)"
  - pattern: "new javax.activation.FileDataSource(...)"
  - pattern: "new java.io.FileInputStream(...)"
  - pattern: "new java.io.File(...)"
  - pattern: "java.nio.file.Paths.get(...)"
  - pattern: "java.io.File.createTempFile(...)"
  - pattern: "java.io.File.createTempDirectory(...)"
  - pattern: "java.nio.file.Files.createTempFile(...)"
  - pattern: "java.nio.file.Files.createTempDirectory(...)"
  - patterns:
    - pattern-inside: |-
        new java.io.FileWriter($PATH, ...)
    - pattern: "$PATH"
  - patterns:
    - pattern-inside: |-
        new java.io.FileOutputStream($PATH, ...)
    - pattern: "$PATH"
  pattern-sources:
  - patterns:
    - pattern-inside: |
        $P = (HttpServletRequest $REQ).getParameter(...);
        ...
    - pattern-either:
      - pattern: "$P + ..."
      - pattern: "... + $P"
  severity: "WARNING"
- id: "find_sec_bugs.SQL_INJECTION_SPRING_JDBC-1.SQL_INJECTION_JPA-1.SQL_INJECTION_JDO-1.SQL_INJECTION_JDBC-1.SQL_NONCONSTANT_STRING_PASSED_TO_EXECUTE-1.SQL_INJECTION-1.SQL_INJECTION_HIBERNATE-1.SQL_INJECTION_VERTX-1.SQL_PREPARED_STATEMENT_GENERATED_FROM_NONCONSTANT_STRING-1"
  languages:
  - "java"
  message: |
    SQL Injection is a critical vulnerability that can lead to data or system compromise. By
    dynamically generating SQL query strings, user input may be able to influence the logic of
    the SQL statement. This could lead to an adversary accessing information they should
    not have access to, or in some circumstances, being able to execute OS functionality or code.

    Replace all dynamically generated SQL queries with parameterized queries. In situations where
    dynamic queries must be created, never use direct user input, but instead use a map or
    dictionary of valid values and resolve them using a user supplied key.

    For example, some database drivers do not allow parameterized queries for `>` or `<` comparison
    operators. In these cases, do not use a user supplied `>` or `<` value, but rather have the
    user
    supply a `gt` or `lt` value. The alphabetical values are then used to look up the `>` and `<`
    values to be used in the construction of the dynamic query. The same goes for other queries
    where
    column or table names are required but cannot be parameterized.

    Example using `PreparedStatement` queries:
    ```
    // Some userInput
    String userInput = "someUserInput";
    // Your connection string
    String url = "...";
    // Get a connection from the DB via the DriverManager
    Connection conn = DriverManager.getConnection(url);
    // Create a prepared statement
    PreparedStatement st = conn.prepareStatement("SELECT name FROM table where name=?");
    // Set each parameters value by the index (starting from 1)
    st.setString(1, userInput);
    // Execute query and get the result set
    ResultSet rs = st.executeQuery();
    // Iterate over results
    while (rs.next()) {
        // Get result for this row at the provided column number (starting from 1)
        String result = rs.getString(1);
        // ...
    }
    // Close the ResultSet
    rs.close();
    // Close the PreparedStatement
    st.close();
    ```

    For more information on SQL Injection see OWASP:
    https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html
  metadata:
    shortDescription: "Improper Neutralization of Special Elements used in an SQL
      Command ('SQL Injection')"
    category: "security"
    cwe: "CWE-89"
    primary_identifier: "find_sec_bugs.SQL_INJECTION_SPRING_JDBC-1.SQL_INJECTION_JPA-1.SQL_INJECTION_JDO-1.SQL_INJECTION_JDBC-1.SQL_NONCONSTANT_STRING_PASSED_TO_EXECUTE-1.SQL_INJECTION-1.SQL_INJECTION_HIBERNATE-1.SQL_INJECTION_VERTX-1.SQL_PREPARED_STATEMENT_GENERATED_FROM_NONCONSTANT_STRING-1"
    secondary_identifiers:
    - name: "Find Security Bugs-SQL_INJECTION_SPRING_JDBC"
      type: "find_sec_bugs_type"
      value: "SQL_INJECTION_SPRING_JDBC"
    - name: "Find Security Bugs-SQL_INJECTION_JPA"
      type: "find_sec_bugs_type"
      value: "SQL_INJECTION_JPA"
    - name: "Find Security Bugs-SQL_INJECTION_JDO"
      type: "find_sec_bugs_type"
      value: "SQL_INJECTION_JDO"
    - name: "Find Security Bugs-SQL_INJECTION_JDBC"
      type: "find_sec_bugs_type"
      value: "SQL_INJECTION_JDBC"
    - name: "Find Security Bugs-SQL_NONCONSTANT_STRING_PASSED_TO_EXECUTE"
      type: "find_sec_bugs_type"
      value: "SQL_NONCONSTANT_STRING_PASSED_TO_EXECUTE"
    - name: "Find Security Bugs-SQL_INJECTION"
      type: "find_sec_bugs_type"
      value: "SQL_INJECTION"
    - name: "Find Security Bugs-SQL_INJECTION_HIBERNATE"
      type: "find_sec_bugs_type"
      value: "SQL_INJECTION_HIBERNATE"
    - name: "Find Security Bugs-SQL_INJECTION_VERTX"
      type: "find_sec_bugs_type"
      value: "SQL_INJECTION_VERTX"
    - name: "Find Security Bugs-SQL_PREPARED_STATEMENT_GENERATED_FROM_NONCONSTANT_STRING"
      type: "find_sec_bugs_type"
      value: "SQL_PREPARED_STATEMENT_GENERATED_FROM_NONCONSTANT_STRING"
  patterns:
  - pattern-not-inside: |
      final String $ARG = ...;
      ...
  - pattern-not-inside: |
      class $CLAZZ {
        ...
        final String $ARG = ...;
        ...
      }
  - pattern-either:
    - patterns:
      - pattern: "(javax.jdo.PersistenceManager $PM).newQuery($ARG)"
      - pattern-not: "(javax.jdo.PersistenceManager $PM).newQuery(\"...\")"
    - patterns:
      - pattern: "(javax.jdo.PersistenceManager $PM).newQuery(..., $ARG)"
      - pattern-not: "(javax.jdo.PersistenceManager $PM).newQuery(..., \"...\")"
    - patterns:
      - pattern: "(javax.jdo.Query $Q).setFilter($ARG)"
      - pattern-not: "(javax.jdo.Query $Q).setFilter(\"...\")"
    - patterns:
      - pattern: "(javax.jdo.Query $Q).setGrouping($ARG)"
      - pattern-not: "(javax.jdo.Query $Q).setGrouping(\"...\")"
    - patterns:
      - pattern: "(javax.jdo.Query $Q).setGrouping($ARG)"
      - pattern-not: "(javax.jdo.Query $Q).setGrouping(\"...\")"
    - patterns:
      - pattern: "org.hibernate.criterion.Restrictions.sqlRestriction($ARG, ...)"
      - pattern-not: "org.hibernate.criterion.Restrictions.sqlRestriction(\"...\",
          ...)"
    - patterns:
      - pattern: "(org.hibernate.Session $S).createQuery((String $ARG), ...)"
      - pattern-not: "(org.hibernate.Session $S).createQuery(\"...\", ...)"
    - patterns:
      - pattern: "(org.hibernate.Session $S).createSQLQuery($ARG, ...)"
      - pattern-not: "(org.hibernate.Session $S).createSQLQuery(\"...\", ...)"
    - patterns:
      - pattern: "(java.sql.Statement $S).executeQuery($ARG, ...)"
      - pattern-not: "(java.sql.Statement $S).createSQLQuery(\"...\", ...)"
    - patterns:
      - pattern: "(java.sql.Statement $S).execute($ARG, ...)"
      - pattern-not: "(java.sql.Statement $S).execute(\"...\", ...)"
    - patterns:
      - pattern: "(java.sql.Statement $S).executeUpdate($ARG, ...)"
      - pattern-not: "(java.sql.Statement $S).executeUpdate(\"...\", ...)"
    - patterns:
      - pattern: "(java.sql.Statement $S).executeLargeUpdate($ARG, ...)"
      - pattern-not: "(java.sql.Statement $S).executeLargeUpdate(\"...\", ...)"
    - patterns:
      - pattern: "(java.sql.Statement $S).addBatch($ARG, ...)"
      - pattern-not: "(java.sql.Statement $S).addBatch(\"...\", ...)"
    - patterns:
      - pattern: "(java.sql.PreparedStatement $S).executeQuery($ARG, ...)"
      - pattern-not: "(java.sql.PreparedStatement $S).executeQuery(\"...\", ...)"
    - patterns:
      - pattern: "(java.sql.PreparedStatement $S).execute($ARG, ...)"
      - pattern-not: "(java.sql.PreparedStatement $S).execute(\"...\", ...)"
    - patterns:
      - pattern: "(java.sql.PreparedStatement $S).executeUpdate($ARG, ...)"
      - pattern-not: "(java.sql.PreparedStatement $S).executeUpdate(\"...\", ...)"
    - patterns:
      - pattern: "(java.sql.PreparedStatement $S).executeLargeUpdate($ARG, ...)"
      - pattern-not: "(java.sql.PreparedStatement $S).executeLargeUpdate(\"...\",
          ...)"
    - patterns:
      - pattern: "(java.sql.PreparedStatement $S).addBatch($ARG, ...)"
      - pattern-not: "(java.sql.PreparedStatement $S).addBatch(\"...\", ...)"
    - patterns:
      - pattern: "(java.sql.Connection $S).prepareCall($ARG, ...)"
      - pattern-not: "(java.sql.Connection $S).prepareCall(\"...\", ...)"
    - patterns:
      - pattern: "(java.sql.Connection $S).prepareStatement($ARG, ...)"
      - pattern-not: "(java.sql.Connection $S).prepareStatement(\"...\", ...)"
    - patterns:
      - pattern: "(java.sql.Connection $S).nativeSQL($ARG, ...)"
      - pattern-not: "(java.sql.Connection $S).nativeSQL(\"...\", ...)"
    - patterns:
      - pattern: "new org.springframework.jdbc.core.PreparedStatementCreatorFactory($ARG,
          ...)"
      - pattern-not: "new org.springframework.jdbc.core.PreparedStatementCreatorFactory(\"...\",
          ...)"
    - patterns:
      - pattern: "(org.springframework.jdbc.core.PreparedStatementCreatorFactory $F).newPreparedStatementCreator($ARG,
          ...)"
      - pattern-not: "(org.springframework.jdbc.core.PreparedStatementCreatorFactory
          $F).newPreparedStatementCreator(\"...\", ...)"
    - patterns:
      - pattern: "(org.springframework.jdbc.core.JdbcOperations $O).batchUpdate($ARG,
          ...)"
      - pattern-not: "(org.springframework.jdbc.core.JdbcOperations $O).batchUpdate(\"...\",
          ...)"
    - patterns:
      - pattern: "(org.springframework.jdbc.core.JdbcOperations $O).execute($ARG,
          ...)"
      - pattern-not: "(org.springframework.jdbc.core.JdbcOperations $O).execute(\"...\",
          ...)"
    - patterns:
      - pattern: "(org.springframework.jdbc.core.JdbcOperations $O).query($ARG, ...)"
      - pattern-not: "(org.springframework.jdbc.core.JdbcOperations $O).query(\"...\",
          ...)"
    - patterns:
      - pattern: "(org.springframework.jdbc.core.JdbcOperations $O).queryForList($ARG,
          ...)"
      - pattern-not: "(org.springframework.jdbc.core.JdbcOperations $O).queryForList(\"...\",
          ...)"
    - patterns:
      - pattern: "(org.springframework.jdbc.core.JdbcOperations $O).queryForMap($ARG,
          ...)"
      - pattern-not: "(org.springframework.jdbc.core.JdbcOperations $O).queryForMap(\"...\",
          ...)"
    - patterns:
      - pattern: "(org.springframework.jdbc.core.JdbcOperations $O).queryForObject($ARG,
          ...)"
      - pattern-not: "(org.springframework.jdbc.core.JdbcOperations $O).queryForObject(\"...\",
          ...)"
    - patterns:
      - pattern: "(org.springframework.jdbc.core.JdbcOperations $O).queryForObject($ARG,
          ...)"
      - pattern-not: "(org.springframework.jdbc.core.JdbcOperations $O).queryForObject(\"...\",
          ...)"
    - patterns:
      - pattern: "(org.springframework.jdbc.core.JdbcOperations $O).queryForRowSet($ARG,
          ...)"
      - pattern-not: "(org.springframework.jdbc.core.JdbcOperations $O).queryForRowSet(\"...\",
          ...)"
    - patterns:
      - pattern: "(org.springframework.jdbc.core.JdbcOperations $O).queryForInt($ARG,
          ...)"
      - pattern-not: "(org.springframework.jdbc.core.JdbcOperations $O).queryForInt(\"...\",
          ...)"
    - patterns:
      - pattern: "(org.springframework.jdbc.core.JdbcOperations $O).queryForLong($ARG,
          ...)"
      - pattern-not: "(org.springframework.jdbc.core.JdbcOperations $O).queryForLong(\"...\",
          ...)"
    - patterns:
      - pattern: "(org.springframework.jdbc.core.JdbcOperations $O).udpate($ARG, ...)"
      - pattern-not: "(org.springframework.jdbc.core.JdbcOperations $O).udpate(\"...\",
          ...)"
    - patterns:
      - pattern: "(org.springframework.jdbc.core.JdbcTemplate $O).batchUpdate($ARG,
          ...)"
      - pattern-not: "(org.springframework.jdbc.core.JdbcTemplate $O).batchUpdate(\"...\",
          ...)"
    - patterns:
      - pattern: "(org.springframework.jdbc.core.JdbcTemplate $O).execute($ARG, ...)"
      - pattern-not: "(org.springframework.jdbc.core.JdbcTemplate $O).execute(\"...\",
          ...)"
    - patterns:
      - pattern: "(org.springframework.jdbc.core.JdbcTemplate $O).query($ARG, ...)"
      - pattern-not: "(org.springframework.jdbc.core.JdbcTemplate $O).query(\"...\",
          ...)"
    - patterns:
      - pattern: "(org.springframework.jdbc.core.JdbcTemplate $O).queryForList($ARG,
          ...)"
      - pattern-not: "(org.springframework.jdbc.core.JdbcTemplate $O).queryForList(\"...\",
          ...)"
    - patterns:
      - pattern: "(org.springframework.jdbc.core.JdbcTemplate $O).queryForMap($ARG,
          ...)"
      - pattern-not: "(org.springframework.jdbc.core.JdbcTemplate $O).queryForMap(\"...\",
          ...)"
    - patterns:
      - pattern: "(org.springframework.jdbc.core.JdbcTemplate $O).queryForObject($ARG,
          ...)"
      - pattern-not: "(org.springframework.jdbc.core.JdbcTemplate $O).queryForObject(\"...\",
          ...)"
    - patterns:
      - pattern: "(org.springframework.jdbc.core.JdbcTemplate $O).queryForRowSet($ARG,
          ...)"
      - pattern-not: "(org.springframework.jdbc.core.JdbcTemplate $O).queryForRowSet(\"...\",
          ...)"
    - patterns:
      - pattern: "(org.springframework.jdbc.core.JdbcTemplate $O).queryForInt($ARG,
          ...)"
      - pattern-not: "(org.springframework.jdbc.core.JdbcTemplate $O).queryForInt(\"...\",
          ...)"
    - patterns:
      - pattern: "(org.springframework.jdbc.core.JdbcTemplate $O).queryForLong($ARG,
          ...)"
      - pattern-not: "(org.springframework.jdbc.core.JdbcTemplate $O).queryForLong(\"...\",
          ...)"
    - patterns:
      - pattern: "(org.springframework.jdbc.core.JdbcTemplate $O).update($ARG, ...)"
      - pattern-not: "(org.springframework.jdbc.core.JdbcTemplate $O).update(\"...\",
          ...)"
    - patterns:
      - pattern: "(io.vertx.sqlclient.SqlClient $O).query($ARG, ...)"
      - pattern-not: "(io.vertx.sqlclient.SqlClient $O).query(\"...\", ...)"
    - patterns:
      - pattern: "(io.vertx.sqlclient.SqlClient $O).preparedQuery($ARG, ...)"
      - pattern-not: "(io.vertx.sqlclient.SqlClient $O).preparedQuery(\"...\", ...)"
    - patterns:
      - pattern: "(io.vertx.sqlclient.SqlConnection $O).prepare($ARG, ...)"
      - pattern-not: "(io.vertx.sqlclient.SqlConnection $O).prepare(\"...\", ...)"
    - patterns:
      - pattern: "(org.apache.turbine.om.peer.BasePeer $O).executeQuery($ARG, ...)"
      - pattern-not: "(org.apache.turbine.om.peer.BasePeer $O).executeQuery(\"...\",
          ...)"
    - patterns:
      - pattern: "(org.apache.torque.util.BasePeer $O).executeQuery($ARG, ...)"
      - pattern-not: "(org.apache.torque.util.BasePeer $O).executeQuery(\"...\", ...)"
    - patterns:
      - pattern: "(javax.persistence.EntityManager $O).createQuery($ARG, ...)"
      - pattern-not: "(javax.persistence.EntityManager $O).createQuery(\"...\", ...)"
    - patterns:
      - pattern: "(javax.persistence.EntityManager $O).createNativeQuery($ARG, ...)"
      - pattern-not: "(javax.persistence.EntityManager $O).createNativeQuery(\"...\",
          ...)"
  severity: "ERROR"
- id: "find_sec_bugs.LDAP_ANONYMOUS-1"
  languages:
  - "java"
  patterns:
  - pattern-inside: |
      import javax.naming.Context;
      ...
  - pattern: "$ENV.put(Context.SECURITY_AUTHENTICATION, \"none\");"
  message: |
    The application does not provide authentication when communicating an LDAP
    server. It is strongly recommended that the LDAP server be configured with
    authentication and restrict what queries users can execute.

    Example code that authenticates with a remote LDAP server and encodes any
    user-supplied input:
    ```
    // Create a properties to hold the ldap connection details
    Properties props = new Properties();
    // Use the com.sun.jndi.ldap.LdapCtxFactory factory provider
    props.put(Context.INITIAL_CONTEXT_FACTORY, "com.sun.jndi.ldap.LdapCtxFactory");
    // The LDAP server URL
    props.put(Context.PROVIDER_URL, "ldap://ldap.example.org:3889");
    // User details for the connection
    props.put(Context.SECURITY_PRINCIPAL, "cn=admin,dc=example,dc=org");
    // LDAP account password
    String ldapAccountPassword = getAccountPasswordFromSecureStoreOrKMS();
    // Pass in the LDAP password
    props.put(Context.SECURITY_CREDENTIALS, ldapAccountPassword);

    // Create the LDAPContext
    InitialDirContext ldapContext = new InitialDirContext(props);
    // Example using SUBTREE_SCOPE SearchControls
    SearchControls searchControls = new SearchControls();
    searchControls.setSearchScope(SearchControls.SUBTREE_SCOPE);

    // Get user input for query
    String userQuery = someUserInput;
    // Use searchArguments to hold the user-supplied input
    Object[] searchArguments = new Object[]{userQuery};
    // Hardcode the BaseDN, use the {0} format specifier to use the searchArguments array value,
    and pass in the search controls.
    // searchArguments automatically encode
    NamingEnumeration answer = ldapContext.search("dc=example,dc=org", "(cn={0})",
    searchArguments, searchControls);
    // Process the response answer
    while (answer.hasMoreElements()) {
      ...
    }
    ```

    For information on enabling authentication, please see your LDAP server's
    documentation.

    For more information on LDAP Injection see OWASP:
    https://cheatsheetseries.owasp.org/cheatsheets/LDAP_Injection_Prevention_Cheat_Sheet.html
  metadata:
    shortDescription: "Missing authentication for critical function (LDAP)"
    category: "security"
    cwe: "CWE-306"
    primary_identifier: "find_sec_bugs.LDAP_ANONYMOUS-1"
    secondary_identifiers:
    - name: "Find Security Bugs-LDAP_ANONYMOUS"
      type: "find_sec_bugs_type"
      value: "LDAP_ANONYMOUS"
  severity: "WARNING"
- id: "find_sec_bugs.LDAP_ENTRY_POISONING-1"
  languages:
  - "java"
  message: |
    Without proper access control, executing an LDAP statement that contains a
    user-controlled value can allow an attacker to abuse poorly configured LDAP
    context
  metadata:
    category: "security"
    cwe: "CWE-20"
    shortDescription: "Improper Input Validation"
    primary_identifier: "find_sec_bugs.LDAP_ENTRY_POISONING-1"
    secondary_identifiers:
    - name: "Find Security Bugs-LDAP_ENTRY_POISONING"
      type: "find_sec_bugs_type"
      value: "LDAP_ENTRY_POISONING"
  patterns:
  - pattern: "new javax.naming.directory.SearchControls($SCOPE, $CLIMIT, $TLIMIT,
      $ATTR, true, $DEREF)"
  severity: "ERROR"
- id: "find_sec_bugs.DMI_CONSTANT_DB_PASSWORD-1.HARD_CODE_PASSWORD-3"
  languages:
  - "java"
  patterns:
  - pattern: "java.sql.DriverManager.getConnection($URI, $USR, \"...\");"
  message: |
    A potential hard-coded password was identified in a database connection string.
    Passwords should not be stored directly in code
    but loaded from secure locations such as a Key Management System (KMS).

    The purpose of using a Key Management System is so access can be audited and keys easily
    rotated
    in the event of a breach. By hardcoding passwords, it will be extremely difficult to determine
    when or if, a key is compromised.

    The recommendation on which KMS to use depends on the environment the application is running
    in:

    - For Google Cloud Platform consider [Cloud Key Management](https://cloud.google.com/kms/docs)
    - For Amazon Web Services consider [AWS Key Management](https://aws.amazon.com/kms/)
    - For on premise or other alternatives to cloud providers, consider [Hashicorp's
    Vault](https://www.vaultproject.io/)
    - For other cloud providers, please see their documentation
  severity: "WARNING"
  metadata:
    shortDescription: "Use of hard-coded password"
    category: "security"
    cwe: "CWE-259"
    technology:
    - "java"
    primary_identifier: "find_sec_bugs.DMI_CONSTANT_DB_PASSWORD-1.HARD_CODE_PASSWORD-3"
    secondary_identifiers:
    - name: "Find Security Bugs-DMI_CONSTANT_DB_PASSWORD"
      type: "find_sec_bugs_type"
      value: "DMI_CONSTANT_DB_PASSWORD"
    - name: "Find Security Bugs-HARD_CODE_PASSWORD"
      type: "find_sec_bugs_type"
      value: "HARD_CODE_PASSWORD"
- id: "find_sec_bugs.DMI_EMPTY_DB_PASSWORD-1.HARD_CODE_PASSWORD-2"
  languages:
  - "java"
  patterns:
  - pattern: "java.sql.DriverManager.getConnection($URI, $USR, \"\");"
  message: |
    The application does not provide authentication when communicating a database
    server. It is strongly recommended that the database server be configured with
    authentication and restrict what queries users can execute.

    Please see your database server's documentation on how to configure a password.

    Additionally, passwords should not be stored directly in code
    but loaded from secure locations such as a Key Management System (KMS).

    The purpose of using a Key Management System is so access can be audited and keys easily
    rotated
    in the event of a breach. By hardcoding passwords, it will be extremely difficult to determine
    when or if, a key is compromised.

    The recommendation on which KMS to use depends on the environment the application is running
    in:

    - For Google Cloud Platform consider [Cloud Key Management](https://cloud.google.com/kms/docs)
    - For Amazon Web Services consider [AWS Key Management](https://aws.amazon.com/kms/)
    - For on premise or other alternatives to cloud providers, consider [Hashicorp's
    Vault](https://www.vaultproject.io/)
    - For other cloud providers, please see their documentation
  severity: "WARNING"
  metadata:
    shortDescription: "Missing authentication for critical function (database)"
    category: "security"
    cwe: "CWE-306"
    technology:
    - "java"
    primary_identifier: "find_sec_bugs.DMI_EMPTY_DB_PASSWORD-1.HARD_CODE_PASSWORD-2"
    secondary_identifiers:
    - name: "Find Security Bugs-DMI_EMPTY_DB_PASSWORD"
      type: "find_sec_bugs_type"
      value: "DMI_EMPTY_DB_PASSWORD"
    - name: "Find Security Bugs-HARD_CODE_PASSWORD"
      type: "find_sec_bugs_type"
      value: "HARD_CODE_PASSWORD"
- id: "find_sec_bugs.HARD_CODE_PASSWORD-1"
  languages:
  - "java"
  patterns:
  - pattern-either:
    - pattern-inside: |
        char[] $PWD = ...;
        ...
    - pattern-inside: |
        String $PWD = ...;
        ...
    - pattern-inside: |
        public class $CLAZZ {
        final char[] $PWD = ...;
          ...
        }
    - pattern-inside: |
        public class $CLAZZ {
        final String $PWD = ...;
          ...
        }
    - pattern-inside: |
        $S = new SymmetricEncryptionConfig(...);
        ...
  - pattern-either:
    - pattern: "(java.security.KeyStore $KS).load(..., \"...\")"
    - pattern: "(java.security.KeyStore $KS).load(..., \"...\".$FOO(...))"
    - pattern: "(java.security.KeyStore $KS).load(..., $PWD)"
    - pattern: "(java.security.KeyStore $KS).load(..., $PWD.$FOO(...))"
    - pattern: "KeyManagerFactory.getInstance(...).init(..., $PWD);"
    - pattern: "KeyManagerFactory.getInstance(...).init(..., $PWD.$FOO(...));"
    - pattern: "KeyManagerFactory.getInstance(...).init(..., \"...\");"
    - pattern: "KeyManagerFactory.getInstance(...).init(..., \"...\".$FOO(...));"
    - pattern: "(java.security.KeyStore $KS).getInstance(...).load(..., \"...\")"
    - pattern: "(java.security.KeyStore $KS).getInstance(...).load(..., \"...\".$FOO(...))"
    - pattern: "(java.security.KeyStore $KS).getInstance(...).load(..., $PWD)"
    - pattern: "(java.security.KeyStore $KS).getInstance(...).load(..., $PWD.$FOO(...))"
    - pattern: "KeyStore.getInstance(...).load(..., \"...\");"
    - pattern: "KeyStore.getInstance(...).load(..., \"...\".$FOO(...));"
    - pattern: "KeyStore.getInstance(...).load(..., $PWD);"
    - pattern: "KeyStore.getInstance(...).load(..., $PWD.$FOO(...));"
    - pattern: "new PBEKeySpec(\"...\", ...)"
    - pattern: "new PBEKeySpec(\"...\".$FOO(...), ...)"
    - pattern: "new PBEKeySpec($PWD, ...)"
    - pattern: "new PBEKeySpec($PWD.$FOO(...), ...)"
    - pattern: "new PasswordAuthentication(\"...\", \"...\")"
    - pattern: "new PasswordAuthentication(\"...\", \"...\".$FOO(...))"
    - pattern: "new PasswordAuthentication(\"...\", $PWD)"
    - pattern: "new PasswordAuthentication(\"...\", $PWD.$FOO(...))"
    - pattern: "(PasswordCallback $CB).setPassword(\"...\")"
    - pattern: "(PasswordCallback $CB).setPassword(\"...\".$FOO(...))"
    - pattern: "(PasswordCallback $CB).setPassword($PWD)"
    - pattern: "(PasswordCallback $CB).setPassword($PWD.$FOO(...))"
    - pattern: "new KeyStore.PasswordProtection(\"...\")"
    - pattern: "new KeyStore.PasswordProtection(\"...\".$FOO(...))"
    - pattern: "new KeyStore.PasswordProtection($PWD)"
    - pattern: "new KeyStore.PasswordProtection($PWD.$FOO(...))"
    - pattern: "new KerberosKey(...,\"...\",...);"
    - pattern: "new KerberosKey(...,\"...\".$FOO(...),...);"
    - pattern: "new KerberosKey(...,$PWD,...);"
    - pattern: "new KerberosKey(...,$PWD.$FOO(...),...);"
    - pattern: "(javax.net.ssl.KeyManagerFactory $KMF).init(..., $PWD);"
    - pattern: "(javax.net.ssl.KeyManagerFactory $KMF).init(..., \"...\");"
    - pattern: "(javax.net.ssl.KeyManagerFactory $KMF).init(..., \"...\".$FOO(...));"
    - pattern: "(javax.net.ssl.KeyManagerFactory $KMF).init(..., $PWD.$FOO(...));"
    - pattern: "(java.sql.DriverManager).getConnection(..., \"...\");"
    - pattern: "(java.sql.DriverManager).getConnection(..., \"...\".$FOO(...));"
    - pattern: "(java.sql.DriverManager).getConnection(..., $PWD);"
    - pattern: "(java.sql.DriverManager).getConnection(..., $PWD.$FOO(...));"
    - pattern: "(javax.net.ssl.KeyManagerFactory $KMF).init(..., \"...\");"
    - pattern: "(javax.net.ssl.KeyManagerFactory $KMF).init(..., \"...\".$FOO(...));"
    - pattern: "(javax.net.ssl.KeyManagerFactory $KMF).init(..., $PWD);"
    - pattern: "(javax.net.ssl.KeyManagerFactory $KMF).init(..., $PWD.$FOO(...));"
    - pattern: "io.vertx.ext.web.handler.CSRFHandler.create(..., \"...\");"
    - pattern: "io.vertx.ext.web.handler.CSRFHandler.create(..., \"...\".$FOO(...));"
    - pattern: "io.vertx.ext.web.handler.CSRFHandler.create(..., $PWD);"
    - pattern: "io.vertx.ext.web.handler.CSRFHandler.create(..., $PWD.$FOO(...));"
    - pattern: "$S.setPassword($PWD);"
    - pattern: "$S.setPassword($PWD.$FOO(...));"
    - pattern: "$S.setPassword(\"...\");"
  - metavariable-regex:
      metavariable: "$PWD"
      regex: "(?i).*(pass|pwd|psw|secret|key|cipher|crypt|des|aes|mac|private|sign|cert).*"
  message: |
    A potential hard-coded password was identified in a hard-coded string.
    Passwords should not be stored directly in code
    but loaded from secure locations such as a Key Management System (KMS).

    The purpose of using a Key Management System is so access can be audited and keys easily
    rotated
    in the event of a breach. By hardcoding passwords, it will be extremely difficult to determine
    when or if, a key is compromised.

    The recommendation on which KMS to use depends on the environment the application is running
    in:

    - For Google Cloud Platform consider [Cloud Key Management](https://cloud.google.com/kms/docs)
    - For Amazon Web Services consider [AWS Key Management](https://aws.amazon.com/kms/)
    - For on premise or other alternatives to cloud providers, consider [Hashicorp's
    Vault](https://www.vaultproject.io/)
    - For other cloud providers, please see their documentation
  severity: "ERROR"
  metadata:
    shortDescription: "Use of hard-coded password"
    category: "security"
    cwe: "CWE-259"
    technology:
    - "java"
    primary_identifier: "find_sec_bugs.HARD_CODE_PASSWORD-1"
    secondary_identifiers:
    - name: "Find Security Bugs-HARD_CODE_PASSWORD"
      type: "find_sec_bugs_type"
      value: "HARD_CODE_PASSWORD"
- id: "find_sec_bugs.DANGEROUS_PERMISSION_COMBINATION-1"
  pattern-either:
  - pattern: |
      $RUNVAR = new RuntimePermission("createClassLoader");
      ...
      (PermissionCollection $PC).add($RUNVAR);
  - pattern: |
      $REFVAR = new ReflectPermission("suppressAccessChecks");
      ...
      (PermissionCollection $PC).add($REFVAR);
  - pattern: "(PermissionCollection $PC).add(new ReflectPermission(\"suppressAccessChecks\"))"
  - pattern: "(PermissionCollection $PC).add(new RuntimePermission(\"createClassLoader\"))"
  languages:
  - "java"
  message: |
    The application was found to permit the `RuntimePermission` of `createClassLoader`,
    `ReflectPermission` of `suppressAccessChecks`, or both.

    By granting the `RuntimePermission` of `createClassLoader`, a compromised application
    could instantiate their own class loaders and load arbitrary classes.

    By granting the `ReflectPermission` of `suppressAccessChecks` an application will no longer
    check Java language access checks on fields and methods of a class. This will effectively
    grant access to protected and private members.

    For more information on `RuntimePermission` see:
    https://docs.oracle.com/javase/8/docs/api/java/lang/RuntimePermission.html

    For more information on `ReflectPermission` see:
    https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/ReflectPermission.html
  metadata:
    shortDescription: "Improper privilege management"
    category: "security"
    cwe: "CWE-269"
    confidence: "HIGH"
    primary_identifier: "find_sec_bugs.DANGEROUS_PERMISSION_COMBINATION-1"
    secondary_identifiers:
    - name: "Find Security Bugs-DANGEROUS_PERMISSION_COMBINATION"
      type: "find_sec_bugs_type"
      value: "DANGEROUS_PERMISSION_COMBINATION"
  severity: "WARNING"
- id: "find_sec_bugs.OVERLY_PERMISSIVE_FILE_PERMISSION-1"
  languages:
  - "java"
  patterns:
  - pattern-either:
    - pattern: "java.nio.file.Files.setPosixFilePermissions(..., java.nio.file.attribute.PosixFilePermissions.fromString(\"$PERM_STRING\"));"
    - pattern: |
        $PERMISSIONS = java.nio.file.attribute.PosixFilePermissions.fromString("$PERM_STRING");
        ...
        java.nio.file.Files.setPosixFilePermissions(..., $PERMISSIONS);
  - metavariable-regex:
      metavariable: "$PERM_STRING"
      regex: "[rwx-]{6}[rwx]{1,}"
  message: |
    The application was found setting file permissions to overly permissive values. Consider
    using the following values if the application user is the only process to access
    the file:

    - `r--` - read only access to the file
    - `w--` - write only access to the file
    - `rw-` - read/write access to the file

    Example setting read/write permissions for only the owner of a `Path`:
    ```
    // Get a reference to the path
    Path path = Paths.get("/tmp/somefile");
    // Create a PosixFilePermission set from java.nio.file.attribute
    Set<PosixFilePermission> permissions =
    java.nio.file.attribute.PosixFilePermissions.fromString("rw-------");
    // Set the permissions
    java.nio.file.Files.setPosixFilePermissions(path, permissions);
    ```

    For all other values please see:
    https://en.wikipedia.org/wiki/File-system_permissions#Symbolic_notation
  metadata:
    shortDescription: "Incorrect permission assignment for critical resource"
    cwe: "CWE-732"
    owasp: "A6:2017-Security Misconfiguration"
    category: "security"
    confidence: "HIGH"
    primary_identifier: "find_sec_bugs.OVERLY_PERMISSIVE_FILE_PERMISSION-1"
    secondary_identifiers:
    - name: "Find Security Bugs-OVERLY_PERMISSIVE_FILE_PERMISSION"
      type: "find_sec_bugs_type"
      value: "OVERLY_PERMISSIVE_FILE_PERMISSION"
  severity: "WARNING"
- id: "find_sec_bugs.OVERLY_PERMISSIVE_FILE_PERMISSION-2"
  languages:
  - "java"
  message: |
    Overly permissive file permission
  metadata:
    category: "security"
    confidence: "HIGH"
    cwe: "CWE-732"
    shortDescription: "Incorrect Permission Assignment for Critical Resource"
    primary_identifier: "find_sec_bugs.OVERLY_PERMISSIVE_FILE_PERMISSION-2"
    secondary_identifiers:
    - name: "Find Security Bugs-OVERLY_PERMISSIVE_FILE_PERMISSION"
      type: "find_sec_bugs_type"
      value: "OVERLY_PERMISSIVE_FILE_PERMISSION"
  patterns:
  - pattern-inside: |
      $PERMS.add($P);
      ...
      java.nio.file.Files.setPosixFilePermissions(..., $PERMS);
  - metavariable-regex:
      metavariable: "$P"
      regex: "(PosixFilePermission.){0,1}(OTHERS_)"
  severity: "WARNING"
- id: "find_sec_bugs.PREDICTABLE_RANDOM-1"
  languages:
  - "java"
  patterns:
  - pattern-either:
    - pattern: |
        java.util.Random $R = new java.util.Random();
        ...
        $R.$METHOD();
    - pattern: "(java.util.Random $R).$METHOD()"
    - pattern: "new java.util.Random().$METHOD()"
    - pattern: "org.apache.commons.lang.math.RandomUtils.$METHOD()"
    - pattern: "org.apache.commons.lang.RandomStringUtils.$METHOD(...)"
  - metavariable-regex:
      metavariable: "$METHOD"
      regex: "^(next|random)"
  message: |
    Depending on the context, generating weak random numbers may expose cryptographic functions
    which rely on these numbers, to be exploitable. When generating numbers for sensitive values
    such as tokens, nonces, and cryptographic keys, it is recommended that the `DRBG` instance
    of `SecureRandom` be used.

    Example using `DRBG` with `SecureRandom`:
    ```
    public SecureRandom getSecureRandomDRBG() throws NoSuchAlgorithmException {
    // Use DRBG according to
    http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-90Ar1.pdf
        return SecureRandom.getInstance("DRBG",
                // Security strength in bits (default is 128)
                DrbgParameters.instantiation(256,
                    // Set prediction resistance and re-seeding
                    DrbgParameters.Capability.PR_AND_RESEED,
                    // Set the personalization string (optional, not necessary)
                    "some_personalization_string".getBytes()
                )
        );
    }
    ```

    For more information on Java Cryptography see:
    https://docs.oracle.com/en/java/javase/15/security/java-cryptography-architecture-jca-reference-guide.html
  severity: "WARNING"
  metadata:
    shortDescription: "Use of insufficiently random values"
    category: "security"
    cwe: "CWE-330"
    technology:
    - "java"
    primary_identifier: "find_sec_bugs.PREDICTABLE_RANDOM-1"
    secondary_identifiers:
    - name: "Find Security Bugs-PREDICTABLE_RANDOM"
      type: "find_sec_bugs_type"
      value: "PREDICTABLE_RANDOM"
- id: "find_sec_bugs.SCRIPT_ENGINE_INJECTION-1.SPEL_INJECTION-1.EL_INJECTION-2.SEAM_LOG_INJECTION-1"
  languages:
  - "java"
  patterns:
  - pattern: "(javax.script.ScriptEngine $ENGINE).eval($ARG);"
  - pattern-not: "(javax.script.ScriptEngine $ENGINE).eval(\"...\");"
  message: |
    The application executes an argument using a `ScriptEngine`'s `eval` method. This
    may allow for direct OS commands to be executed as it's possible to pass in strings
    such as `java.lang.Runtime.getRuntime().exec('/bin/sh ...');`.

    Never pass user-supplied input directly to the `eval` function. If possible hardcode all
    JavasScript code or use a lookup table to resolve user input to known values. If none of these
    techniques are possible, use `javax.script.Bindings` to pass input to the script engine.

    Example using `Binding` to safely pass in string values:
    ```
    // Get ECMAScript engine
    ScriptEngine engine = new ScriptEngineManager().getEngineByName("ECMAScript");

    // User input, consisting of first and last name
    String userFirstName = "John";
    String userLastName = "Snow";

    // Create bindings to pass into our script, forcing the values to be String.
    Bindings bindings = engine.createBindings();
    bindings.put("fname", new String(userFirstName));
    bindings.put("lname", new String(userLastName));

    // Example script that concatenates a greeting with the user-supplied input first/last name
    String script = "var greeting='Hello ';" +
    // fname and lname variables will be resolved by our bindings defined above
    "greeting += fname + ' ' + lname;" +
    // prints greeting
    "greeting";

    try {
      // Execute the script, passing in the bindings
      Object bindingsResult = engine.eval(script, bindings);
      // Work with result
      // ...
    } catch (ScriptException e) {
      // Handle exception
      e.printStackTrace();
    }
    ```
  severity: "ERROR"
  metadata:
    shortDescription: "Improper control of generation of code ('Code Injection')"
    category: "security"
    cwe: "CWE-94"
    primary_identifier: "find_sec_bugs.SCRIPT_ENGINE_INJECTION-1.SPEL_INJECTION-1.EL_INJECTION-2.SEAM_LOG_INJECTION-1"
    secondary_identifiers:
    - name: "Find Security Bugs-SCRIPT_ENGINE_INJECTION"
      type: "find_sec_bugs_type"
      value: "SCRIPT_ENGINE_INJECTION"
    - name: "Find Security Bugs-SPEL_INJECTION"
      type: "find_sec_bugs_type"
      value: "SPEL_INJECTION"
    - name: "Find Security Bugs-EL_INJECTION"
      type: "find_sec_bugs_type"
      value: "EL_INJECTION"
    - name: "Find Security Bugs-SEAM_LOG_INJECTION"
      type: "find_sec_bugs_type"
      value: "SEAM_LOG_INJECTION"
- id: "find_sec_bugs.SCRIPT_ENGINE_INJECTION-2"
  languages:
  - "java"
  patterns:
  - pattern: "($PARSER $P).parseExpression($ARG);"
  - pattern-not: "($PARSER $P).parseExpression(\"...\");"
  - metavariable-pattern:
      metavariable: "$PARSER"
      pattern-either:
      - pattern: "org.springframework.expression.spel.standard.SpelExpressionParser"
      - pattern: "org.springframework.expression.ExpressionParser"
  message: |
    The application was found calling SpringFramework's `SpelExpressionParser.parseExpression`.
    Calling this method directly with user-supplied input may allow an adversary to
    execute arbitrary Java code including OS system commands.

    Never call `parseExpression` or `parseRaw` directly with user-supplied input. Consider
    alternate
    methods such as a lookup table to take user input and resolve hardcoded values.

    Later versions of SpringFramework introduced a `SimpleEvaluationContext` which can be
    used to access bound data when calling the `getValue` result of `parseExpression`. This
    `SimpleEvaluationContext` has a reduced set of functionality and can restrict data binding
    to read-only or read-write contexts. An adversary could still access public properties
    or fields on custom types that have been provided to the evaluation context. Use with caution.

    Example using `SimpleEvaluationContext` with a read-write data binding context:
    ```
    @RequestMapping(value="/spel", method=RequestMethod.POST)
    public String spel(@Validated User user, Model model)  {
      // Create the Expression Parser
      SpelExpressionParser parser = new SpelExpressionParser();
      // Parse the expression
      Expression parsedExpression = parser.parseExpression(model.getPossiblyUnsafeData());
      // Create the read-write data binding context
      SimpleEvaluationContext context = SimpleEvaluationContext.forReadWriteDataBinding().build();
      // Execute the expression, passing in the read-write context
      Object result = parsedExpression.getValue(context);
      // work with the result
      // ...
      return "user";
    }
    ```

    For more information on SimpleEvaluationContext see:
    https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/expression/spel/support/SimpleEvaluationContext.html
  severity: "ERROR"
  metadata:
    shortDescription: "Improper neutralization of special elements used in an expression
      language statement ('Expression Language Injection')"
    category: "security"
    cwe: "CWE-917"
    primary_identifier: "find_sec_bugs.SCRIPT_ENGINE_INJECTION-2"
    secondary_identifiers:
    - name: "Find Security Bugs-SCRIPT_ENGINE_INJECTION"
      type: "find_sec_bugs_type"
      value: "SCRIPT_ENGINE_INJECTION"
- id: "find_sec_bugs.INSECURE_SMTP_SSL-1"
  languages:
  - "java"
  patterns:
  - pattern-either:
    - pattern-inside: |
        $E = new org.apache.commons.mail.SimpleEmail(...);
        ...
    - pattern-inside: |
        $E = new org.apache.commons.mail.Email(...);
        ...
    - pattern-inside: |
        $E = new org.apache.commons.mail.MultiPartEmail(...);
        ...
    - pattern-inside: |
        $E = new org.apache.commons.mail.HtmlEmail(...);
        ...
    - pattern-inside: |
        $E = new org.apache.commons.mail.ImageHtmlEmail(...);
        ...
  - pattern-not: |
      $E.setSSLOnConnect(true);
      ...
      $E.setSSLCheckServerIdentity(true);
  message: |
    The Apache commons mail client by default does not enable TLS server identity.
    This allows for an adversary who is in between the application and the target host to intercept
    potentially sensitive information or transmit malicious data.

    Enable checking server identity by calling `Email.setSSLCheckServerIdentity(true)`

    Example email client that enables TLS and server identity:
    ```
    // Create an email client
    Email email = new SimpleEmail();
    // Configure the email hostname
    email.setHostName("smtp.mail.example.com");
    // Set the port
    email.setSmtpPort(465);
    // Securely retrieve username and password values
    String username = getUserNameFromKMSorSecretStore();
    String password = getPasswordFromKMSorSecretStore();
    // Configure the Authenticator
    DefaultAuthenticator auth = new DefaultAuthenticator(username, password);
    // Set the authenticator
    email.setAuthenticator(auth);
    // Ensure we use SSL on connect
    email.setSSLOnConnect(true);
    // Ensure we validate server identity
    email.setSSLCheckServerIdentity(true);
    // configure the rest of the email
    email.setFrom("x@example.com");
    email.setSubject("TestMail");
    email.setMsg("This is a test mail ... :-)");
    email.addTo("y@example.com");
    email.send();
    ```
  metadata:
    shortDescription: "Improper validation of certificate with host mismatch"
    category: "security"
    cwe: "CWE-297"
    primary_identifier: "find_sec_bugs.INSECURE_SMTP_SSL-1"
    secondary_identifiers:
    - name: "Find Security Bugs-INSECURE_SMTP_SSL"
      type: "find_sec_bugs_type"
      value: "INSECURE_SMTP_SSL"
  severity: "ERROR"
- id: "find_sec_bugs.SMTP_HEADER_INJECTION-1"
  languages:
  - "java"
  message: |
    The application was found calling `MimeMessage` methods without encoding
    new line characters. Much like HTTP, Simple Mail Transfer Protocol (SMTP) is a
    text based protocol that uses headers to convey additional directives for how
    email messages should be treated. An adversary could potentially cause email
    messages to be sent to unintended recipients by abusing the CC or BCC headers
    if they were able to inject them.

    To mitigate this issue, `\r\n` (CRLF) character sequences must be escaped
    or encoded prior to being used in any of the `MimeMessage` methods.

    Example that escapes values that come from user input with
    [Apache Commons Text](https://commons.apache.org/proper/commons-text/):
    ```
    // Create a MimeMessage with a javax.mail.Session
    Message message = new MimeMessage(session);
    // Set the from address
    message.setFrom(new InternetAddress("source@example.com"));
    // Set the to address
    message.setRecipients(Message.RecipientType.TO,new InternetAddress[] {new
    InternetAddress("destination@example.com")});
    // Example user input
    String subject = "potentially malicious data";
    String headerValue = "potentially malicious data";
    // Use Apache Commons Text StringEscapeUtils.escapeJava to encode \r\n to \\r\\n.
    message.setSubject(StringEscapeUtils.escapeJava(subject));
    // Use Apache Commons Text StringEscapeUtils.escapeJava to encode \r\n to \\r\\n.
    message.addHeader("HeaderName", StringEscapeUtils.escapeJava(header));
    // Use Apache Commons Text StringEscapeUtils.escapeJava to encode \r\n to \\r\\n.
    message.setDescription(StringEscapeUtils.escapeJava("some description"));
    // Use Apache Commons Text StringEscapeUtils.escapeJava to encode \r\n to \\r\\n.
    message.setDisposition(StringEscapeUtils.escapeJava("some disposition"));
    // Set the mail body text
    message.setText("Some email content.");
    // Send the message
    ```
  metadata:
    shortDescription: "Improper neutralization of special elements used in a command"
    category: "security"
    cwe: "CWE-77"
    primary_identifier: "find_sec_bugs.SMTP_HEADER_INJECTION-1"
    secondary_identifiers:
    - name: "Find Security Bugs-SMTP_HEADER_INJECTION"
      type: "find_sec_bugs_type"
      value: "SMTP_HEADER_INJECTION"
  patterns:
  - pattern-either:
    - patterns:
      - pattern-inside: |
          $M = new MimeMessage(...);
          ...
      - pattern: "$M.setSubject($ARG);"
      - pattern-not: "$M.setSubject(\"...\")"
    - patterns:
      - pattern-inside: |
          $M = new MimeMessage(...);
          ...
      - pattern: "$M.addHeader($ARG1, $ARG2)"
      - pattern-not: "$M.addHeader(\"...\", \"...\")"
    - patterns:
      - pattern-inside: |
          $M = new MimeMessage(...);
          ...
      - pattern: "$M.setDescription($ARG)"
      - pattern-not: "$M.setDescription(\"...\")"
    - patterns:
      - pattern-inside: |
          $M = new MimeMessage(...);
          ...
      - pattern: "$M.setDisposition($ARG)"
      - pattern-not: "$M.setDisposition(\"...\")"
  severity: "ERROR"
- id: "find_sec_bugs.URLCONNECTION_SSRF_FD-1"
  languages:
  - "java"
  message: |
    Server-Side-Request-Forgery (SSRF) exploits backend systems that initiate requests to third
    parties.
    If user input is used in constructing or sending these requests, an attacker could supply
    malicious
    data to force the request to other systems or modify request data to cause unwanted actions.

    Ensure user input is not used directly in constructing URLs or URIs when initiating requests
    to third party
    systems from back end systems. Care must also be taken when constructing payloads using user
    input. Where
    possible restrict to known URIs or payloads. Consider using a server-side map where keys are
    used to return
    URLs such as `https://site/goto?key=1` where `{key: 1, url: 'http://some.url/', key: 2, url:
    'http://...'}`.

    If you must use user-supplied input for requesting URLs, it is strongly recommended that the
    HTTP client
    chosen allows you to customize and block certain IP ranges at the network level. By blocking
    RFC 1918
    addresses or other network address ranges, you can limit the severity of a successful SSRF
    attack. Care must
    also be taken to block certain protocol or address formatting such as IPv6.

    If you cannot block address ranges at the client level, you may want to run the HTTP client
    as a protected
    user, or in a protected network where you can apply IP Table or firewall rules to block access
    to dangerous
    addresses. Finally, if none of the above protections are available, you could also run a
    custom HTTP proxy
    and force all requests through it to handle blocking dangerous addresses.

    Example using a map to look up a key to be used in a HTTP request:
    ```
    HashMap<String, String> lookupTable = new HashMap<>();
    lookupTable.put("key1", "https://example.com/");
    lookupTable.put("key2", "https://safeurl.com/");
    String userInput = request.getParameter("key");

    // Create a CloseableHttpClient, ideally any requests issued should be done
    // out-of-band from the servlet request itself (such as using a separate thread/scheduler
    system)
    try (final CloseableHttpClient httpClient = HttpClients.createDefault()) {
        // Lookup the value from our user input from our lookupTable
        String value = lookupTable.getOrDefault(userInput, "https://example.com/");
        // Construct the url, with the hardcoded url and only pass in the value from the
    lookupTable,
        // not direct user input
        final HttpGet httpget = new HttpGet(value);
        // Execute the request
        CloseableHttpResponse clientResponse = httpClient.execute(httpget);
        // Read the response
        byte[] responseData = clientResponse.getEntity().getContent().readAllBytes();
        // Handle the response
        // ...
    }
    ```

    If using a map is not possible, the user-supplied input must be encoded prior to use, and
    never allow full
    URLs:
    ```
    // Get user input
    String userInput = request.getParameter("key");
    // Encode the string using java.net.URLEncoder with the UTF-8 character set
    String encodedString = java.net.URLEncoder.encode(userInput, StandardCharsets.UTF_8);
    // Create a CloseableHttpClient, ideally any requests issued should be done
    // out-of-band from the servlet request itself (such as using a separate thread/scheduler
    system)
    try (final CloseableHttpClient httpClient = HttpClients.createDefault()) {
      // Construct the url, with the hardcoded url and only pass in the encoded value, never a
    full URL
      final HttpGet httpget = new HttpGet("https://example.com/getId?key="+encodedString);
      // Execute the request
      CloseableHttpResponse clientResponse = httpClient.execute(httpget);
      // Read the response
      byte[] responseData = clientResponse.getEntity().getContent().readAllBytes();
      // handle the response
    }
    ```

    For more information on SSRF see OWASP:
    https://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html
  metadata:
    shortDescription: "Server-Side Request Forgery (SSRF)"
    category: "security"
    cwe: "CWE-918"
    primary_identifier: "find_sec_bugs.URLCONNECTION_SSRF_FD-1"
    secondary_identifiers:
    - name: "Find Security Bugs-URLCONNECTION_SSRF_FD"
      type: "find_sec_bugs_type"
      value: "URLCONNECTION_SSRF_FD"
  pattern-either:
  - patterns:
    - pattern-either:
      - pattern-inside: |
          import java.net.*
          ...
      - pattern-inside: |
          import java.net.URL
          ...
      - pattern-inside: |
          import java.net.URI
          ...
    - pattern: "new $TYPE(...). ... .$FUNC"
    - pattern-not: "new $TYPE(\"...\"). ... .$FUNC"
    - metavariable-pattern:
        metavariable: "$FUNC"
        pattern-either:
        - pattern: "connect"
        - pattern: "GetContent"
        - pattern: "openConnection"
        - pattern: "openStream"
        - pattern: "getContent"
    - metavariable-pattern:
        metavariable: "$TYPE"
        pattern-either:
        - pattern: "URL"
        - pattern: "java.net.URL"
        - pattern: "URI"
        - pattern: "java.net.URI"
  - patterns:
    - pattern-either:
      - pattern-inside: |
          import java.net.*;
          ...
      - pattern-inside: |
          import java.net.InetSocketAddress;
          ...
    - pattern: |
        new InetSocketAddress(..., $PORT)
    - pattern-not: |
        new InetSocketAddress("...", $PORT)
  severity: "ERROR"
- id: "find_sec_bugs.BAD_HEXA_CONVERSION-1"
  languages:
  - "java"
  message: |
    The application is using `Integer.toHexString` on a digest array buffer which
    may lead to an incorrect version of values.

    Consider using the `HexFormat` object introduced in Java 17. For older Java applications
    consider using the `javax.xml.bind.DatatypeConverter`.

    Example using `HexFormat` to create a human-readable string:
    ```
    // Create a MessageDigest using the SHA-384 algorithm
    MessageDigest sha384Digest = MessageDigest.getInstance("SHA-384");
    // Call update with your data
    sha384Digest.update("some input".getBytes(StandardCharsets.UTF_8));
    // Only call digest once all data has been fed into the update sha384digest instance
    byte[] output = sha384Digest.digest();
    // Create a JDK 17 HexFormat object
    HexFormat hex = HexFormat.of();
    // Use formatHex on the byte array to create a string (note that alphabet characters are
    lowercase)
    String hexString = hex.formatHex(output);
    ```

    For more information on DatatypeConverter see:
    https://docs.oracle.com/javase/9/docs/api/javax/xml/bind/DatatypeConverter.html#printHexBinary-byte:A-
  metadata:
    shortDescription: "Incorrect type conversion or cast"
    cwe: "CWE-704"
    category: "security"
    confidence: "HIGH"
    primary_identifier: "find_sec_bugs.BAD_HEXA_CONVERSION-1"
    secondary_identifiers:
    - name: "Find Security Bugs-BAD_HEXA_CONVERSION"
      type: "find_sec_bugs_type"
      value: "BAD_HEXA_CONVERSION"
  patterns:
  - pattern: |
      $B_ARR = (java.security.MessageDigest $MD).digest(...);
      ...
      for(...) {
        ...
        Integer.toHexString(...);
      }
  severity: "WARNING"
- id: "find_sec_bugs.FORMAT_STRING_MANIPULATION-1"
  languages:
  - "java"
  patterns:
  - pattern-either:
    - patterns:
      - pattern-inside: |
          String $INPUT = (HttpServletRequest $REQ).getParameter(...);
          ...
      - pattern-inside: |
          String $FORMAT_STR = ... + $INPUT;
          ...
    - patterns:
      - pattern-inside: |
          String $INPUT = (HttpServletRequest $REQ).getParameter(...);
          ...
      - pattern-inside: |
          String $FORMAT_STR = ... + $INPUT + ...;
          ...
    - pattern-inside: |
        String $FORMAT_STR = ... + (HttpServletRequest $REQ).getParameter(...) + ...;
        ...
    - pattern-inside: |
        String $FORMAT_STR = ... + (HttpServletRequest $REQ).getParameter(...);
        ...
  - pattern-either:
    - pattern: "String.format($FORMAT_STR, ...);"
    - pattern: "String.format(java.util.Locale.$LOCALE, $FORMAT_STR, ...);"
    - pattern: "(java.util.Formatter $F).format($FORMAT_STR, ...);"
    - pattern: "(java.util.Formatter $F).format(java.util.Locale.$LOCALE, $FORMAT_STR,
        ...);"
    - pattern: "(java.io.PrintStream $F).printf($FORMAT_STR, ...);"
    - pattern: "(java.io.PrintStream $F).printf(java.util.Locale.$LOCALE, $FORMAT_STR,
        ...);"
    - pattern: "(java.io.PrintStream $F).format($FORMAT_STR, ...);"
    - pattern: "(java.io.PrintStream $F).format(java.util.Locale.$LOCALE, $FORMAT_STR,
        ...);"
    - pattern: "System.out.printf($FORMAT_STR, ...);"
    - pattern: "System.out.printf(java.util.Locale.$LOCALE, $FORMAT_STR, ...);"
    - pattern: "System.out.format($FORMAT_STR, ...);"
    - pattern: "System.out.format(java.util.Locale.$LOCALE, $FORMAT_STR, ...);"
  message: |
    The application allows user input to control format string parameters. By passing invalid
    format
    string specifiers an adversary could cause the application to throw exceptions or possibly
    leak
    internal information depending on application logic.

    Never allow user-supplied input to be used to create a format string. Replace all format
    string
    arguments with hardcoded format strings containing the necessary specifiers.

    Example of using `String.format` safely:
    ```
    // Get untrusted user input
    String userInput = request.getParameter("someInput");
    // Ensure that user input is not included in the first argument to String.format
    String.format("Hardcoded string expecting a string: %s", userInput);
    // ...
    ```
  metadata:
    shortDescription: "Use of externally-controlled format string"
    cwe: "CWE-134"
    category: "security"
    confidence: "HIGH"
    primary_identifier: "find_sec_bugs.FORMAT_STRING_MANIPULATION-1"
    secondary_identifiers:
    - name: "Find Security Bugs-FORMAT_STRING_MANIPULATION"
      type: "find_sec_bugs_type"
      value: "FORMAT_STRING_MANIPULATION"
  severity: "ERROR"
- id: "find_sec_bugs.IMPROPER_UNICODE-1"
  languages:
  - "java"
  message: |
    Improper Handling of Unicode Encoding
  metadata:
    category: "security"
    confidence: "HIGH"
    cwe: "CWE-176"
    shortDescription: "Improper Handling of Unicode Encoding"
    primary_identifier: "find_sec_bugs.IMPROPER_UNICODE-1"
    secondary_identifiers:
    - name: "Find Security Bugs-IMPROPER_UNICODE"
      type: "find_sec_bugs_type"
      value: "IMPROPER_UNICODE"
  pattern-either:
  - patterns:
    - pattern-either:
      - pattern: |
          $S = (String $INPUT).$TRANSFORM(...);
          ...
          $S.$METHOD(...);
      - pattern: "(String $INPUT).$TRANSFORM().$METHOD(...);"
    - metavariable-regex:
        metavariable: "$METHOD"
        regex: "(equals|equalsIgnoreCase|indexOf)"
    - metavariable-regex:
        metavariable: "$TRANSFORM"
        regex: "(toLowerCase|toUpperCase)"
  - pattern: "java.text.Normalizer.normalize(...);"
  - pattern: "java.net.IDN.toASCII(...);"
  - pattern: "(URI $U).toASCIIString();"
  severity: "ERROR"
- id: "find_sec_bugs.MODIFICATION_AFTER_VALIDATION-1"
  languages:
  - "java"
  patterns:
  - pattern: |
      (java.util.regex.Pattern $Y).matcher($VAR);
      ...
      $VAR.$METHOD(...);
  - metavariable-regex:
      metavariable: "$METHOD"
      regex: "(replace)"
  message: |+
    The application was found matching a variable during a regular expression
    pattern match, and then calling string modification functions after validation has occurred.
    This is usually indicative of a poor input validation strategy as an adversary may attempt to
    exploit the removal of characters.

    For example a common mistake in attempting to remove path characters to protect against path
    traversal is to match '../' and then remove any matches. However, if an adversary were to
    include in their input: '....//' then the `replace`  method would replace the first `../` but
    cause the leading `..` and trailing `/` to join into the final string of `../`, effectively
    bypassing the check.

    To remediate this issue always perform string modifications before any validation of a string.
    It is strongly recommended that strings be encoded instead of replaced or removed prior to
    validation.


    Example replaces `..` before validation. Do note this is still not a recommended method for
    protecting against directory traversal, always use randomly generated IDs or filenames instead:
    ```
    // This is ONLY for demonstration purpose, never use untrusted input
    // in paths, always use randomly generated filenames or IDs.
    String input = "test../....//dir";
    // Use replaceAll _not_ replace
    input = input.replaceAll("\\.\\.", "");
    // Input would be test///dir at this point
    // Create a pattern to match on
    Pattern pattern = Pattern.compile("\\.\\.");
    // Create a matcher
    Matcher match = pattern.matcher(input);
    // Call find to see if .. is still in our string
    if (match.find()) {
        throw new Exception(".. detected");
    }
    // Use the input (but do not modify the string)
    System.out.println(input + " safe");
    ```

    For more information see Carnegie Mellon University's Secure Coding Guide:
    https://wiki.sei.cmu.edu/confluence/display/java/IDS11-J.+Perform+any+string+modifications+before+validation

  metadata:
    shortDescription: "Collapse of data into unsafe value"
    category: "security"
    cwe: "CWE-182"
    confidence: "HIGH"
    primary_identifier: "find_sec_bugs.MODIFICATION_AFTER_VALIDATION-1"
    secondary_identifiers:
    - name: "Find Security Bugs-MODIFICATION_AFTER_VALIDATION"
      type: "find_sec_bugs_type"
      value: "MODIFICATION_AFTER_VALIDATION"
  severity: "WARNING"
- id: "find_sec_bugs.NORMALIZATION_AFTER_VALIDATION-1"
  patterns:
  - pattern: |
      $Y = java.util.regex.Pattern.compile("[<>]");
      ...
      $Y.matcher($VAR);
      ...
      java.text.Normalizer.normalize($VAR, ...);
  languages:
  - "java"
  message: |
    The application was found matching a variable during a regular expression
    pattern match, and then calling a Unicode normalize function after validation has occurred.
    This is usually indicative of a poor input validation strategy as an adversary may attempt to
    exploit the normalization process.

    To remediate this issue, always perform Unicode normalization before any validation of a
    string.

    Example of normalizing a string before validation:
    ```
    // User input possibly containing malicious unicode
    String userInput = "\uFE64" + "tag" + "\uFE65";
    // Normalize the input
    userInput = Normalizer.normalize(userInput, Normalizer.Form.NFKC);
    // Compile our regex pattern looking for < or > charcters
    Pattern pattern = Pattern.compile("[<>]");
    // Create a matcher from the userInput
    Matcher matcher = pattern.matcher(userInput);
    // See if the matcher matches
    if (matcher.find()) {
        // It did so throw an error
        throw new Exception("found banned characters in input");
    }
    ```

    For more information see Carnegie Mellon University's Secure Coding Guide:
    https://wiki.sei.cmu.edu/confluence/display/java/IDS01-J.+Normalize+strings+before+validating+them
  metadata:
    shortDescription: "Incorrect behavior order: validate before canonicalize"
    category: "security"
    cwe: "CWE-180"
    confidence: "HIGH"
    primary_identifier: "find_sec_bugs.NORMALIZATION_AFTER_VALIDATION-1"
    secondary_identifiers:
    - name: "Find Security Bugs-NORMALIZATION_AFTER_VALIDATION"
      type: "find_sec_bugs_type"
      value: "NORMALIZATION_AFTER_VALIDATION"
  severity: "WARNING"
- id: "find_sec_bugs.TEMPLATE_INJECTION_PEBBLE-1.TEMPLATE_INJECTION_FREEMARKER-1.TEMPLATE_INJECTION_VELOCITY-1"
  languages:
  - "java"
  message: |
    The application may allow control over a template string. Providing user input directly in the
    template by
    dynamically creating template strings may allow an adversary to execute arbitrary Java code,
    including
    OS system commands.

    For Velocity, never call `evaluate` with user-supplied input in the template string. Use a
    `VelocityContext`
    object instead to data-bind user-supplied information as it will be treated as an underlying
    data type and not
    template code.

    Example using Apache Velocity's `VelocityContext` and escape tools to pass in user-supplied
    data to a template:
    ```
    // Create a tool manager
    ToolManager manager = new ToolManager(true);
    // Create a context from the tool manager
    Context context = manager.createContext();
    // For demonstration purposes, alternatively configure from a properties file
    context.put("esc", new EscapeTool());
    // For demonstration purposes, create an output buffer
    StringWriter stringWriter = new StringWriter();
    // Get userInput
    String userInput = "potentially malicious data";
    // Use the context to pass in the userInput value
    context.put("userInput", userInput);
    // Pass in the context, the output buffer, a logtag (demo), and the template with userInput
    // making sure to escape it if in the context of HTML.
    Velocity.evaluate(context, stringWriter, "demo", "Hello $esc.html($userInput)");
    // Work with the output buffer
    // ...
    ```

    For other templating engines, please see your framework's documentation.
  metadata:
    shortDescription: "Improper control of generation of code ('Code Injection')"
    category: "security"
    cwe: "CWE-94"
    primary_identifier: "find_sec_bugs.TEMPLATE_INJECTION_PEBBLE-1.TEMPLATE_INJECTION_FREEMARKER-1.TEMPLATE_INJECTION_VELOCITY-1"
    secondary_identifiers:
    - name: "Find Security Bugs-TEMPLATE_INJECTION_PEBBLE"
      type: "find_sec_bugs_type"
      value: "TEMPLATE_INJECTION_PEBBLE"
    - name: "Find Security Bugs-TEMPLATE_INJECTION_FREEMARKER"
      type: "find_sec_bugs_type"
      value: "TEMPLATE_INJECTION_FREEMARKER"
    - name: "Find Security Bugs-TEMPLATE_INJECTION_VELOCITY"
      type: "find_sec_bugs_type"
      value: "TEMPLATE_INJECTION_VELOCITY"
  pattern-either:
  - patterns:
    - pattern: "org.apache.velocity.app.Velocity.evaluate(..., $VAR)"
    - pattern-not: "org.apache.velocity.app.Velocity.evaluate(..., \"...\")"
  - patterns:
    - pattern-not-inside: |
        $C = (freemarker.template.Configuration $CFG).getTemplate("...");
        ...
    - pattern-inside: |
        $C = (freemarker.template.Configuration $CFG).getTemplate($IN);
        ...
    - pattern: "$C.process(...)"
  - patterns:
    - pattern-inside: |
        import com.mitchellbosecke.pebble.PebbleEngine;
        ...
    - pattern-inside: |
        $C = $T.getTemplate($IN);
        ...
    - pattern-not-inside: |
        $C = $T.getTemplate("...");
        ...
    - pattern: "$C.evaluate(...)"
  severity: "ERROR"
- id: "find_sec_bugs.EXTERNAL_CONFIG_CONTROL-1"
  languages:
  - "java"
  patterns:
  - pattern: |
      $TAINTED = (HttpServletRequest $REQ).getParameter(...);
      ...
      (java.sql.Connection $CONN).setCatalog($TAINTED);
  message: |
    The application was found using user-supplied input in a `java.sql.Connection`'s
    `setCatalog` call. This could allow an adversary to supply a different database for the
    lifetime of the connection. Allowing external control of system settings can disrupt service
    or cause an application to behave in unexpected, and potentially malicious ways. Most likely
    this would only cause an error by providing a nonexistent catalog name.

    It is recommended to not use user-supplied input when selecting the database for an
    applications
    database connection.
  severity: "WARNING"
  metadata:
    shortDescription: "External control of system or configuration setting"
    category: "security"
    cwe: "CWE-15"
    technology:
    - "java"
    primary_identifier: "find_sec_bugs.EXTERNAL_CONFIG_CONTROL-1"
    secondary_identifiers:
    - name: "Find Security Bugs-EXTERNAL_CONFIG_CONTROL"
      type: "find_sec_bugs_type"
      value: "EXTERNAL_CONFIG_CONTROL"
- id: "find_sec_bugs.INFORMATION_EXPOSURE_THROUGH_AN_ERROR_MESSAGE-1"
  languages:
  - "java"
  pattern-either:
  - pattern: |
      catch(Throwable $E) {
        ...
        $E.printStackTrace();
        ...
      }
  - pattern: |
      catch(Exception $E) {
        ...
        $E.printStackTrace();
        ...
      }
  - pattern: |
      catch(Error $E) {
        ...
        $E.printStackTrace();
        ...
      }
  - pattern: |
      catch(java.io.FileNotFoundException $E) {
        ...
        $E.printStackTrace();
        ...
      }
  - pattern: |
      catch(java.sql.SQLException $E) {
        ...
        $E.printStackTrace();
        ...
      }
  - pattern: |
      catch(java.net.BindException $E) {
        ...
        $E.printStackTrace();
        ...
      }
  - pattern: |
      catch(java.util.ConcurrentModificationException $E) {
        ...
        $E.printStackTrace();
        ...
      }
  - pattern: |
      catch(javax.naming.InsufficientResourcesException $E) {
        ...
        $E.printStackTrace();
        ...
      }
  - pattern: |
      catch(java.util.MissingResourceException $E) {
        ...
        $E.printStackTrace();
        ...
      }
  - pattern: |
      catch(java.util.jar.JarException $E) {
        ...
        $E.printStackTrace();
        ...
      }
  - pattern: |
      catch(java.security.acl.NotOwnerException $E) {
        ...
        $E.printStackTrace();
        ...
      }
  - pattern: |
      catch(OutOfMemoryError $E) {
        ...
        $E.printStackTrace();
        ...
      }
  - pattern: |
      catch(StackOverflowError $E) {
        ...
        $E.printStackTrace();
        ...
      }
  message: |
    The application was found printing stack information to the default system output.
    As stack trace data may contain sensitive information, it is recommended that the
    output be logged using a secure logging framework. Log files should also be protected
    with proper operating system permission levels.
  severity: "WARNING"
  metadata:
    shortDescription: "Information exposure through an error message"
    category: "security"
    cwe: "CWE-209"
    technology:
    - "java"
    primary_identifier: "find_sec_bugs.INFORMATION_EXPOSURE_THROUGH_AN_ERROR_MESSAGE-1"
    secondary_identifiers:
    - name: "Find Security Bugs-INFORMATION_EXPOSURE_THROUGH_AN_ERROR_MESSAGE"
      type: "find_sec_bugs_type"
      value: "INFORMATION_EXPOSURE_THROUGH_AN_ERROR_MESSAGE"
- id: "find_sec_bugs.RPC_ENABLED_EXTENSIONS-1"
  languages:
  - "java"
  message: |
    Enabling extensions in Apache XML RPC server or client can lead to deserialization
    vulnerability which would allow an attacker to execute arbitrary code.
  metadata:
    category: "security"
    cwe: "CWE-502"
    shortDescription: "Deserialization of Untrusted Data"
    primary_identifier: "find_sec_bugs.RPC_ENABLED_EXTENSIONS-1"
    secondary_identifiers:
    - name: "Find Security Bugs-RPC_ENABLED_EXTENSIONS"
      type: "find_sec_bugs_type"
      value: "RPC_ENABLED_EXTENSIONS"
  patterns:
  - pattern-either:
    - patterns:
      - pattern-inside: |
          XmlRpcServerConfigImpl $VAR = new org.apache.xmlrpc.server.XmlRpcServerConfigImpl();
          ...
      - pattern: "$VAR.setEnabledForExtensions(true);"
    - patterns:
      - pattern-inside: |
          XmlRpcClientConfigImpl $VAR = new org.apache.xmlrpc.client.XmlRpcClientConfigImpl();
          ...
      - pattern: "$VAR.setEnabledForExtensions(true);"
  severity: "WARNING"
- id: "find_sec_bugs.SAML_IGNORE_COMMENTS-1"
  languages:
  - "java"
  message: |
    SAML parses attestations as an XML document. By processing XML comments,
    comment fields can end up modifying the interpretation of input fields.
    This could allow an adversary to insert an XML comment to break up the attestation's
    username or other fields, allowing an attacker to bypass authorization or authentication
    checks.

    To remediate this issue, when using `org.opensaml.xml.parse.BasicParserPool` ensure
    `setIgnoreComments(true)` is called.

    For more information on how this issue can be exploited see:
    https://developer.okta.com/blog/2018/02/27/a-breakdown-of-the-new-saml-authentication-bypass-vulnerability

    For more information on SAML security see OWASP:
    https://cheatsheetseries.owasp.org/cheatsheets/SAML_Security_Cheat_Sheet.html
  metadata:
    shortDescription: "Improper authentication"
    cwe: "CWE-287"
    category: "security"
    primary_identifier: "find_sec_bugs.SAML_IGNORE_COMMENTS-1"
    secondary_identifiers:
    - name: "Find Security Bugs-SAML_IGNORE_COMMENTS"
      type: "find_sec_bugs_type"
      value: "SAML_IGNORE_COMMENTS"
  pattern: "(BasicParserPool $POOL).setIgnoreComments(false);"
  severity: "WARNING"
- id: "find_sec_bugs.XML_DECODER-1"
  languages:
  - "java"
  message: |
    Deserialization attacks exploit the process of reading serialized data and turning it back
    into an object. By constructing malicious objects and serializing them, an adversary may
    attempt to:

    - Inject code that is executed upon object construction, which occurs during the
    deserialization process.
    - Exploit mass assignment by including fields that are not normally a part of the serialized
    data but are read in during deserialization.

    Consider safer alternatives such as serializing data in the JSON format. Ensure any format
    chosen allows
    the application to specify exactly which object types are allowed to be deserialized.
    Additionally, when
    deserializing, never deserialize to base object types like `Object` and only cast to the exact
    object
    type that is expected.

    To protect against mass assignment, only allow deserialization of the specific fields that are
    required. If this is not easily done, consider creating an intermediary type that
    can be serialized with only the necessary fields exposed.

    Do note that `XMLEncoder` and `XMLDecoder` are not recommended. If the application must
    use this serialization method, use a custom ClassLoader to prevent loading of arbitrary
    classes:
    ```
    XMLDecoder decoder = new XMLDecoder(inputStream, null, null, new ClassLoader() {
        @Override
        protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {
            if (!name.equals(NameOfBeanHere.class.getName()) &&
    !name.equals(XMLDecoder.class.getName())) {
                throw new RuntimeException("Unauthorized deserialization attempt: " + name);
            }

            throw new ClassNotFoundException(name);
        }
    });
    ```

    For more information on XML security see OWASP's guide:
    https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html#java

    For more details on deserialization attacks in general, see OWASP's guide:
    https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html

    It should be noted that [tools exist](https://github.com/frohoff/ysoserial) to
    automatically create
    exploit code for these vulnerabilities.
  metadata:
    shortDescription: "Deserialization of untrusted data"
    category: "security"
    cwe: "CWE-502"
    primary_identifier: "find_sec_bugs.XML_DECODER-1"
    secondary_identifiers:
    - name: "Find Security Bugs-XML_DECODER"
      type: "find_sec_bugs_type"
      value: "XML_DECODER"
  patterns:
  - pattern-either:
    - patterns:
      - pattern-inside: |
          $D = new XMLDecoder($IN);
          ...
      - pattern-not-inside: |
          $D = new XMLDecoder("...");
          ...
      - pattern: "$D.readObject()"
  severity: "WARNING"
- id: "find_sec_bugs.MALICIOUS_XSLT-1"
  languages:
  - "java"
  mode: "taint"
  pattern-sources:
  - patterns:
    - pattern-either:
      - patterns:
        - pattern-inside: |
            $FUNC(...,String $VAR, ...) {
              ...
            }
        - pattern-either:
          - pattern: "new FileInputStream(<... $VAR ...>);"
          - pattern: "getClass().getResourceAsStream(<... $VAR ...>)"
      - patterns:
        - pattern-inside: |
            class $CLZ {
              String $X = "...";
              ...
            }
        - pattern-inside: |
            $FUNC(...,String $Y, ...) {
              ...
            }
        - pattern-either:
          - pattern: "new FileInputStream($X + $Y);"
          - pattern: "getClass().getResourceAsStream($X + $Y)"
  pattern-sinks:
  - patterns:
    - pattern-either:
      - pattern-inside: |-
          (javax.xml.transform.TransformerFactory $T).newTransformer($SRC, ...)
      - pattern-inside: |-
          (javax.xml.transform.Transformer $T).transform($SRC, ...)
    - pattern: "$SRC"
  message: |
    The application performs XSLT translation with potentially malicious input. An adversary who
    is able to influence the
    loaded
    XSL document could call XSL functions or exploit External XML Entity (XXE) attacks that allow
    file
    retrieval or force the parser to connect to arbitrary servers to exfiltrate files. It is
    strongly
    recommended that an alternative approach is used to work with XML data.

    For increased security, never process user-supplied XSL style sheets. If XSLT processing is
    absolutely
    necessary, ensure that `FEATURE_SECURE_PROCESSING` is enabled prior to processing the XSLT
    file:
    ```
    // Create a new TransformerFactory instance
    TransformerFactory transformerFactory = TransformerFactory.newInstance();
    // Enable the FEATURE_SECURE_PROCESSING feature
    transformerFactory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);
    // Read in the XML Source
    Source xmlSource = new StreamSource(new FileInputStream("hardcoded.xml"));
    // Read in the XSL template file
    Source xslSource = new StreamSource(new FileInputStream("hardcoded.xsl"));
    /// Create the transformer object to do the transformation
    Transformer transformer = transformerFactory.newTransformer(xslSource);
    // Create a Result object for output
    Result result = new StreamResult(System.out);
    // Execute the transformation process
    transformer.transform(xmlSource, result);
    ```

    For more information on XML security see OWASP's guide:
    https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html#java

    For more information on the secure processing feature see:
    - https://xml.apache.org/xalan-j/features.html#secureprocessing
  metadata:
    shortDescription: "Improper neutralization of special elements in output used
      by a downstream component ('Injection')"
    category: "security"
    cwe: "CWE-74"
    primary_identifier: "find_sec_bugs.MALICIOUS_XSLT-1"
    secondary_identifiers:
    - name: "Find Security Bugs-MALICIOUS_XSLT"
      type: "find_sec_bugs_type"
      value: "MALICIOUS_XSLT"
  severity: "WARNING"
- id: "find_sec_bugs.XPATH_INJECTION-1"
  languages:
  - "java"
  message: |
    The application processes `XPath` queries with potentially malicious input.
    An adversary who is able to control the XPath query could potentially influence the logic
    of how data is retrieved, processed or even bypass protections.

    To protect against XPath injection, user input should be parameterized using a variable
    resolver.
    By creating a class that implements the `XPathVariableResolver` the application can ensure
    that
    the xpath query and user-supplied input are treated separately.

    Example implementation of an XPathVariableResolver:
    ```
    // Create a class which implements the XPathVariableResolver interface
    public static class SimpleXPathVariableResolver implements XPathVariableResolver {
      // Use a map or lookup table to store variables for resolution
      private HashMap<QName, String> variables = new HashMap<>();
      // Allow caller to set variables
      public void setVariable(QName name, String value) {
        variables.put(name, value);
      }
      // Implement the resolveVariable to return the value
      @Override
      public Object resolveVariable(QName name) {
        return variables.getOrDefault(name, "");
      }
    }

    public static void xpathQuery(String userInput) throws ParseException,
    ParserConfigurationException,
      SAXException, IOException, XPathExpressionException {

      // Create our DocumentFactory
      DocumentBuilderFactory domFactory = DocumentBuilderFactory.newInstance();
      // Enable namespace awareness
      domFactory.setNamespaceAware(true);
      // Enable secure processing
      domFactory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);
      // Create our DocumentBuilder
      DocumentBuilder builder = domFactory.newDocumentBuilder();
      // Parse our XML document
      Document doc = builder.parse("inventory.xml");

      // Create a new instance of an XPath object
      XPath xpathProcessor = XPathFactory.newInstance().newXPath();
      // Create our XPathVariableResolver
      SimpleXPathVariableResolver resolver = new SimpleXPathVariableResolver();
      // Add user input as a variable value
      resolver.setVariable(new QName("author"), userInput);
      // Configure the processor to use our variable resolver
      xpathProcessor.setXPathVariableResolver(resolver);
      // Evaluate the XPath query
          String result = xpathProcessor.compile("//author[contains(., $author)]").evaluate(doc);
      // Work with the result
      // ...
    }
    ```

    For more information on XPath Injection see:
    - https://owasp.org/www-community/attacks/XPATH_Injection
  metadata:
    shortDescription: "Improper neutralization of data within XPath expressions ('XPath
      Injection')"
    category: "security"
    cwe: "CWE-643"
    primary_identifier: "find_sec_bugs.XPATH_INJECTION-1"
    secondary_identifiers:
    - name: "Find Security Bugs-XPATH_INJECTION"
      type: "find_sec_bugs_type"
      value: "XPATH_INJECTION"
  patterns:
  - pattern-either:
    - pattern-inside: |-
        import javax.xml.xpath.*; ...
    - pattern-inside: |-
        import javax.xml.xpath.XPath; ...
  - pattern-either:
    - patterns:
      - pattern: "(XPath $X).compile($ARG)"
      - pattern-not: "(XPath $X).compile(\"...\")"
    - patterns:
      - pattern: "(XPath $X).evaluate($ARG)"
      - pattern-not: "(XPath $X).evaluate(\"...\")"
  severity: "ERROR"
- id: "find_sec_bugs.XSS_REQUEST_WRAPPER-1"
  languages:
  - "java"
  message: |
    Avoid using custom XSS filtering. Please use standard sanitization functions.
  metadata:
    category: "security"
    cwe: "CWE-79"
    shortDescription: "Improper Neutralization of Input During Web Page Generation
      ('Cross-site Scripting')"
    primary_identifier: "find_sec_bugs.XSS_REQUEST_WRAPPER-1"
    secondary_identifiers:
    - name: "Find Security Bugs-XSS_REQUEST_WRAPPER"
      type: "find_sec_bugs_type"
      value: "XSS_REQUEST_WRAPPER"
  patterns:
  - pattern-inside: |
      class $CLASS extends HttpServletRequestWrapper {
      ...
      }
  - pattern: "stripXSS(...) { ... }"
  severity: "INFO"
- id: "find_sec_bugs.WICKET_XSS1-1"
  languages:
  - "java"
  patterns:
  - pattern: "(org.apache.wicket.markup.html.basic.Label $X).setEscapeModelStrings(false);"
  message: |
    The application is disabling Wicket's string escaping functionality by calling
    `setEscapeModelStrings(false)`.
    This could lead to Cross Site Scripting (XSS) if used with user-supplied input. XSS is an
    attack which exploits
     a web application or system to treat    user input
    as markup or script code. It is important to encode the data depending on the specific context
    it
    is used in. There are at least six context types:

    - Inside HTML tags `<div>context 1</div>`
    - Inside attributes: `<div class="context 2"></div>`
    - Inside event attributes `<button onclick="context 3">button</button>`
    - Inside script blocks: `<script>var x = "context 4"</script>`
    - Unsafe element HTML assignment: `element.innerHTML = "context 5"`
    - Inside URLs: `<iframe src="context 6"></iframe><a href="context 6">link</a>`

    Script blocks alone have multiple ways they need to be encoded. Extra care must be taken if
    user input
    is ever output inside of script tags.

    User input that is displayed within the application must be encoded, sanitized or validated
    to ensure it cannot be treated as HTML or executed as JavaScript code. Care must also be
    taken
    to not mix server-side templating with client-side templating, as the server-side templating
    will
    not encode things like {{ 7*7 }} which may execute client-side templating features.

    It is _NOT_ advised to encode user input prior to inserting into a data store. The data will
    need to be
    encoded depending on context of where it is output. It is much safer to force the displaying
    system to
    handle the encoding and not attempt to guess how it should be encoded.

    Use Wicket's built in escaping feature by calling `Component.setEscapeModelStrings(true);`

    For more information on Wicket components see:
    - https://nightlies.apache.org/wicket/apidocs/9.x/org/apache/wicket/Component.html

    For more information on XSS see OWASP:
    - https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html
  metadata:
    shortDescription: "Improper neutralization of input during web page generation
      ('Cross-site Scripting')"
    category: "security"
    cwe: "CWE-79"
    primary_identifier: "find_sec_bugs.WICKET_XSS1-1"
    secondary_identifiers:
    - name: "Find Security Bugs-WICKET_XSS1"
      type: "find_sec_bugs_type"
      value: "WICKET_XSS1"
  severity: "WARNING"
- id: "find_sec_bugs.XSS_REQUEST_PARAMETER_TO_SEND_ERROR-1"
  languages:
  - "java"
  mode: "taint"
  pattern-sanitizers:
  - patterns:
    - pattern-inside: |-
        org.owasp.encoder.Encode.forHtml($TAINTED);
    - pattern: "$TAINTED"
  pattern-sinks:
  - patterns:
    - pattern-inside: |-
        $FUNC(..., HttpServletResponse $RES, ...) {...}
    - pattern: "$RES.sendError(..., $DATA);"
    - pattern: "$DATA"
  pattern-sources:
  - patterns:
    - pattern-inside: |-
        $FUNC(..., HttpServletRequest $REQ, ...) {...}
    - pattern-either:
      - pattern: "$REQ.getParameter(...);"
      - pattern: "$REQ.getHeader(...);"
      - pattern: "$REQ.getRequestedSessionId();"
      - pattern: "$REQ.getQueryString();"
  message: |
    The application is returning user-supplied data from an HTTP request to an HTTP response's
    `sendError` method. This could lead to Cross Site Scripting (XSS) if the input were malicious
    script code and the application server is not properly validating the output. Note that Apache
    Tomcat 9 and above automatically encode the output and are not vulnerable.

    XSS is an attack which exploits a web application or system to treat user input
    as markup or script code. It is important to encode the data depending on the specific context
    it is used in. There are at least six context types:

    - Inside HTML tags `<div>context 1</div>`
    - Inside attributes: `<div class="context 2"></div>`
    - Inside event attributes `<button onclick="context 3">button</button>`
    - Inside script blocks: `<script>var x = "context 4"</script>`
    - Unsafe element HTML assignment: `element.innerHTML = "context 5"`
    - Inside URLs: `<iframe src="context 6"></iframe><a href="context 6">link</a>`

    Script blocks alone have multiple ways they need to be encoded. Extra care must be taken if
    user input
    is ever output inside of script tags.

    User input that is displayed within the application must be encoded, sanitized or validated
    to ensure it cannot be treated as HTML or executed as Javascript code. Care must also be
    taken
    to not mix server-side templating with client-side templating, as the server-side templating
    will
    not encode things like {{ 7*7 }} which may execute client-side templating features.

    It is _NOT_ advised to encode user input prior to inserting into a data store. The data will
    need to be
    encoded depending on context of where it is output. It is much safer to force the displaying
    system to
    handle the encoding and not attempt to guess how it should be encoded.

    If possible do not use user input directly in the output to the `sendError` message parameter.

    Regardless if the application server handles output encoding, consider encoding any
    user-supplied
    input
    that is used in the sendError method:

    Example using [Apache Commons Text](https://commons.apache.org/proper/commons-text/)
    `StringEscapeUtils.escapeHtml4`:
    ```
    // Get user input
    String userInput = request.getParameter("key");
    // Encode the input using the Html4 encoder
    String encoded = StringEscapeUtils.escapeHtml4(userInput);
    // Respond with the error code and value
    response.sendError(401, encoded);
    ```

    For more information on XSS see OWASP:
    - https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html
  severity: "WARNING"
  metadata:
    shortDescription: "Improper neutralization of input during web page generation
      ('Cross-site Scripting')"
    category: "security"
    cwe: "CWE-79"
    technology:
    - "java"
    primary_identifier: "find_sec_bugs.XSS_REQUEST_PARAMETER_TO_SEND_ERROR-1"
    secondary_identifiers:
    - name: "Find Security Bugs-XSS_REQUEST_PARAMETER_TO_SEND_ERROR"
      type: "find_sec_bugs_type"
      value: "XSS_REQUEST_PARAMETER_TO_SEND_ERROR"
- id: "find_sec_bugs.XSS_REQUEST_PARAMETER_TO_SERVLET_WRITER-1"
  languages:
  - "java"
  mode: "taint"
  pattern-sanitizers:
  - patterns:
    - pattern-inside: |-
        org.owasp.encoder.Encode.forHtml($TAINTED);
    - pattern: "$TAINTED"
  pattern-sinks:
  - patterns:
    - pattern-inside: |-
        $FUNC(..., HttpServletResponse $RES, ...) {...}
    - pattern-inside: |
        $WRITER = $RES.getWriter();
        ...
    - pattern: "$WRITER.write($DATA,...);"
    - pattern: "$DATA"
  - patterns:
    - pattern-inside: |-
        $FUNC(..., HttpServletResponse $RES, ...) {...}
    - pattern: "$RES.getWriter().write($DATA,...);"
    - pattern: "$DATA"
  pattern-sources:
  - patterns:
    - pattern-inside: |-
        $FUNC(..., HttpServletRequest $REQ, ...) {...}
    - pattern: "$REQ.getParameter(...);"
  message: |
    The application is returning user-supplied data from an HTTP request directly into an HTTP
    response output
    writer. This could lead to Cross Site Scripting (XSS) if the input were malicious
    script code and the application server is not properly validating the output.

    XSS is an attack which exploits a web application or system to treat user input
    as markup or script code. It is important to encode the data depending on the specific context
    it is used in. There are at least six context types:

    - Inside HTML tags `<div>context 1</div>`
    - Inside attributes: `<div class="context 2"></div>`
    - Inside event attributes `<button onclick="context 3">button</button>`
    - Inside script blocks: `<script>var x = "context 4"</script>`
    - Unsafe element HTML assignment: `element.innerHTML = "context 5"`
    - Inside URLs: `<iframe src="context 6"></iframe><a href="context 6">link</a>`

    Script blocks alone have multiple ways they need to be encoded. Extra care must be taken if
    user input
    is ever output inside of script tags.

    User input that is displayed within the application must be encoded, sanitized or validated
    to ensure it cannot be treated as HTML or executed as Javascript code. Care must also be
    taken
    to not mix server-side templating with client-side templating, as the server-side templating
    will
    not encode things like {{ 7*7 }} which may execute client-side templating features.

    It is _NOT_ advised to encode user input prior to inserting into a data store. The data will
    need to be
    encoded depending on context of where it is output. It is much safer to force the displaying
    system to
    handle the encoding and not attempt to guess how it should be encoded.

    If possible do not use user input directly in the output to the response writer.

    If the application must output user-supplied input, it will need to encode the data depending
    on
    the output context.

    Consider using [Apache Commons Text](https://commons.apache.org/proper/commons-text/)
    `StringEscapeUtils` methods for various context. Please note there is no way to safely
    output script code in most circumstances, regardless of encoding. If calling the HTTP
    response writer directly, ensure that the `Content-Type` is set to `text/plain` so it will
    not be accidentally interpreted by HTML by modern browsers.
    ```
    // Get user input
    String htmlInput = request.getParameter("userInput");
    // Encode the input using the Html4 encoder
    String htmlEncoded = StringEscapeUtils.escapeHtml4(htmlInput);
    // Force the HTTP response to be content type of text/plain so it is not interpreted as HTML
    response.setContentType("text/plain");
    // Ensure UTF-8
    response.setCharacterEncoding("UTF-8");
    // Write response
    response.getWriter().write(htmlEncoded);
    ```

    For more information on XSS see OWASP:
    - https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html
  severity: "WARNING"
  metadata:
    shortDescription: "Improper neutralization of input during web page generation
      ('Cross-site Scripting')"
    category: "security"
    cwe: "CWE-79"
    technology:
    - "java"
    primary_identifier: "find_sec_bugs.XSS_REQUEST_PARAMETER_TO_SERVLET_WRITER-1"
    secondary_identifiers:
    - name: "Find Security Bugs-XSS_REQUEST_PARAMETER_TO_SERVLET_WRITER"
      type: "find_sec_bugs_type"
      value: "XSS_REQUEST_PARAMETER_TO_SERVLET_WRITER"
- id: "find_sec_bugs.XSS_SERVLET-1"
  languages:
  - "java"
  message: |
    A potential XSS was found. It could be used to execute unwanted JavaScript in a
    client's browser.
  metadata:
    category: "security"
    cwe: "CWE-79"
    shortDescription: "Improper Neutralization of Input During Web Page Generation
      ('Cross-site Scripting')"
    primary_identifier: "find_sec_bugs.XSS_SERVLET-1"
    secondary_identifiers:
    - name: "Find Security Bugs-XSS_SERVLET"
      type: "find_sec_bugs_type"
      value: "XSS_SERVLET"
  mode: "taint"
  pattern-sanitizers:
  - patterns:
    - pattern-inside: |-
        org.owasp.encoder.Encode.forHtml($TAINTED);
    - pattern: "$TAINTED"
  pattern-sinks:
  - patterns:
    - pattern-inside: |-
        $FUNC(..., HttpServletResponse $RES, ...) {...}
    - pattern-inside: |
        $WRITER = $RES.getWriter();
        ...
    - pattern: "$WRITER.write($DATA,...);"
    - pattern: "$DATA"
  - patterns:
    - pattern-inside: |-
        $FUNC(..., HttpServletResponse $RES, ...) {...}
    - pattern: "$RES.getWriter().write($DATA,...);"
    - pattern: "$DATA"
  pattern-sources:
  - patterns:
    - pattern-inside: |-
        $FUNC(..., HttpServletRequest $REQ, ...) {...}
    - pattern: "$REQ.getParameter(...);"
  severity: "WARNING"
- id: "find_sec_bugs.XSS_SERVLET-2.XSS_SERVLET_PARAMETER-1"
  languages:
  - "java"
  message: |
    The Servlet can read GET and POST parameters from various methods. The value obtained should be
    considered unsafe. You may need to validate or sanitize those values before passing them to
    sensitive APIs
  metadata:
    category: "security"
    cwe: "CWE-20"
    shortDescription: "Improper Input Validation"
    technology:
    - "java"
    primary_identifier: "find_sec_bugs.XSS_SERVLET-2.XSS_SERVLET_PARAMETER-1"
    secondary_identifiers:
    - name: "Find Security Bugs-XSS_SERVLET"
      type: "find_sec_bugs_type"
      value: "XSS_SERVLET"
    - name: "Find Security Bugs-XSS_SERVLET_PARAMETER"
      type: "find_sec_bugs_type"
      value: "XSS_SERVLET_PARAMETER"
  pattern-either:
  - patterns:
    - pattern-inside: |-
        $TYPE $FUNC(..., ServletRequest $REQ, ...) { ... }
    - pattern-either:
      - pattern: "$REQ.getParameter(...);"
      - pattern: "$REQ.getParameterValues();"
      - pattern: "$REQ.getParameterMap(...);"
      - pattern: "$REQ.getParameterNames();"
  - patterns:
    - pattern-inside: |-
        $TYPE $FUNC(..., HttpServletRequest $SREQ, ...) { ... }
    - pattern-either:
      - pattern: "$SREQ.getRequestedSessionId();"
      - pattern: "$SREQ.getQueryString();"
      - pattern: "$SREQ.getParameter(...);"
      - pattern: "$SREQ.getParameterValues();"
      - pattern: "$SREQ.getParameterMap(...);"
      - pattern: "$SREQ.getParameterNames();"
      - patterns:
        - pattern: "$SREQ.getHeader($HEADER);"
        - metavariable-regex:
            metavariable: "$HEADER"
            regex: "(?i)(Host|Referer|User-Agent)"
  severity: "WARNING"
- id: "find_sec_bugs.XXE_SAXPARSER-1"
  languages:
  - "java"
  message: |
    External XML entities are a feature of XML parsers that allow documents to contain references
    to
    other documents or data. This feature can be abused to read files, communicate with external
    hosts,
    exfiltrate data, or cause a Denial of Service (DoS).

    It is recommended that the `SAXParser` is configured to disable DTD doctypes as this protects
    against the majority of XXE attacks.

    Example creating a SAXParser with disallowing the doctypes feature enabled:
    ```
    // Create a SAXParserFactory
    SAXParserFactory saxParserFactory = SAXParserFactory.newInstance();
    // Enable the feature which disallows <!DOCTYPE declarations which includes referencing
    external entities.
    saxParserFactory.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true);
    // Create a new parser from this factory
    SAXParser parser = saxParserFactory.newSAXParser();
    // Parse the XML file, passing in a DefaultHandler (which also includes an empty entityResolve
    method)
    parser.parse(new FileInputStream(new File("bad.xml")), new DefaultHandler());
    ```

    For more information on XML security see OWASP's guide:
    https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html#java
  metadata:
    shortDescription: "Improper restriction of XML external entity reference ('XXE')"
    category: "security"
    cwe: "CWE-611"
    primary_identifier: "find_sec_bugs.XXE_SAXPARSER-1"
    secondary_identifiers:
    - name: "Find Security Bugs-XXE_SAXPARSER"
      type: "find_sec_bugs_type"
      value: "XXE_SAXPARSER"
  patterns:
  - pattern-inside: |
      $SF = SAXParserFactory.newInstance();
      ...
  - pattern-not-inside: |
      $SF.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);
      ...
  - pattern-not-inside: |
      $SF.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true);
      ...
  - pattern-inside: |
      $P = $SFP.newSAXParser();
      ...
  - pattern: "$P.parse(...);"
  severity: "ERROR"
- id: "find_sec_bugs.XXE_DTD_TRANSFORM_FACTORY-1.XXE_XSLT_TRANSFORM_FACTORY-1"
  languages:
  - "java"
  message: |
    XML External Entity (XXE) attacks can occur when an XML parser supports XML
    entities while processing XML received from an untrusted source.
  metadata:
    category: "security"
    cwe: "CWE-611"
    shortDescription: "Improper Restriction of XML External Entity Reference ('XXE')"
    primary_identifier: "find_sec_bugs.XXE_DTD_TRANSFORM_FACTORY-1.XXE_XSLT_TRANSFORM_FACTORY-1"
    secondary_identifiers:
    - name: "Find Security Bugs-XXE_DTD_TRANSFORM_FACTORY"
      type: "find_sec_bugs_type"
      value: "XXE_DTD_TRANSFORM_FACTORY"
    - name: "Find Security Bugs-XXE_XSLT_TRANSFORM_FACTORY"
      type: "find_sec_bugs_type"
      value: "XXE_XSLT_TRANSFORM_FACTORY"
  patterns:
  - pattern-inside: |-
      import javax.xml.transform.*; ...
  - pattern-inside: |
      $T = $FACT.newTransformer();
      ...
  - pattern-not-inside: |
      $T.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, "");
      ...
  - pattern-not-inside: |
      $T.setAttribute(XMLConstants.ACCESS_EXTERNAL_SCHEMA, "");
      ...
  - pattern-not-inside: |
      $T.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);
      ...
  - pattern: "$T.transform(...)"
  severity: "ERROR"
- id: "find_sec_bugs.XXE_XMLREADER-1"
  languages:
  - "java"
  message: |
    External XML entities are a feature of XML parsers that allow documents to contain references
    to
    other documents or data. This feature can be abused to read files, communicate with external
    hosts,
    exfiltrate data, or cause a Denial of Service (DoS).

    The XMLReaderFactory has been deprecated. It is recommended that
    [SAXParserFactory](https://docs.oracle.com/javase/9/docs/api/javax/xml/parsers/SAXParserFactory.html)
    be used
    instead. Additionally when using the SAXParser it must be configured to disallow doctypes,
    which will
    protect against the majority of XXE attacks.

    Example creating a SAXParser with disallowing the doctypes feature enabled:
    ```
    // Create a SAXParserFactory
    SAXParserFactory saxParserFactory = SAXParserFactory.newInstance();
    // Enable the feature which disallows <!DOCTYPE declarations which includes referencing
    external entities.
    saxParserFactory.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true);
    // Create a new parser from this factory
    SAXParser parser = saxParserFactory.newSAXParser();
    // Parse the XML file, passing in a DefaultHandler (which also includes an empty entityResolve
    method)
    parser.parse(new FileInputStream(new File("bad.xml")), new DefaultHandler());
    ```

    For more information on XML security see OWASP's guide:
    https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html#java
  metadata:
    shortDescription: "Improper restriction of XML external entity reference ('XXE')"
    category: "security"
    cwe: "CWE-611"
    primary_identifier: "find_sec_bugs.XXE_XMLREADER-1"
    secondary_identifiers:
    - name: "Find Security Bugs-XXE_XMLREADER"
      type: "find_sec_bugs_type"
      value: "XXE_XMLREADER"
  patterns:
  - pattern-inside: |
      $R = XMLReaderFactory.createXMLReader();
      ...
  - pattern-not-inside: |
      $R.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);
      ...
  - pattern: "$R.parse(...);"
  severity: "ERROR"
- id: "find_sec_bugs.XXE_XMLSTREAMREADER-1"
  languages:
  - "java"
  message: |
    External XML entities are a feature of XML parsers that allow documents to contain references
    to
    other documents or data. This feature can be abused to read files, communicate with external
    hosts,
    exfiltrate data, or cause a Denial of Service (DoS).

    In most XML parsers, the recommendation to protect against XXE is to disable the doctype
    feature.
    Unfortunately use of the `XMLInputFactory` requires that the doctypes feature be enabled.
    Instead
    the application can set the `ACCESS_EXTERNAL_DTD` to an empty string and disable
    `javax.xml.stream.isSupportingExternalEntities`.


    Creates an `XMLInputFactory` stream parser, but disables accessing external DTD or entities:
    ```
    // Create an XMLInputFactory
    XMLInputFactory factory = XMLInputFactory.newFactory();
    // Set the ACCESS_EXTERNAL_DTD property to an empty string so it won't access
    // entities using protocols
    // (ref:
    https://docs.oracle.com/javase/8/docs/api/javax/xml/XMLConstants.html#ACCESS_EXTERNAL_DTD)
    factory.setProperty(XMLConstants.ACCESS_EXTERNAL_DTD, "");
    // Additionally, disable support for resolving external entities
    factory.setProperty("javax.xml.stream.isSupportingExternalEntities", false);
    // Continue to work with the factory/stream parser
    ```

    For more information on XML security see OWASP's guide:
    https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html#java
  metadata:
    shortDescription: "Improper restriction of XML external entity reference ('XXE')"
    category: "security"
    cwe: "CWE-611"
    primary_identifier: "find_sec_bugs.XXE_XMLSTREAMREADER-1"
    secondary_identifiers:
    - name: "Find Security Bugs-XXE_XMLSTREAMREADER"
      type: "find_sec_bugs_type"
      value: "XXE_XMLSTREAMREADER"
  patterns:
  - pattern-inside: |
      $SF = XMLInputFactory.newFactory();
      ...
  - pattern-not-inside: |
      $SF.setProperty(XMLInputFactory.SUPPORT_DTD, false);
      ...
  - pattern-not-inside: |
      $SF.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, false);
      ...
  - pattern-not-inside: |
      $SF.setProperty(XMLInputFactory.SUPPORT_DTD, Boolean.FALSE);
      ...
  - pattern-not-inside: |
      $SF.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, Boolean.FALSE);
      ...
  - pattern: "$SF.createXMLStreamReader(...)"
  severity: "ERROR"
- id: "find_sec_bugs.XXE_XPATH-1.XXE_DOCUMENT-1"
  languages:
  - "java"
  message: |
    XML External Entity (XXE) attacks can occur when an XML parser supports XML
    entities while processing XML received from an untrusted source.
  metadata:
    category: "security"
    cwe: "CWE-611"
    shortDescription: "Improper Restriction of XML External Entity Reference ('XXE')"
    primary_identifier: "find_sec_bugs.XXE_XPATH-1.XXE_DOCUMENT-1"
    secondary_identifiers:
    - name: "Find Security Bugs-XXE_XPATH"
      type: "find_sec_bugs_type"
      value: "XXE_XPATH"
    - name: "Find Security Bugs-XXE_DOCUMENT"
      type: "find_sec_bugs_type"
      value: "XXE_DOCUMENT"
  patterns:
  - pattern-inside: |
      $DF = df.newDocumentBuilder();
      ...
  - pattern-not-inside: |
      $DF.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, "");
      ...
  - pattern-not-inside: |
      $DF.setAttribute(XMLConstants.ACCESS_EXTERNAL_SCHEMA, "");
      ...
  - pattern-not-inside: |
      $DF.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);
      ...
  - pattern-not-inside: |
      $DF.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true);
      ...
  - pattern: "$SF.newDocumentBuilder(...)"
  severity: "ERROR"
