# yamllint disable
# rule-set version: v1.3.40
# yamllint enable
---
rules:
- id: "find_sec_bugs_scala.HTTPONLY_COOKIE-1"
  languages:
  - "scala"
  message: |
    A new cookie is created without the HttpOnly flag set. The HttpOnly flag is a directive to the
    browser to make sure that the cookie can not be red by malicious script. When a user is the
    target of a "Cross-Site Scripting", the attacker would benefit greatly from getting the session
    id for example.
  metadata:
    category: "security"
    cwe: "CWE-1004"
    shortDescription: "Sensitive Cookie Without 'HttpOnly' Flag"
    technology:
    - "scala"
    primary_identifier: "find_sec_bugs.HTTPONLY_COOKIE"
    secondary_identifiers:
    - name: "Find Security Bugs-HTTPONLY_COOKIE"
      type: "find_sec_bugs_type"
      value: "HTTPONLY_COOKIE"
  pattern-either:
  - patterns:
    - pattern: |
        val $C = new javax.servlet.http.Cookie(..., ...);
        ...
        $RESP.addCookie($C);
    - pattern-not-inside: |
        val $C = new javax.servlet.http.Cookie(..., ...);
        ...
        $C.setHttpOnly(true);
        ...
        $RESP.addCookie($C);
  - pattern: "(javax.servlet.http.Cookie $C).setHttpOnly(false);"
  severity: "WARNING"
- id: "find_sec_bugs_scala.INSECURE_COOKIE-1"
  languages:
  - "scala"
  message: |
    "A new cookie is created without the Secure flag set. The Secure flag is a
     directive to the browser to make sure that the cookie is not sent for insecure communication
    (http://)"
  metadata:
    category: "security"
    cwe: "CWE-539"
    shortDescription: "Information Exposure Through Persistent Cookies"
    technology:
    - "scala"
    primary_identifier: "find_sec_bugs.INSECURE_COOKIE"
    secondary_identifiers:
    - name: "Find Security Bugs-INSECURE_COOKIE"
      type: "find_sec_bugs_type"
      value: "INSECURE_COOKIE"
  patterns:
  - pattern-not-inside: |
      val $C = new javax.servlet.http.Cookie(..., ...);
      ...
      $C.setSecure(true);
      ...
      $RESP.addCookie($C);
  - pattern-either:
    - pattern: |
        val $C = new javax.servlet.http.Cookie(..., ...);
        ...
        $RESP.addCookie($C);
    - pattern: "($C:javax.servlet.http.Cookie).setSecure(false);"
  severity: "WARNING"
- id: "find_sec_bugs_scala.COOKIE_PERSISTENT-1"
  languages:
  - "scala"
  message: |
    "Storing sensitive data in a persistent cookie for an extended period can lead to a breach of
    confidentiality or account compromise."
  metadata:
    category: "security"
    cwe: "CWE-614"
    shortDescription: "Sensitive Cookie in HTTPS Session Without 'Secure' Attribute"
    technology:
    - "scala"
    primary_identifier: "find_sec_bugs.COOKIE_PERSISTENT"
    secondary_identifiers:
    - name: "Find Security Bugs-COOKIE_PERSISTENT"
      type: "find_sec_bugs_type"
      value: "COOKIE_PERSISTENT"
  patterns:
  - pattern: |
      ($C: Cookie).setMaxAge($AGE)
  - metavariable-comparison:
      comparison: "$AGE >= 31536000"
      metavariable: "$AGE"
  severity: "WARNING"
- id: "find_sec_bugs_scala.COOKIE_USAGE-1"
  languages:
  - "scala"
  message: |
    The information stored in a custom cookie should not be sensitive or related to the session.
    In most cases, sensitive data should only be stored in session and referenced by the user's
    session cookie.
  metadata:
    category: "security"
    cwe: "CWE-614"
    shortDescription: "Sensitive Cookie in HTTPS Session Without 'Secure' Attribute"
    technology:
    - "scala"
    primary_identifier: "find_sec_bugs.COOKIE_USAGE"
    secondary_identifiers:
    - name: "Find Security Bugs-COOKIE_USAGE"
      type: "find_sec_bugs_type"
      value: "COOKIE_USAGE"
  patterns:
  - pattern-inside: |
      def $FUNC(..., $REQ: HttpServletRequest, ...): $TYPE = {
        ...
      }
  - pattern-either:
    - patterns:
      - pattern-inside: |
          for ($C <- $REQ.getCookies) {
              ...
          }
      - pattern-either:
        - pattern: "$C.getName"
        - pattern: "$C.getValue"
        - pattern: "$C.getPath"
    - pattern: "($C: Cookie).getName()"
    - pattern: "($C: Cookie).getValue"
    - pattern: "($C: Cookie).getPath"
  severity: "WARNING"
- id: "find_sec_bugs_scala.HTTP_RESPONSE_SPLITTING-1"
  languages:
  - "scala"
  message: |
    When an HTTP request contains unexpected CR and LF characters, the server may respond with an
    output stream that is interpreted as two different HTTP responses (instead of one). An attacker
    can control the second response and mount attacks such as cross-site scripting and cache
    poisoning attacks.
  metadata:
    category: "security"
    cwe: "CWE-113"
    shortDescription: "Improper Neutralization of CRLF Sequences in HTTP Headers ('HTTP
      Response Splitting')"
    technology:
    - "scala"
    primary_identifier: "find_sec_bugs.HTTP_RESPONSE_SPLITTING"
    secondary_identifiers:
    - name: "Find Security Bugs-HTTP_RESPONSE_SPLITTING"
      type: "find_sec_bugs_type"
      value: "HTTP_RESPONSE_SPLITTING"
  mode: "taint"
  pattern-sanitizers:
  - patterns:
    - pattern-inside: |-
        $STR.replaceAll("$REPLACE_CHAR", "$REPLACE");
    - pattern: "$STR"
    - metavariable-regex:
        metavariable: "$REPLACE_CHAR"
        regex: "(.*\\\\r\\\\n.*)"
    - metavariable-regex:
        metavariable: "$REPLACE"
        regex: "(?!(\\\\r\\\\n))"
  - pattern: "org.owasp.encoder.Encode.forUriComponent(...)"
  - pattern: "org.owasp.encoder.Encode.forUri(...)"
  - pattern: "java.net.URLEncoder.encode(..., $CHARSET)"
  pattern-sinks:
  - pattern: "new javax.servlet.http.Cookie(\"$KEY\", ...)"
  - pattern: "($C:javax.servlet.http.Cookie).setValue(...)"
  pattern-sources:
  - pattern: "($REQ: javax.servlet.http.HttpServletRequest).getParameter(...)"
  severity: "WARNING"
- id: "find_sec_bugs_scala.HRS_REQUEST_PARAMETER_TO_COOKIE-1"
  languages:
  - "scala"
  message: |
    This code constructs an HTTP Cookie using an untrusted HTTP parameter. If this cookie is added
    to an HTTP response, it will allow a HTTP response splitting vulnerability. See
    http://en.wikipedia.org/wiki/HTTP_response_splitting for more information.
  metadata:
    category: "security"
    cwe: "CWE-113"
    shortDescription: "Improper Neutralization of CRLF Sequences in HTTP Headers ('HTTP
      Response Splitting')"
    technology:
    - "scala"
    primary_identifier: "find_sec_bugs.HRS_REQUEST_PARAMETER_TO_COOKIE"
    secondary_identifiers:
    - name: "Find Security Bugs-HRS_REQUEST_PARAMETER_TO_COOKIE"
      type: "find_sec_bugs_type"
      value: "HRS_REQUEST_PARAMETER_TO_COOKIE"
  mode: "taint"
  pattern-sanitizers:
  - patterns:
    - pattern-inside: |-
        $STR.replaceAll("$REPLACE_CHAR", "$REPLACE");
    - pattern: "$STR"
    - metavariable-regex:
        metavariable: "$REPLACE_CHAR"
        regex: "(.*\\\\r\\\\n.*)"
    - metavariable-regex:
        metavariable: "$REPLACE"
        regex: "(?!(\\\\r\\\\n))"
  - pattern: "org.owasp.encoder.Encode.forUriComponent(...)"
  - pattern: "org.owasp.encoder.Encode.forUri(...)"
  - pattern: "java.net.URLEncoder.encode(..., $CHARSET)"
  pattern-sinks:
  - pattern: "new javax.servlet.http.Cookie(\"$KEY\", ...);"
  - patterns:
    - pattern-inside: |
        $C = new javax.servlet.http.Cookie("$KEY", ...);
        ...
    - pattern: "$C.setValue(...);"
  pattern-sources:
  - pattern: "($REQ: HttpServletRequest).getParameter(...);"
  severity: "ERROR"
- id: "find_sec_bugs_scala.HRS_REQUEST_PARAMETER_TO_HTTP_HEADER-1"
  languages:
  - "scala"
  message: |
    This code directly writes an HTTP parameter to an HTTP header, which allows for a HTTP
    response splitting vulnerability. See http://en.wikipedia.org/wiki/HTTP_response_splitting for
    more information.
  metadata:
    category: "security"
    cwe: "CWE-113"
    shortDescription: "Improper Neutralization of CRLF Sequences in HTTP Headers ('HTTP
      Response Splitting')"
    technology:
    - "scala"
    primary_identifier: "find_sec_bugs.HRS_REQUEST_PARAMETER_TO_HTTP_HEADER"
    secondary_identifiers:
    - name: "Find Security Bugs-HRS_REQUEST_PARAMETER_TO_HTTP_HEADER"
      type: "find_sec_bugs_type"
      value: "HRS_REQUEST_PARAMETER_TO_HTTP_HEADER"
  mode: "taint"
  pattern-sanitizers:
  - patterns:
    - pattern-inside: |-
        $STR.replaceAll("$REPLACE_CHAR", "$REPLACE");
    - pattern: "$STR"
    - metavariable-regex:
        metavariable: "$REPLACE_CHAR"
        regex: "(.*\\\\r\\\\n.*)"
    - metavariable-regex:
        metavariable: "$REPLACE"
        regex: "(?!(\\\\r\\\\n))"
  - pattern: "org.owasp.encoder.Encode.forUriComponent(...)"
  - pattern: "org.owasp.encoder.Encode.forUri(...)"
  - pattern: "java.net.URLEncoder.encode(..., $CHARSET)"
  pattern-sinks:
  - pattern: "($RES: HttpServletResponse).setHeader(\"$KEY\", ...);"
  - pattern: "($RES: HttpServletResponse).addHeader(\"$KEY\", ...);"
  - pattern: "($WRP: HttpServletResponseWrapper).setHeader(\"$KEY\", ...);"
  - pattern: "($WRP: HttpServletResponseWrapper).addHeader(\"$KEY\", ...);"
  pattern-sources:
  - pattern: "($REQ: HttpServletRequest).getParameter(...);"
  severity: "ERROR"
- id: "find_sec_bugs_scala.TRUST_BOUNDARY_VIOLATION-1"
  languages:
  - "scala"
  message: |
    A trust boundary can be thought of as line drawn through a program. On one side
    of the line, data is untrusted. On the other side of the line, data is assumed
    to be trustworthy. The purpose of validation logic is to allow data to safely
    cross the trust boundary - to move from untrusted to trusted. A trust boundary
    violation occurs when a program blurs the line between what is trusted and what
    is untrusted. By combining trusted and untrusted data in the same data
    structure, it becomes easier for programmers to mistakenly trust unvalidated
    data.
  metadata:
    category: "security"
    cwe: "CWE-501"
    shortDescription: "Trust Boundary Violation"
    primary_identifier: "find_sec_bugs.TRUST_BOUNDARY_VIOLATION"
    secondary_identifiers:
    - name: "Find Security Bugs-TRUST_BOUNDARY_VIOLATION"
      type: "find_sec_bugs_type"
      value: "TRUST_BOUNDARY_VIOLATION"
  patterns:
  - pattern-either:
    - patterns:
      - pattern: "($H: HttpServletRequest). ... .setAttribute($ARG1, $ARG2)"
      - pattern-not: "($H: HttpServletRequest). ... .setAttribute(\"...\", \"...\")"
    - patterns:
      - pattern: "($H: HttpServletRequest). ... .putValue($ARG1, $ARG2)"
      - pattern-not: "($H: HttpServletRequest). ... .putValue(\"...\", \"...\")"
  severity: "WARNING"
- id: "find_sec_bugs_scala.PERMISSIVE_CORS-1"
  languages:
  - "scala"
  message: |
    Prior to HTML5, Web browsers enforced the Same Origin Policy which ensures that in order for
    JavaScript to access the contents of a Web page, both the JavaScript and the Web page must
    originate from the same domain. Without the Same Origin Policy, a malicious website could serve
    up JavaScript that loads sensitive information from other websites using a client's
    credentials, cull through it, and communicate it back to the attacker. HTML5 makes it possible
    for JavaScript to access data across domains if a new HTTP header called
    Access-Control-Allow-Origin is defined. With this header, a Web server defines which other
    domains are allowed to access its domain using cross-origin requests. However, caution should
    be taken when defining the header because an overly permissive CORS policy will allow a
    malicious application to communicate with the victim application in an inappropriate way,
    leading to spoofing, data theft, relay and other attacks.
  metadata:
    category: "security"
    cwe: "CWE-942"
    shortDescription: "Permissive Cross-domain Policy with Untrusted Domains"
    technology:
    - "scala"
    primary_identifier: "find_sec_bugs.PERMISSIVE_CORS"
    secondary_identifiers:
    - name: "Find Security Bugs-PERMISSIVE_CORS"
      type: "find_sec_bugs_type"
      value: "PERMISSIVE_CORS"
  pattern-either:
  - patterns:
    - pattern-either:
      - pattern: "($RESP:javax.servlet.http.HttpServletResponse).setHeader(\"$HEADER\",
          \"$VAL\")"
      - pattern: "($RESP:javax.servlet.http.HttpServletResponse).addHeader(\"$HEADER\",
          \"$VAL\")"
    - metavariable-regex:
        metavariable: "$HEADER"
        regex: "(?i)(Access-Control-Allow-Origin)"
    - metavariable-regex:
        metavariable: "$VAL"
        regex: "(\\*|null)"
  - patterns:
    - pattern-inside: |
        $REQVAL = ($REQ: javax.servlet.http.HttpServletRequest).getParameter(...)
        ...
    - pattern-either:
      - pattern-inside: |-
          ($RESP:javax.servlet.http.HttpServletResponse).setHeader("$HEADER", $REQVAL)
      - pattern-inside: |-
          ($RESP:javax.servlet.http.HttpServletResponse).addHeader("$HEADER", $REQVAL)
  - patterns:
    - pattern-either:
      - pattern-inside: |-
          ($RESP:javax.servlet.http.HttpServletResponse).setHeader("$HEADER",($REQ: javax.servlet.http.HttpServletRequest).getParameter(...))
      - pattern-inside: |-
          ($RESP:javax.servlet.http.HttpServletResponse).addHeader("$HEADER",($REQ: javax.servlet.http.HttpServletRequest).getParameter(...))
  severity: "ERROR"
- id: "find_sec_bugs_scala.PERMISSIVE_CORS-2"
  languages:
  - "java"
  message: |
    Prior to HTML5, Web browsers enforced the Same Origin Policy which ensures that in order for
    JavaScript to access the contents of a Web page, both the JavaScript and the Web page must
    originate from the same domain. Without the Same Origin Policy, a malicious website could serve
    up JavaScript that loads sensitive information from other websites using a client's
    credentials, cull through it, and communicate it back to the attacker. HTML5 makes it possible
    for JavaScript to access data across domains if a new HTTP header called
    Access-Control-Allow-Origin is defined. With this header, a Web server defines which other
    domains are allowed to access its domain using cross-origin requests. However, caution should
    be taken when defining the header because an overly permissive CORS policy will allow a
    malicious application to communicate with the victim application in an inappropriate way,
    leading to spoofing, data theft, relay and other attacks.
  metadata:
    category: "security"
    cwe: "CWE-942"
    shortDescription: "Permissive Cross-domain Policy with Untrusted Domains"
    technology:
    - "java"
    primary_identifier: "find_sec_bugs.PERMISSIVE_CORS-2"
    secondary_identifiers:
    - name: "Find Security Bugs-PERMISSIVE_CORS"
      type: "find_sec_bugs_type"
      value: "PERMISSIVE_CORS"
  mode: "taint"
  pattern-sinks:
  - patterns:
    - pattern-either:
      - pattern: "(HttpServletResponse $RES).setHeader(\"$HEADER\", ...)"
      - pattern: "(HttpServletResponse $RES).addHeader(\"$HEADER\", ...)"
    - metavariable-regex:
        metavariable: "$HEADER"
        regex: "(?i)(Access-Control-Allow-Origin)"
  pattern-sources:
  - pattern: "(HttpServletRequest $REQ).getParamater(...)"
  severity: "ERROR"
- id: "find_sec_bugs_scala.BLOWFISH_KEY_SIZE-1"
  languages:
  - "scala"
  message: |
    A small key size makes the ciphertext vulnerable to brute force attacks. At least 128 bits of
    entropy should be used when generating the key if use of Blowfish is required.
  metadata:
    category: "security"
    cwe: "CWE-326"
    shortDescription: "Inadequate Encryption Strength"
    technology:
    - "scala"
    primary_identifier: "find_sec_bugs.BLOWFISH_KEY_SIZE"
    secondary_identifiers:
    - name: "Find Security Bugs-BLOWFISH_KEY_SIZE"
      type: "find_sec_bugs_type"
      value: "BLOWFISH_KEY_SIZE"
  patterns:
  - pattern-inside: |
      $KEYGEN = javax.crypto.KeyGenerator.getInstance("Blowfish", ...);
      ...
      $KEYGEN.init($KEY_SIZE);
  - metavariable-comparison:
      comparison: "$KEY_SIZE < 128"
      metavariable: "$KEY_SIZE"
  severity: "WARNING"
- id: "find_sec_bugs_scala.DES_USAGE-1"
  languages:
  - "scala"
  message: |
    DES is considered strong ciphers for modern applications. Currently, NIST recommends the usage
    of AES block ciphers instead of DES.
  metadata:
    category: "security"
    cwe: "CWE-326"
    shortDescription: "Inadequate Encryption Strength"
    technology:
    - "scala"
    primary_identifier: "find_sec_bugs.DES_USAGE"
    secondary_identifiers:
    - name: "Find Security Bugs-DES_USAGE"
      type: "find_sec_bugs_type"
      value: "DES_USAGE"
  patterns:
  - pattern-inside: |-
      javax.crypto.Cipher.getInstance("$ALG")
  - metavariable-regex:
      metavariable: "$ALG"
      regex: "^(DES)/.*"
  severity: "WARNING"
- id: "find_sec_bugs_scala.TDES_USAGE-1"
  languages:
  - "scala"
  message: |
    Triple DES (also known as 3DES or DESede) is considered strong ciphers for modern
    applications. NIST recommends the usage of AES block ciphers instead of 3DES.
  metadata:
    category: "security"
    cwe: "CWE-326"
    shortDescription: "Inadequate Encryption Strength"
    technology:
    - "scala"
    primary_identifier: "find_sec_bugs.TDES_USAGE"
    secondary_identifiers:
    - name: "Find Security Bugs-TDES_USAGE"
      type: "find_sec_bugs_type"
      value: "TDES_USAGE"
  patterns:
  - pattern-inside: |-
      javax.crypto.Cipher.getInstance("$ALG")
  - metavariable-regex:
      metavariable: "$ALG"
      regex: "^(DESede)/.*"
  severity: "WARNING"
- id: "find_sec_bugs_scala.ECB_MODE-1"
  languages:
  - "scala"
  message: |
    An authentication cipher mode which provides better confidentiality of the encrypted data
    should be used instead of Electronic Code Book (ECB) mode, which does not provide good
    confidentiality. Specifically, ECB mode produces the same output for the same input each time.
    This allows an attacker to intercept and replay the data.
  metadata:
    category: "security"
    cwe: "CWE-326"
    shortDescription: "Inadequate Encryption Strength"
    technology:
    - "scala"
    primary_identifier: "find_sec_bugs.ECB_MODE"
    secondary_identifiers:
    - name: "Find Security Bugs-ECB_MODE"
      type: "find_sec_bugs_type"
      value: "ECB_MODE"
  patterns:
  - pattern-inside: |-
      javax.crypto.Cipher.getInstance("...")
  - pattern-regex: "(AES|DES(ede)?)(/ECB/*)"
  severity: "ERROR"
- id: "find_sec_bugs_scala.CIPHER_INTEGRITY-1"
  languages:
  - "scala"
  message: |
    The ciphertext produced is susceptible to alteration by an adversary. This mean that the
    cipher provides no way to detect that the data has been tampered with. If the ciphertext can be
    controlled by an attacker, it could be altered without detection.
  metadata:
    category: "security"
    cwe: "CWE-353"
    shortDescription: "Missing Support for Integrity Check"
    technology:
    - "scala"
    primary_identifier: "find_sec_bugs.CIPHER_INTEGRITY"
    secondary_identifiers:
    - name: "Find Security Bugs-CIPHER_INTEGRITY"
      type: "find_sec_bugs_type"
      value: "CIPHER_INTEGRITY"
  patterns:
  - pattern-inside: |-
      javax.crypto.Cipher.getInstance("...")
  - pattern-either:
    - pattern-regex: "(/CBC/PKCS5Padding)"
    - pattern-regex: "(AES|DES(ede)?)(/ECB/*)"
    - pattern-regex: "(AES|DES(ede)?)(/CBC/*)"
    - pattern-regex: "(AES|DES(ede)?)(/OFB/*)"
    - pattern-regex: "(AES|DES(ede)?)(/CTR/*)"
  - pattern-not-regex: ".*/(CCM|CWC|OCB|EAX|GCM)/.*"
  - pattern-not-regex: "^(RSA)/.*"
  - pattern-not-regex: "^(ECIES)$"
  severity: "ERROR"
- id: "find_sec_bugs_scala.PADDING_ORACLE-1"
  languages:
  - "scala"
  message: |
    This specific mode of CBC with PKCS5Padding is susceptible to padding oracle attacks. An
    adversary could potentially decrypt the message if the system exposed the difference between
    plaintext with invalid padding or valid padding. The distinction between valid and invalid
    padding is usually revealed through distinct error messages being returned for each condition.
  metadata:
    category: "security"
    cwe: "CWE-696"
    shortDescription: "Incorrect Behavior Order"
    technology:
    - "scala"
    primary_identifier: "find_sec_bugs.PADDING_ORACLE"
    secondary_identifiers:
    - name: "Find Security Bugs-PADDING_ORACLE"
      type: "find_sec_bugs_type"
      value: "PADDING_ORACLE"
  patterns:
  - pattern-inside: |-
      javax.crypto.Cipher.getInstance("...")
  - pattern-regex: "(/CBC/PKCS5Padding)"
  - pattern-not-regex: "^(RSA)/.*"
  - pattern-not-regex: "^(ECIES)$"
  severity: "ERROR"
- id: "find_sec_bugs_scala.CUSTOM_MESSAGE_DIGEST-1"
  languages:
  - "scala"
  message: |
    Implementing a custom MessageDigest is error-prone. National Institute of Standards and
    Technology(NIST) recommends the use of SHA-224, SHA-256, SHA-384, SHA-512, SHA-512/224, or
    SHA-512/256.
  metadata:
    category: "security"
    cwe: "CWE-327"
    shortDescription: "Use of a Broken or Risky Cryptographic Algorithm"
    technology:
    - "scala"
    primary_identifier: "find_sec_bugs.CUSTOM_MESSAGE_DIGEST"
    secondary_identifiers:
    - name: "Find Security Bugs-CUSTOM_MESSAGE_DIGEST"
      type: "find_sec_bugs_type"
      value: "CUSTOM_MESSAGE_DIGEST"
  patterns:
  - pattern: |
      class $CLAZZ extends java.security.MessageDigest(...) {
        ...
      }
  severity: "WARNING"
- id: "find_sec_bugs_scala.DEFAULT_HTTP_CLIENT-1"
  patterns:
  - pattern: "new org.apache.http.impl.client.DefaultHttpClient(...)"
  message: |
    DefaultHttpClient with default constructor is not compatible with TLS 1.2
  languages:
  - "scala"
  severity: "WARNING"
  metadata:
    shortDescription: "Inadequate encryption strength"
    category: "security"
    cwe: "CWE-326"
    technology:
    - "scala"
    primary_identifier: "find_sec_bugs.DEFAULT_HTTP_CLIENT"
    secondary_identifiers:
    - name: "Find Security Bugs-DEFAULT_HTTP_CLIENT"
      type: "find_sec_bugs_type"
      value: "DEFAULT_HTTP_CLIENT"
- id: "find_sec_bugs_scala.HAZELCAST_SYMMETRIC_ENCRYPTION-1"
  languages:
  - "scala"
  message: |
    The network communications for Hazelcast is configured to use a symmetric cipher (probably DES
    or Blowfish). Those ciphers alone do not provide integrity or secure authentication. The use of
    asymmetric encryption is preferred.
  metadata:
    category: "security"
    cwe: "CWE-326"
    shortDescription: "Inadequate Encryption Strength"
    technology:
    - "scala"
    primary_identifier: "find_sec_bugs.HAZELCAST_SYMMETRIC_ENCRYPTION"
    secondary_identifiers:
    - name: "Find Security Bugs-HAZELCAST_SYMMETRIC_ENCRYPTION"
      type: "find_sec_bugs_type"
      value: "HAZELCAST_SYMMETRIC_ENCRYPTION"
  patterns:
  - pattern: "new com.hazelcast.config.SymmetricEncryptionConfig()"
  severity: "WARNING"
- id: "find_sec_bugs_scala.RSA_KEY_SIZE-1"
  languages:
  - "scala"
  message: |
    Detected an insufficient key size for DSA. NIST recommends a key size
    of 2048 or higher.
  metadata:
    category: "security"
    cwe: "CWE-326"
    shortDescription: "Inadequate Encryption Strength"
    primary_identifier: "find_sec_bugs.RSA_KEY_SIZE"
    secondary_identifiers:
    - name: "Find Security Bugs-RSA_KEY_SIZE"
      type: "find_sec_bugs_type"
      value: "RSA_KEY_SIZE"
  patterns:
  - pattern-either:
    - patterns:
      - pattern-inside: |
          $GEN = KeyPairGenerator.getInstance($ALG, ...);
          ...
      - pattern-either:
        - pattern: "$VAR.initialize($SIZE, ...)"
        - pattern: "new java.security.spec.RSAKeyGenParameterSpec($SIZE, ...)"
      - metavariable-comparison:
          comparison: "$SIZE < 2048"
          metavariable: "$SIZE"
      - metavariable-regex:
          metavariable: "$ALG"
          regex: "\"(RSA|DSA)\""
  severity: "WARNING"
- id: "find_sec_bugs_scala.NULL_CIPHER-1"
  languages:
  - "scala"
  message: |
    The NullCipher implements the Cipher interface by returning ciphertext identical to the
    supplied plaintext. In a few contexts, such as testing, a NullCipher may be appropriate. Avoid
    using the NullCipher. Its accidental use can introduce a significant confidentiality risk.
  metadata:
    category: "security"
    cwe: "CWE-327"
    shortDescription: "Use of a Broken or Risky Cryptographic Algorithm"
    technology:
    - "scala"
    primary_identifier: "find_sec_bugs.NULL_CIPHER"
    secondary_identifiers:
    - name: "Find Security Bugs-NULL_CIPHER"
      type: "find_sec_bugs_type"
      value: "NULL_CIPHER"
  pattern: "new javax.crypto.NullCipher()"
  severity: "WARNING"
- id: "find_sec_bugs_scala.RSA_NO_PADDING-1"
  languages:
  - "scala"
  message: |
    The software uses the RSA algorithm but does not incorporate Optimal Asymmetric
    Encryption Padding (OAEP), which might weaken the encryption.
  metadata:
    cwe: "CWE-780"
    shortDescription: "Use of RSA Algorithm without OAEP"
    primary_identifier: "find_sec_bugs.RSA_NO_PADDING"
    secondary_identifiers:
    - name: "Find Security Bugs-RSA_NO_PADDING"
      type: "find_sec_bugs_type"
      value: "RSA_NO_PADDING"
  patterns:
  - pattern: "javax.crypto.Cipher.getInstance(\"$ALG\",...)"
  - metavariable-regex:
      metavariable: "$ALG"
      regex: ".*NoPadding.*"
  severity: "WARNING"
- id: "find_sec_bugs_scala.WEAK_MESSAGE_DIGEST_MD5-1.WEAK_MESSAGE_DIGEST_SHA1-1"
  languages:
  - "scala"
  message: |
    DES is considered strong ciphers for modern applications. Currently, NIST recommends the usage
    of AES block ciphers instead of DES.
  metadata:
    category: "security"
    cwe: "CWE-326"
    shortDescription: "Inadequate Encryption Strength"
    technology:
    - "scala"
    primary_identifier: "find_sec_bugs.WEAK_MESSAGE_DIGEST_MD5-1.WEAK_MESSAGE_DIGEST_SHA1-1"
    secondary_identifiers:
    - name: "Find Security Bugs-WEAK_MESSAGE_DIGEST_MD5"
      type: "find_sec_bugs_type"
      value: "WEAK_MESSAGE_DIGEST_MD5"
    - name: "Find Security Bugs-WEAK_MESSAGE_DIGEST_SHA1"
      type: "find_sec_bugs_type"
      value: "WEAK_MESSAGE_DIGEST_SHA1"
  patterns:
  - pattern-either:
    - pattern: "MessageDigest.getInstance(\"$ALG\", ...)"
    - pattern: "Signature.getInstance(\"$ALG\", ...)"
  - metavariable-regex:
      metavariable: "$ALG"
      regex: "(.*(MD5|MD4|MD2|SHA1|SHA-1).*)"
  severity: "WARNING"
- id: "find_sec_bugs_scala.SSL_CONTEXT-1"
  languages:
  - "scala"
  message: |
    A HostnameVerifier that accept any host are often use because of certificate
    reuse on many hosts. As a consequence, this is vulnerable to Man-in-the-middleattacks
    attacks since the client will trust any certificate.
  metadata:
    category: "security"
    cwe: "CWE-295"
    shortDescription: "Improper Certificate Validation"
    primary_identifier: "find_sec_bugs.SSL_CONTEXT"
    secondary_identifiers:
    - name: "Find Security Bugs-SSL_CONTEXT"
      type: "find_sec_bugs_type"
      value: "SSL_CONTEXT"
  patterns:
  - pattern-either:
    - pattern: "new org.apache.http.impl.client.DefaultHttpClient()"
    - pattern: "javax.net.ssl.SSLContext.getInstance(\"SSL\")"
    - patterns:
      - pattern-inside: |
          import javax.net.ssl._
          ...
      - pattern: "SSLContext.getInstance(\"SSL\")"
  severity: "WARNING"
- id: "find_sec_bugs_scala.SERVLET_PARAMETER-1.SERVLET_CONTENT_TYPE-1.SERVLET_SERVER_NAME-1.SERVLET_SESSION_ID-1.SERVLET_QUERY_STRING-1.SERVLET_HEADER-1.SERVLET_HEADER_REFERER-1.SERVLET_HEADER_USER_AGENT-1"
  languages:
  - "scala"
  message: |
    The Servlet can read GET and POST parameters from various methods. The
    value obtained should be considered unsafe."
  metadata:
    category: "security"
    cwe: "CWE-20"
    shortDescription: "Improper Input Validation"
    primary_identifier: "find_sec_bugs.SERVLET_PARAMETER-1.SERVLET_CONTENT_TYPE-1.SERVLET_SERVER_NAME-1.SERVLET_SESSION_ID-1.SERVLET_QUERY_STRING-1.SERVLET_HEADER-1.SERVLET_HEADER_REFERER-1.SERVLET_HEADER_USER_AGENT-1"
    secondary_identifiers:
    - name: "Find Security Bugs-SERVLET_PARAMETER"
      type: "find_sec_bugs_type"
      value: "SERVLET_PARAMETER"
    - name: "Find Security Bugs-SERVLET_CONTENT_TYPE"
      type: "find_sec_bugs_type"
      value: "SERVLET_CONTENT_TYPE"
    - name: "Find Security Bugs-SERVLET_SERVER_NAME"
      type: "find_sec_bugs_type"
      value: "SERVLET_SERVER_NAME"
    - name: "Find Security Bugs-SERVLET_SESSION_ID"
      type: "find_sec_bugs_type"
      value: "SERVLET_SESSION_ID"
    - name: "Find Security Bugs-SERVLET_QUERY_STRING"
      type: "find_sec_bugs_type"
      value: "SERVLET_QUERY_STRING"
    - name: "Find Security Bugs-SERVLET_HEADER"
      type: "find_sec_bugs_type"
      value: "SERVLET_HEADER"
    - name: "Find Security Bugs-SERVLET_HEADER_REFERER"
      type: "find_sec_bugs_type"
      value: "SERVLET_HEADER_REFERER"
    - name: "Find Security Bugs-SERVLET_HEADER_USER_AGENT"
      type: "find_sec_bugs_type"
      value: "SERVLET_HEADER_USER_AGENT"
  mode: "taint"
  pattern-sanitizers:
  - pattern: "Encode.forHtml(...)"
  - pattern: "org.owasp.esapi.Encoder.encodeForSQL(...)"
  pattern-sinks:
  - patterns:
    - pattern-either:
      - pattern: |
          ... + $PAR
      - pattern: |
          ... + $PAR + ...
      - pattern: |
          $PAR + ...
    - pattern: "$PAR"
  pattern-sources:
  - pattern-either:
    - pattern: "($REQ: HttpServletRequest).getContentType"
    - pattern: "($REQ: HttpServletRequest).getServerName"
    - pattern: "($REQ: HttpServletRequest).getRequestedSessionId"
    - pattern: "($REQ: HttpServletRequest).getParameterValues(...)"
    - pattern: "($REQ: HttpServletRequest).getParameterMap"
    - pattern: "($REQ: HttpServletRequest).getParameterNames"
    - pattern: "($REQ: HttpServletRequest).getParameter(...)"
    - patterns:
      - pattern-inside: |
          ($REQ: HttpServletRequest).getSession
      - pattern: "$SESS.getAttribute(\"...\")"
    - pattern: |
        ($REQ: HttpServletRequest).getSession.getAttribute("...")
  severity: "WARNING"
- id: "find_sec_bugs_scala.JAXRS_ENDPOINT-1"
  languages:
  - "scala"
  message: |
    This method is part of a REST Web Service (JSR311). The security of this web service should be
    analyzed. For example:
    - Authentication, if enforced, should be tested.
    - Access control, if enforced, should be tested.
    - The inputs should be tracked for potential vulnerabilities.
    - The communication should ideally be over SSL.
    - If the service supports writes (e.g., via POST), its vulnerability to CSRF should be
    investigated.
  metadata:
    category: "security"
    cwe: "CWE-20"
    shortDescription: "Improper Input Validation"
    technology:
    - "scala"
    primary_identifier: "find_sec_bugs.JAXRS_ENDPOINT"
    secondary_identifiers:
    - name: "Find Security Bugs-JAXRS_ENDPOINT"
      type: "find_sec_bugs_type"
      value: "JAXRS_ENDPOINT"
  mode: "taint"
  pattern-sinks:
  - pattern: "<...$VAR...>"
  pattern-sources:
  - patterns:
    - pattern-inside: |
        @javax.ws.rs.Path("...")
        def $FUNC(..., $VAR: $TYPE, ...) = ...
    - pattern: "$VAR"
  severity: "INFO"
- id: "find_sec_bugs_scala.JAXWS_ENDPOINT-1"
  languages:
  - "scala"
  message: |
    This method is part of a SOAP Web Service (JSR224). The security of this web service should be
    analyzed. For example:
    - Authentication, if enforced, should be tested.
    - Access control, if enforced, should be tested.
    - The inputs should be tracked for potential vulnerabilities.
    - The communication should ideally be over SSL.
  metadata:
    category: "security"
    cwe: "CWE-20"
    owasp: "A7:2017-Cross-Site Scripting (XSS)"
    shortDescription: "Improper Input Validation"
    technology:
    - "scala"
    primary_identifier: "find_sec_bugs.JAXWS_ENDPOINT"
    secondary_identifiers:
    - name: "Find Security Bugs-JAXWS_ENDPOINT"
      type: "find_sec_bugs_type"
      value: "JAXWS_ENDPOINT"
  mode: "taint"
  pattern-sinks:
  - pattern: "<...$VAR...>"
  pattern-sources:
  - patterns:
    - pattern-inside: |
        @javax.jws.WebMethod(...)
        def $FUNC(..., $VAR: $TYPE, ...) = ...
    - pattern: "$VAR"
  severity: "INFO"
- id: "find_sec_bugs_scala.UNENCRYPTED_SOCKET-1.UNENCRYPTED_SERVER_SOCKET-1"
  languages:
  - "scala"
  message: |
    Beyond using an SSL socket, you need to make sure your use of SSLSocketFactory
    does all the appropriate certificate validation checks to make sure you are not
    subject to man-in-the-middle attacks. Please read the OWASP Transport Layer
    Protection Cheat Sheet for details on how to do this correctly.
  metadata:
    cwe: "CWE-319"
    shortDescription: "Cleartext Transmission of Sensitive Information"
    primary_identifier: "find_sec_bugs.UNENCRYPTED_SOCKET-1.UNENCRYPTED_SERVER_SOCKET-1"
    secondary_identifiers:
    - name: "Find Security Bugs-UNENCRYPTED_SOCKET"
      type: "find_sec_bugs_type"
      value: "UNENCRYPTED_SOCKET"
    - name: "Find Security Bugs-UNENCRYPTED_SERVER_SOCKET"
      type: "find_sec_bugs_type"
      value: "UNENCRYPTED_SERVER_SOCKET"
  patterns:
  - pattern: "new java.net.Socket(...)"
  severity: "WARNING"
- id: "find_sec_bugs_scala.UNVALIDATED_REDIRECT-1.URL_REWRITING-1"
  languages:
  - "scala"
  message: |
    Unvalidated redirects occur when an application redirects a user to a
    destination URL specified by a user supplied parameter that is not validated.
    Such vulnerabilities can be used to facilitate phishing attacks.
  metadata:
    category: "security"
    cwe: "CWE-601"
    shortDescription: "URL Redirection to Untrusted Site ('Open Redirect')"
    primary_identifier: "find_sec_bugs.UNVALIDATED_REDIRECT-1.URL_REWRITING-1"
    secondary_identifiers:
    - name: "Find Security Bugs-UNVALIDATED_REDIRECT"
      type: "find_sec_bugs_type"
      value: "UNVALIDATED_REDIRECT"
    - name: "Find Security Bugs-URL_REWRITING"
      type: "find_sec_bugs_type"
      value: "URL_REWRITING"
  patterns:
  - pattern-either:
    - patterns:
      - pattern: "($REQ: HttpServletResponse).sendRedirect(...)"
      - pattern-not: "($REQ: HttpServletResponse).sendRedirect(\"...\")"
    - patterns:
      - pattern: "($REQ: HttpServletResponse).addHeader(...)"
      - pattern-not: "($REQ: HttpServletResponse).addHeader(\"...\", \"...\")"
    - patterns:
      - pattern: "($REQ: HttpServletResponse).encodeURL(...)"
      - pattern-not: "($REQ: HttpServletResponse).encodeURL(\"...\")"
    - patterns:
      - pattern: "($REQ: HttpServletResponse).encodeRedirectUrl(...)"
      - pattern-not: "($REQ: HttpServletResponse).encodeRedirectUrl(\"...\")"
  severity: "ERROR"
- id: "find_sec_bugs_scala.WEAK_HOSTNAME_VERIFIER-1.WEAK_TRUST_MANAGER-1"
  languages:
  - "scala"
  message: |
    A HostnameVerifier that accept any host are often use because of certificate
    reuse on many hosts. As a consequence, this is vulnerable to Man-in-the-middle
    attacks since the client will trust any certificate.
  metadata:
    category: "security"
    cwe: "CWE-295"
    shortDescription: "Improper Certificate Validation"
    primary_identifier: "find_sec_bugs.WEAK_HOSTNAME_VERIFIER-1.WEAK_TRUST_MANAGER-1"
    secondary_identifiers:
    - name: "Find Security Bugs-WEAK_HOSTNAME_VERIFIER"
      type: "find_sec_bugs_type"
      value: "WEAK_HOSTNAME_VERIFIER"
    - name: "Find Security Bugs-WEAK_TRUST_MANAGER"
      type: "find_sec_bugs_type"
      value: "WEAK_TRUST_MANAGER"
  patterns:
  - pattern-either:
    - patterns:
      - pattern-inside: |
          class $V extends HostnameVerifier {
            ...
          }
      - pattern-either:
        - pattern: "def verify(...) = true"
        - pattern: |
            def verify(...) = {
              return true
            }
    - patterns:
      - pattern-inside: |
          class $V extends X509TrustManager {
            ...
          }
      - pattern-either:
        - pattern: "def checkClientTrusted(...): Unit = {}"
        - pattern: "def checkServerTrusted(...): Unit = {}"
        - pattern: "def checkClientTrusted(...) = {}"
        - pattern: "def checkServerTrusted(...) = {}"
        - pattern: "def getAcceptedIssuers(): Array[X509Certificate] = null"
        - pattern: "def getAcceptedIssuers(): Array[X509Certificate] = {}"
  severity: "WARNING"
- id: "find_sec_bugs_scala.FILE_UPLOAD_FILENAME-1"
  languages:
  - "scala"
  message: |
    The filename provided by the FileUpload API can be tampered with by the client to reference
    unauthorized files. The provided filename should be properly validated to ensure it's properly
    structured, contains no unauthorized path characters (e.g., / \), and refers to an authorized
    file.
  metadata:
    category: "security"
    cwe: "CWE-22"
    shortDescription: "Improper Limitation of a Pathname to a Restricted Directory
      ('Path Traversal')"
    technology:
    - "scala"
    primary_identifier: "find_sec_bugs.FILE_UPLOAD_FILENAME"
    secondary_identifiers:
    - name: "Find Security Bugs-FILE_UPLOAD_FILENAME"
      type: "find_sec_bugs_type"
      value: "FILE_UPLOAD_FILENAME"
  patterns:
  - pattern: |
      def $FUNC (..., $REQ: HttpServletRequest, ... ) = {
        ...
        val $FILES = ($SFU: ServletFileUpload).parseRequest($REQ)
        ...
        for ($FILE <- $FILES.asScala) {
          ...
        }
      }
  - pattern: "$ITEM.getName()"
  severity: "ERROR"
- id: "find_sec_bugs_scala.WEAK_FILENAMEUTILS-1"
  languages:
  - "scala"
  message: |
    A file is opened to read its content. The filename comes from an input
    parameter. If an unfiltered parameter is passed to this file API, files from an
    arbitrary filesystem location could be read.
  metadata:
    category: "security"
    cwe: "CWE-22"
    shortDescription: "Improper Limitation of a Pathname to a Restricted Directory
      ('Path Traversal')"
    technology:
    - "scala"
    primary_identifier: "find_sec_bugs.WEAK_FILENAMEUTILS"
    secondary_identifiers:
    - name: "Find Security Bugs-WEAK_FILENAMEUTILS"
      type: "find_sec_bugs_type"
      value: "WEAK_FILENAMEUTILS"
  pattern-either:
  - patterns:
    - pattern-inside: |
        import org.apache.commons.io.FilenameUtils._
        ...
    - pattern-either:
      - pattern: "normalize(...)"
      - pattern: "getExtension(...)"
      - pattern: "isExtensions(...)"
      - pattern: "isExtension(...)"
      - pattern: "getName(...)"
      - pattern: "getBaseName(...)"
  - patterns:
    - pattern-either:
      - pattern: "org.apache.commons.io.FilenameUtils.normalize(...)"
      - pattern: "org.apache.commons.io.FilenameUtils.getExtension(...)"
      - pattern: "org.apache.commons.io.FilenameUtils.isExtensions(...)"
      - pattern: "org.apache.commons.io.FilenameUtils.isExtension(...)"
      - pattern: "org.apache.commons.io.FilenameUtils.getName(...)"
      - pattern: "org.apache.commons.io.FilenameUtils.getBaseName(...)"
  severity: "ERROR"
- id: "find_sec_bugs_scala.STRUTS_FORM_VALIDATION-1"
  languages:
  - "scala"
  message: |
    Form inputs should have minimal input validation. Preventive validation helps provide defense
    in depth against a variety of risks.
  metadata:
    category: "security"
    cwe: "CWE-20"
    shortDescription: "Improper Input Validation"
    primary_identifier: "find_sec_bugs.STRUTS_FORM_VALIDATION"
    secondary_identifiers:
    - name: "Find Security Bugs-STRUTS_FORM_VALIDATION"
      type: "find_sec_bugs_type"
      value: "STRUTS_FORM_VALIDATION"
  patterns:
  - pattern-inside: |
      class $CLASS extends $SC {
        ...
      }
  - metavariable-regex:
      metavariable: "$SC"
      regex: "(ActionForm|ValidatorForm)"
  - pattern-not: "public void validate() { ... }"
  severity: "WARNING"
- id: "find_sec_bugs_scala.AWS_QUERY_INJECTION-1"
  languages:
  - "scala"
  message: |
    Constructing SimpleDB queries containing user input can allow an attacker to view unauthorized
    records.
  metadata:
    category: "security"
    cwe: "CWE-943"
    shortDescription: "Improper Neutralization of Special Elements in Data Query Logic"
    technology:
    - "scala"
    primary_identifier: "find_sec_bugs.AWS_QUERY_INJECTION"
    secondary_identifiers:
    - name: "Find Security Bugs-AWS_QUERY_INJECTION"
      type: "find_sec_bugs_type"
      value: "AWS_QUERY_INJECTION"
  mode: "taint"
  pattern-sinks:
  - pattern: "new com.amazonaws.services.simpledb.model.SelectRequest($QUERY, ...);"
  - patterns:
    - pattern-inside: |
        $DB.select(($SR: com.amazonaws.services.simpledb.model.SelectRequest).withSelectExpression($QUERY,...));
    - pattern: "$QUERY"
    - metavariable-pattern:
        metavariable: "$DB"
        pattern-either:
        - pattern: "($DB: com.amazonaws.services.simpledb.AmazonSimpleDB)"
        - pattern: "($DB: com.amazonaws.services.simpledb.AmazonSimpleDBClient)"
  pattern-sources:
  - patterns:
    - pattern-inside: |
        def $FUNC(..., $REQ: HttpServletRequest, ...): $TYPE = {
          ...
        }
    - pattern: "$REQ"
  - patterns:
    - pattern-inside: |
        def $FUNC(..., $X: $TYPE, ...): $RET_TYPE = {
          ...
          $QUERY = <...$X...>
          ...
        }
    - pattern: "$QUERY"
  severity: "ERROR"
- id: "find_sec_bugs_scala.BEAN_PROPERTY_INJECTION-1"
  languages:
  - "scala"
  message: |
    An attacker can set arbitrary bean properties that can compromise system integrity. An
    attacker can leverage this functionality to access special bean properties like
    class.classLoader that will allow them to override system properties and potentially execute
    arbitrary code.
  metadata:
    category: "security"
    cwe: "CWE-15"
    shortDescription: "External Control of System or Configuration Setting"
    technology:
    - "scala"
    primary_identifier: "find_sec_bugs.BEAN_PROPERTY_INJECTION"
    secondary_identifiers:
    - name: "Find Security Bugs-BEAN_PROPERTY_INJECTION"
      type: "find_sec_bugs_type"
      value: "BEAN_PROPERTY_INJECTION"
  patterns:
  - pattern-inside: |-
      def $FUNC(..., $REQ: HttpServletRequest, ...): $TYPE = { ... }
  - pattern-either:
    - pattern: |
        $MAP.put(..., $REQ.getParameter(...))
        ...
        $BEAN_UTIL.populate(..., $MAP)
    - pattern: |
        while (...) {
            ...
            $MAP.put(..., $REQ.getParameterValues(...). ...)
        }
        ...
        $BEAN_UTIL.populate(..., $MAP)
  - metavariable-pattern:
      metavariable: "$BEAN_UTIL"
      pattern-either:
      - pattern: "(BeanUtilsBean $B)"
      - pattern: "new BeanUtilsBean()"
      - pattern: "org.apache.commons.beanutils.BeanUtils"
  severity: "ERROR"
- id: "find_sec_bugs_scala.CRLF_INJECTION_LOGS-1"
  languages:
  - "scala"
  message: |
    When data from an untrusted source is put into a logger and not neutralized correctly, an
    attacker could forge log entries or include malicious content. Inserted false entries could be
    used to skew statistics, distract the administrator or even to implicate another party in the
    commission of a malicious act. If the log file is processed automatically, the attacker can
    render the file unusable by corrupting the format of the file or injecting unexpected
    characters. An attacker may also inject code or other commands into the log file and take
    advantage of a vulnerability in the log processing utility (e.g. command injection or XSS).
  metadata:
    category: "security"
    cwe: "CWE-93"
    shortDescription: "Improper Neutralization of CRLF Sequences ('CRLF Injection')"
    technology:
    - "scala"
    primary_identifier: "find_sec_bugs.CRLF_INJECTION_LOGS"
    secondary_identifiers:
    - name: "Find Security Bugs-CRLF_INJECTION_LOGS"
      type: "find_sec_bugs_type"
      value: "CRLF_INJECTION_LOGS"
  mode: "taint"
  pattern-sanitizers:
  - patterns:
    - pattern-inside: |-
        $STR.replaceAll("$REPLACE_CHAR", "$REPLACE");
    - pattern: "$STR"
    - metavariable-regex:
        metavariable: "$REPLACE_CHAR"
        regex: "(.*\\\\r\\\\n.*)"
    - metavariable-regex:
        metavariable: "$REPLACE"
        regex: "(?!(\\\\r\\\\n))"
  - pattern: "org.owasp.encoder.Encode.forUriComponent(...)"
  - pattern: "org.owasp.encoder.Encode.forUri(...)"
  - pattern: "java.net.URLEncoder.encode(..., $CHARSET)"
  pattern-sinks:
  - patterns:
    - patterns:
      - pattern: "$LOGGER.$METHOD(...,<...$TAINTED...>,...)"
      - focus-metavariable: "$TAINTED"
    - metavariable-regex:
        metavariable: "$METHOD"
        regex: "(log|logp|logrb|entering|exiting|fine|finer|finest|info|debug|trace|warn|warning|config|error|severe)"
    - metavariable-pattern:
        metavariable: "$LOGGER"
        pattern-either:
        - pattern: "Logger"
        - pattern: "log"
        - pattern: "logger"
        - pattern: "org.pmw.tinylog.Logger"
        - pattern: "org.apache.log4j.Logger"
        - pattern: "org.apache.logging.log4j.Logger"
        - pattern: "org.slf4j.Logger"
        - pattern: "org.apache.commons.logging.Log"
        - pattern: "java.util.logging.Logger"
  pattern-sources:
  - patterns:
    - pattern-inside: |
        def $FUNC(..., $REQ: HttpServletRequest, ...) : $TYPE = {
          ...
        }
    - pattern: "$REQ.getParameter(...)"
  severity: "ERROR"
- id: "find_sec_bugs_scala.COMMAND_INJECTION-1.SCALA_COMMAND_INJECTION-1"
  languages:
  - "scala"
  message: |
    The highlighted API is used to execute a system command. If unfiltered input is passed to this
    API, it can lead to arbitrary command execution.
  metadata:
    category: "security"
    cwe: "CWE-78"
    shortDescription: "Improper Neutralization of Special Elements used in an OS Command
      ('OS Command Injection')"
    technology:
    - "scala"
    primary_identifier: "find_sec_bugs.COMMAND_INJECTION-1.SCALA_COMMAND_INJECTION-1"
    secondary_identifiers:
    - name: "Find Security Bugs-COMMAND_INJECTION"
      type: "find_sec_bugs_type"
      value: "COMMAND_INJECTION"
    - name: "Find Security Bugs-SCALA_COMMAND_INJECTION"
      type: "find_sec_bugs_type"
      value: "SCALA_COMMAND_INJECTION"
  pattern-either:
  - patterns:
    - pattern-inside: |
        def $FUNC(..., $PARAM: String, ...): $TYPE = {
          ...
        }
    - pattern-inside: |
        val $RT = Runtime.getRuntime
        ...
    - pattern-either:
      - pattern: "$RT.exec($PARAM)"
      - pattern: |
          var $CMDARR = new Array[String]("$SHELL",...,$PARAM,...)
          ...
          $RT.exec($CMDARR,...)
      - pattern: "$RT.exec(Array[String](\"$SHELL\",...,$PARAM,...), ...)"
      - pattern: "$RT.exec(java.util.String.format(\"...\", ...,$PARAM,...))"
      - pattern: "$RT.exec(($A: String) + ($B: String))"
    - metavariable-regex:
        metavariable: "$SHELL"
        regex: "(/.../)?(sh|bash|ksh|csh|tcsh|zsh)$"
    - pattern-not: "$RT.exec(\"...\",\"...\",\"...\",...)"
    - pattern-not: "$RT.exec(new Array[String](\"...\",\"...\",\"...\",...),...)"
  - patterns:
    - pattern-inside: |
        def $FUNC(...,$PARAM: String, ...): $TYPE = {
          ...
        }
    - pattern-inside: |
        val $PB = new ProcessBuilder()
        ...
    - pattern-either:
      - pattern: "$PB.command($PARAM,...)"
      - patterns:
        - pattern-either:
          - pattern: "$PB.command(\"$SHELL\",...,$PARAM,...)"
          - pattern: |
              var $CMDARR = java.util.Arrays.asList("$SHELL",...,$PARAM,...)
              ...
              $PB.command($CMDARR,...)
          - pattern: "$PB.command(java.util.Arrays.asList(\"$SHELL\",...,$PARAM,...),...)"
          - pattern: "$PB.command(java.util.String.format(\"...\", ...,$PARAM,...))"
          - pattern: "$PB.command(($A: String) + ($B: String))"
        - metavariable-regex:
            metavariable: "$SHELL"
            regex: "(/.../)?(sh|bash|ksh|csh|tcsh|zsh)$"
    - pattern-not: "$PB.command(\"...\",\"...\",\"...\",...)"
    - pattern-not: |
        $PB.command(java.util.Arrays.asList("...","...","...",...))
  severity: "WARNING"
- id: "find_sec_bugs_scala.CUSTOM_INJECTION-1"
  languages:
  - "scala"
  message: |
    The method identified is susceptible to injection. The input should be validated and properly
    escaped.
  metadata:
    category: "security"
    cwe: "CWE-89"
    shortDescription: "Improper Neutralization of Special Elements used in an SQL
      Command ('SQL Injection')"
    technology:
    - "scala"
    primary_identifier: "find_sec_bugs.CUSTOM_INJECTION"
    secondary_identifiers:
    - name: "Find Security Bugs-CUSTOM_INJECTION"
      type: "find_sec_bugs_type"
      value: "CUSTOM_INJECTION"
  patterns:
  - pattern-either:
    - pattern-inside: |
        val $ST = connection.createStatement
        ...
  - pattern-either:
    - pattern: |
        val $QUERY = ... + $VAR + ...
        ...
        $ST.executeQuery($QUERY)
    - pattern: |
        val $QUERY = ... + $VAR
        ...
        $ST.executeQuery($QUERY)
    - pattern: |
        val $QUERY = String.format("...",...,$VAR,...)
        ...
        $ST.executeQuery($QUERY)
    - pattern: "$ST.executeQuery(($SB: StringBuilder).toString())"
    - pattern: "$ST.executeQuery(... + $VAR + ...)"
    - pattern: "$ST.executeQuery(... + $VAR)"
    - pattern: "$ST.executeQuery(...,String.format(\"...\",...,$VAR,...), ...)"
  severity: "WARNING"
- id: "find_sec_bugs_scala.CUSTOM_INJECTION-2"
  languages:
  - "scala"
  message: |
    The method identified is susceptible to injection. The input should be validated and properly
    escaped.
  metadata:
    category: "security"
    cwe: "CWE-89"
    shortDescription: "Improper Neutralization of Special Elements used in an SQL
      Command ('SQL Injection')"
    technology:
    - "scala"
    primary_identifier: "find_sec_bugs.CUSTOM_INJECTION-2"
    secondary_identifiers:
    - name: "Find Security Bugs-CUSTOM_INJECTION"
      type: "find_sec_bugs_type"
      value: "CUSTOM_INJECTION"
  patterns:
  - pattern-inside: |
      def $FOO(..., $SQLIN: String, ...): $TYPE = {
        ...
      }
  - pattern-either:
    - pattern: |
        "$SQL_STR" + $SQLIN
    - pattern: "String.format(\"$SQL_STR\", ... + $SQLIN + ...)"
    - pattern: |
        "$SQL_STR".concat(...)
    - pattern: "(StringBuilder $BUILDER). ... .append(\"$SQL_STR\")"
    - patterns:
      - pattern-inside: |
          StringBuilder $BUILDER = new StringBuilder(... + "$SQL_STR" + ...);
          ...
      - pattern: "$BUILDER.append(...)"
      - pattern-not: "$BUILDER.append(\"...\")"
    - patterns:
      - pattern-inside: |
          $QUERY = "$SQL_STR";
          ...
      - pattern: "$QUERY += ..."
  - metavariable-regex:
      metavariable: "$SQL_STR"
      regex: "(?i)(select|insert|create|update|alter|delete|drop)\\b"
  severity: "WARNING"
- id: "find_sec_bugs_scala.EL_INJECTION-1"
  languages:
  - "scala"
  message: |
    An expression is built with a dynamic value. The source of the value(s) should be verified to
    avoid that unfiltered values fall into this risky code evaluation.
  metadata:
    category: "security"
    cwe: "CWE-94"
    shortDescription: "Improper Control of Generation of Code ('Code Injection')"
    technology:
    - "scala"
    primary_identifier: "find_sec_bugs.EL_INJECTION"
    secondary_identifiers:
    - name: "Find Security Bugs-EL_INJECTION"
      type: "find_sec_bugs_type"
      value: "EL_INJECTION"
  patterns:
  - pattern-inside: |
      import javax.el._
      ...
  - pattern-either:
    - pattern-inside: |
        def $FUNC(..., $EXPR: String, ...) : $TYPE = {
          ...
        }
    - pattern-inside: |
        def $FUNC(..., $EXPR: String, ...) = {
          ...
        }
  - pattern-either:
    - pattern: "$X.createValueExpression(..., $EXPR, ...)"
    - pattern: "$X.createMethodExpression(..., $EXPR, ...)"
  severity: "WARNING"
- id: "find_sec_bugs_scala.REQUESTDISPATCHER_FILE_DISCLOSURE-1.STRUTS_FILE_DISCLOSURE-1.SPRING_FILE_DISCLOSURE-1"
  languages:
  - "scala"
  message: |
    Constructing a server-side redirect path with user input could allow an
    attacker to download application binaries (including application classes or
    jar files) or view arbitrary files within protected directories.
  metadata:
    category: "security"
    cwe: "CWE-552"
    shortDescription: "Files or Directories Accessible to External Parties"
    primary_identifier: "find_sec_bugs.REQUESTDISPATCHER_FILE_DISCLOSURE-1.STRUTS_FILE_DISCLOSURE-1.SPRING_FILE_DISCLOSURE-1"
    secondary_identifiers:
    - name: "Find Security Bugs-REQUESTDISPATCHER_FILE_DISCLOSURE"
      type: "find_sec_bugs_type"
      value: "REQUESTDISPATCHER_FILE_DISCLOSURE"
    - name: "Find Security Bugs-STRUTS_FILE_DISCLOSURE"
      type: "find_sec_bugs_type"
      value: "STRUTS_FILE_DISCLOSURE"
    - name: "Find Security Bugs-SPRING_FILE_DISCLOSURE"
      type: "find_sec_bugs_type"
      value: "SPRING_FILE_DISCLOSURE"
  mode: "taint"
  pattern-sinks:
  - patterns:
    - pattern: "new org.springframework.web.servlet.ModelAndView($FST)"
    - pattern: "$FST"
  - patterns:
    - pattern: "new org.springframework.web.servlet.ModelAndView($FST, $SND)"
    - pattern: "$FST"
  - patterns:
    - pattern: "new org.springframework.web.servlet.ModelAndView($FST, $SND, $TRD)"
    - pattern: "$FST"
  - patterns:
    - pattern: "new org.apache.struts.action.ActionForward($FST)"
    - pattern: "$FST"
  - patterns:
    - pattern: "new org.apache.struts.action.ActionForward($FST, $SND)"
    - pattern: "$FST"
  - patterns:
    - pattern: "new org.apache.struts.action.ActionForward($FST, $SND, $TRD)"
    - pattern: "$SND"
  - patterns:
    - pattern: "new org.apache.struts.action.ActionForward($FST, $SND, $TRD)"
    - pattern: "$TRD"
  - patterns:
    - pattern-inside: |
        $ACTION = new org.apache.struts.action.ActionForward()
        ...
    - pattern: "$ACTION.setPath(...)"
  - patterns:
    - pattern-inside: |
        $MVC = new org.springframework.web.servlet.ModelAndView()
        ...
    - pattern: "$MVC.setViewName(...);"
  - patterns:
    - pattern-inside: |
        $REQ = $HTTP.getRequestDispatcher(...)
        ...
    - pattern-either:
      - pattern: "$REQ.include($FST, $SND)"
      - pattern: "$REQ.forward($FST, $SND)"
  pattern-sources:
  - pattern: "($VAR: javax.servlet.http.HttpServletRequest).getParameter(...)"
  severity: "ERROR"
- id: "find_sec_bugs_scala.HTTP_PARAMETER_POLLUTION-1"
  languages:
  - "scala"
  message: |
    Concatenating unvalidated user input into a URL can allow an attacker to override the value of
    a request parameter. Attacker may be able to override existing parameter values, inject a new
    parameter or exploit variables out of a direct reach. HTTP Parameter Pollution (HPP) attacks
    consist of injecting encoded query string delimiters into other existing parameters. If a web
    application does not properly sanitize the user input, a malicious user may compromise the
    logic of the application to perform either client-side or server-side attacks.
  metadata:
    category: "security"
    cwe: "CWE-88"
    shortDescription: "Improper Neutralization of Argument Delimiters in a Command
      ('Argument Injection')"
    technology:
    - "scala"
    primary_identifier: "find_sec_bugs.HTTP_PARAMETER_POLLUTION"
    secondary_identifiers:
    - name: "Find Security Bugs-HTTP_PARAMETER_POLLUTION"
      type: "find_sec_bugs_type"
      value: "HTTP_PARAMETER_POLLUTION"
  mode: "taint"
  pattern-sanitizers:
  - pattern: "java.net.URLEncoder.encode(...)"
  - pattern: "com.google.common.net.UrlEscapers.urlPathSegmentEscaper().escape(...)"
  pattern-sinks:
  - pattern: "new org.apache.http.client.methods.HttpGet(...)"
  - pattern: "new org.apache.commons.httpclient.methods.GetMethod(...)"
  - pattern: "($GM: org.apache.commons.httpclient.methods.GetMethod).setQueryString(...)"
  pattern-sources:
  - pattern: "($REQ: HttpServletRequest ).getParameter(...)"
  severity: "ERROR"
- id: "find_sec_bugs_scala.LDAP_INJECTION-1"
  languages:
  - "scala"
  message: |
    Just like SQL, all inputs passed to an LDAP query need to be passed in safely. Unfortunately,
    LDAP doesn't have prepared statement interfaces like SQL. Therefore, the primary defense
    against LDAP injection is strong input validation of any untrusted data before including it in
    an LDAP query.
  metadata:
    category: "security"
    cwe: "CWE-90"
    shortDescription: "Improper Neutralization of Special Elements used in an LDAP
      Query ('LDAP Injection')"
    technology:
    - "scala"
    primary_identifier: "find_sec_bugs.LDAP_INJECTION"
    secondary_identifiers:
    - name: "Find Security Bugs-LDAP_INJECTION"
      type: "find_sec_bugs_type"
      value: "LDAP_INJECTION"
  patterns:
  - pattern-either:
    - pattern-inside: |
        def $FUNC(..., $VAR: String, ...): $TYPE = {
          ...
        }
    - pattern-inside: |
        def $FUNC(..., $X: String, ...): $TYPE = {
          ...
          $VAR = ... + $X;
          ...
        }
  - pattern-either:
    - pattern: "($P: java.util.Properties).put($KEY, $VAR)"
    - pattern: "$CTX.lookup(..., $VAR, ...)"
    - pattern: "$CTX.search(..., $VAR, ...)"
    - pattern: "$CTX.list(..., $VAR, ...)"
  - metavariable-pattern:
      metavariable: "$CTX"
      pattern-either:
      - pattern: "($CTX: javax.naming.directory.DirContext)"
      - pattern: "($CTX: javax.naming.directory.Context)"
      - pattern: "($CTX: javax.naming.Context)"
      - pattern: "($CTX: javax.naming.directory.InitialDirContext)"
      - pattern: "($CTX: javax.naming.ldap.LdapContext)"
      - pattern: "($CTX: com.unboundid.ldap.sdk.LDAPConnection)"
      - pattern: "($CTX: javax.naming.event.EventDirContext)"
      - pattern: "($CTX: com.sun.jndi.ldap.LdapCtx)"
      - pattern: "($CTX: org.springframework.ldap.core.LdapTemplate)"
      - pattern: "($CTX: org.springframework.ldap.core.LdapOperations)"
  severity: "WARNING"
- id: "find_sec_bugs_scala.OGNL_INJECTION-1"
  patterns:
  - pattern-either:
    - pattern-inside: |
        def $FUNC(..., $VAR: String, ...): $TYPE = {
          ...
        }
    - pattern-inside: |
        def $FUNC(..., $VAR: Map[$K,$V], ...): $TYPE = {
          ...
        }
    - pattern-inside: |
        def $FUNC(..., $VAR: java.util.HashMap[$K,$V], ...): $TYPE = {
          ...
        }
  - pattern-either:
    - pattern: "com.opensymphony.xwork2.util.TextParseUtil.translateVariables(...,
        $VAR, ...)"
    - pattern: "com.opensymphony.xwork2.util.TextParseUtil.translateVariablesCollection(...,
        $VAR, ...)"
    - pattern: "com.opensymphony.xwork2.util.TextParseUtil.shallBeIncluded(..., $VAR,
        ...)"
    - pattern: "com.opensymphony.xwork2.util.TextParseUtil.commaDelimitedStringToSet(...,
        $VAR, ...)"
    - pattern: "($P:com.opensymphony.xwork2.util.TextParser).evaluate(..., $VAR, ...)"
    - pattern: "($P:com.opensymphony.xwork2.util.OgnlTextParser).evaluate(..., $VAR,
        ...)"
    - pattern: "($P:com.opensymphony.xwork2.ognl.OgnlReflectionProvider).getGetMethod(...,
        $VAR, ...)"
    - pattern: "($P:com.opensymphony.xwork2.ognl.OgnlReflectionProvider).getSetMethod(...,
        $VAR, ...)"
    - pattern: "($P:com.opensymphony.xwork2.ognl.OgnlReflectionProvider).getField(...,
        $VAR, ...)"
    - pattern: "($P:com.opensymphony.xwork2.ognl.OgnlReflectionProvider).setProperties(...,
        $VAR, ...)"
    - pattern: "($P:com.opensymphony.xwork2.ognl.OgnlReflectionProvider).setProperty(...,$VAR,
        ...)"
    - pattern: "($P:com.opensymphony.xwork2.ognl.OgnlReflectionProvider).getValue(...,$VAR,
        ...)"
    - pattern: "($P:com.opensymphony.xwork2.ognl.OgnlReflectionProvider).setValue(...,$VAR,
        ...)"
    - pattern: "($P:com.opensymphony.xwork2.util.reflection.ReflectionProvider).getGetMethod(...,
        $VAR, ...)"
    - pattern: "($P:com.opensymphony.xwork2.util.reflection.ReflectionProvider).getSetMethod(...,
        $VAR, ...)"
    - pattern: "($P:com.opensymphony.xwork2.util.reflection.ReflectionProvider).getField(...,
        $VAR, ...)"
    - pattern: "($P:com.opensymphony.xwork2.util.reflection.ReflectionProvider).setProperties(...,
        $VAR, ...)"
    - pattern: "($P:com.opensymphony.xwork2.util.reflection.ReflectionProvider).setProperty(...,
        $VAR, ...)"
    - pattern: "($P:com.opensymphony.xwork2.util.reflection.ReflectionProvider).getValue(...,
        $VAR, ...)"
    - pattern: "($P:com.opensymphony.xwork2.util.reflection.ReflectionProvider).setValue(...,
        $VAR, ...)"
    - pattern: "($P:com.opensymphony.xwork2.ognl.OgnlUtil).setProperties(..., $VAR,
        ...)"
    - pattern: "($P:com.opensymphony.xwork2.ognl.OgnlUtil).setProperty(..., $VAR,
        ...)"
    - pattern: "($P:com.opensymphony.xwork2.ognl.OgnlUtil).getValue(..., $VAR, ...)"
    - pattern: "($P:com.opensymphony.xwork2.ognl.OgnlUtil).setValue(..., $VAR, ...)"
    - pattern: "($P:com.opensymphony.xwork2.ognl.OgnlUtil).callMethod(..., $VAR, ...)"
    - pattern: "($P:com.opensymphony.xwork2.ognl.OgnlUtil).compile(..., $VAR, ...)"
    - pattern: "($P:org.apache.struts2.util.VelocityStrutsUtil).evaluate(...)"
    - pattern: "org.apache.struts2.util.StrutsUtil.findString(...)"
    - pattern: "org.apache.struts2.util.StrutsUtil.findValue(..., $VAL)"
    - pattern: "org.apache.struts2.util.StrutsUtil.getText(...)"
    - pattern: "org.apache.struts2.util.StrutsUtil.translateVariables(...)"
    - pattern: "org.apache.struts2.util.StrutsUtil.makeSelectList(..., $VAR, ...)"
    - pattern: "($T:org.apache.struts2.views.jsp.ui.OgnlTool).findValue(..., $VAR,
        ...)"
    - pattern: "($V:com.opensymphony.xwork2.util.ValueStack).findString(...)"
    - pattern: "($V:com.opensymphony.xwork2.util.ValueStack).findValue(..., $VAR,
        ...)"
    - pattern: "($V:com.opensymphony.xwork2.util.ValueStack).setValue(..., $VAR, ...)"
    - pattern: "($V:com.opensymphony.xwork2.util.ValueStack).setParameter(..., $VAR,
        ...)"
  message: |
    "A expression is built with a dynamic value. The source of the value(s) should be verified to
    avoid that unfiltered values fall into this risky code evaluation."
  languages:
  - "scala"
  severity: "WARNING"
  metadata:
    shortDescription: "Expression injection (OGNL)"
    category: "security"
    cwe: "CWE-917"
    technology:
    - "scala"
    primary_identifier: "find_sec_bugs.OGNL_INJECTION"
    secondary_identifiers:
    - name: "Find Security Bugs-OGNL_INJECTION"
      type: "find_sec_bugs_type"
      value: "OGNL_INJECTION"
- id: "find_sec_bugs_scala.PATH_TRAVERSAL_IN-1.SCALA_PATH_TRAVERSAL_IN-1"
  languages:
  - "scala"
  message: |
    A file is opened to read its content. The filename comes from an input parameter. If an
    unfiltered parameter is passed to this file API, files from an arbitrary filesystem location
    could be read. This rule identifies potential path traversal vulnerabilities. In many cases,
    the constructed file path cannot be controlled by the user.
  metadata:
    category: "security"
    cwe: "CWE-22"
    shortDescription: "Improper Limitation of a Pathname to a Restricted Directory
      ('Path Traversal')"
    technology:
    - "scala"
    primary_identifier: "find_sec_bugs.PATH_TRAVERSAL_IN-1.SCALA_PATH_TRAVERSAL_IN-1"
    secondary_identifiers:
    - name: "Find Security Bugs-PATH_TRAVERSAL_IN"
      type: "find_sec_bugs_type"
      value: "PATH_TRAVERSAL_IN"
    - name: "Find Security Bugs-SCALA_PATH_TRAVERSAL_IN"
      type: "find_sec_bugs_type"
      value: "SCALA_PATH_TRAVERSAL_IN"
  patterns:
  - pattern-either:
    - patterns:
      - pattern-inside: |
          def $FUNC(...,$ARGS: Array[String], ...): $TYPE = {
          ...
          }
      - pattern-inside: |
          $VAR = $ARGS($IDX)
          ...
    - pattern-inside: |
        def $FUNC(...,$VAR: String, ...): $TYPE = {
        ...
        }
  - pattern-not-inside: |
      ...
      org.apache.commons.io.FilenameUtils.getName($VAR)
      ...
  - pattern-either:
    - patterns:
      - pattern-inside: |
          $U = new java.net.URI($VAR)
          ...
      - pattern-either:
        - pattern: "new java.io.File($U)"
        - pattern: "java.nio.file.Paths.get($U)"
    - pattern: "new java.io.RandomAccessFile(..., $VAR,...)"
    - pattern: "new java.io.FileReader(<...$VAR...>, ...)"
    - pattern: "new javax.activation.FileDataSource(..., $VAR, ...)"
    - pattern: "new java.io.FileInputStream(..., $VAR, ...)"
    - pattern: "new java.io.File(<...$VAR...>, ...)"
    - pattern: "java.nio.file.Paths.get(...,$VAR,...)"
    - pattern: "java.io.File.createTempFile(...,$VAR, ...)"
    - pattern: "java.io.File.createTempDirectory(...,$VAR,...)"
    - pattern: "java.nio.file.Files.createTempFile(..., $VAR, ...)"
    - pattern: "java.nio.file.Files.createTempDirectory(..., $VAR, ...)"
    - pattern: "scala.io.Source.from(<...$VAR...>)"
    - pattern: "scala.io.Source.fromFile(<...$VAR...>)"
    - pattern: "scala.io.Source.fromString(<...$VAR...>)"
  severity: "ERROR"
- id: "find_sec_bugs_scala.PATH_TRAVERSAL_OUT-1"
  languages:
  - "scala"
  message: |
    A file is opened to write to its contents. The filename comes from an input parameter. If an
    unfiltered parameter is passed to this file API, files at an arbitrary filesystem location
    could be modified. This rule identifies potential path traversal vulnerabilities. In many
    cases, the constructed file path cannot be controlled by the user.
  metadata:
    category: "security"
    cwe: "CWE-22"
    shortDescription: "Improper Limitation of a Pathname to a Restricted Directory
      ('Path Traversal')"
    technology:
    - "scala"
    primary_identifier: "find_sec_bugs.PATH_TRAVERSAL_OUT"
    secondary_identifiers:
    - name: "Find Security Bugs-PATH_TRAVERSAL_OUT"
      type: "find_sec_bugs_type"
      value: "PATH_TRAVERSAL_OUT"
  mode: "taint"
  pattern-sanitizers:
  - pattern: "org.apache.commons.io.FilenameUtils.getName(...)"
  pattern-sinks:
  - patterns:
    - pattern-inside: |-
        new java.io.FileWriter($PATH, ...)
    - pattern: "$PATH"
  - patterns:
    - pattern-inside: |-
        new java.io.FileOutputStream($PATH, ...)
    - pattern: "$PATH"
  pattern-sources:
  - patterns:
    - pattern-inside: |
        def $FUNC(..., $ARGS: Array[String], ...): $TYPE = {
          ...
        }
    - pattern: "$ARGS[$IDX]"
  - patterns:
    - pattern-inside: |
        def $FUNC(..., $VAR: String, ...): $TYPE = {
          ...
        }
    - pattern: "$VAR"
  severity: "ERROR"
- id: "find_sec_bugs_scala.PT_ABSOLUTE_PATH_TRAVERSAL-1"
  languages:
  - "scala"
  message: |
    "The software uses an HTTP request parameter to construct a pathname that should be within a
    restricted directory, but it does not properly neutralize absolute path sequences such as
    "/abs/path" that can resolve to a location that is outside of that directory. See
    http://cwe.mitre.org/data/definitions/36.html for more information."
  metadata:
    category: "security"
    cwe: "CWE-22"
    shortDescription: "Improper Limitation of a Pathname to a Restricted Directory
      ('Path Traversal')"
    technology:
    - "scala"
    primary_identifier: "find_sec_bugs.PT_ABSOLUTE_PATH_TRAVERSAL"
    secondary_identifiers:
    - name: "Find Security Bugs-PT_ABSOLUTE_PATH_TRAVERSAL"
      type: "find_sec_bugs_type"
      value: "PT_ABSOLUTE_PATH_TRAVERSAL"
  mode: "taint"
  pattern-sanitizers:
  - pattern: "org.apache.commons.io.FilenameUtils.getName(...)"
  pattern-sinks:
  - patterns:
    - pattern-inside: |
        $U = new java.net.URI($VAR)
    - pattern-either:
      - pattern-inside: |-
          new java.io.File($U)
      - pattern-inside: |-
          java.nio.file.Paths.get($U)
    - pattern: "$VAR"
  - patterns:
    - pattern-inside: |-
        new java.io.RandomAccessFile($INPUT,...)
    - pattern: "$INPUT"
  - pattern: "new java.io.FileReader(...)"
  - pattern: "new javax.activation.FileDataSource(...)"
  - pattern: "new java.io.FileInputStream(...)"
  - pattern: "new java.io.File(...)"
  - pattern: "java.nio.file.Paths.get(...)"
  - pattern: "java.io.File.createTempFile(...)"
  - pattern: "java.io.File.createTempDirectory(...)"
  - pattern: "java.nio.file.Files.createTempFile(...)"
  - pattern: "java.nio.file.Files.createTempDirectory(...)"
  - patterns:
    - pattern-inside: |-
        new java.io.FileWriter($PATH, ...)
    - pattern: "$PATH"
  - patterns:
    - pattern-inside: |-
        new java.io.FileOutputStream($PATH, ...)
    - pattern: "$PATH"
  pattern-sources:
  - pattern: "($REQ: HttpServletRequest ).getParameter(...)"
  severity: "WARNING"
- id: "find_sec_bugs_scala.PT_RELATIVE_PATH_TRAVERSAL-1"
  languages:
  - "scala"
  message: |
    "The software uses an HTTP request parameter to construct a pathname that should be within a
    restricted directory, but it does not properly neutralize sequences such as ".." that can
    resolve to a location that is outside of that directory. See
    http://cwe.mitre.org/data/definitions/23.html for more information."
  metadata:
    category: "security"
    cwe: "CWE-22"
    shortDescription: "Improper Limitation of a Pathname to a Restricted Directory
      ('Path Traversal')"
    technology:
    - "scala"
    primary_identifier: "find_sec_bugs.PT_RELATIVE_PATH_TRAVERSAL"
    secondary_identifiers:
    - name: "Find Security Bugs-PT_RELATIVE_PATH_TRAVERSAL"
      type: "find_sec_bugs_type"
      value: "PT_RELATIVE_PATH_TRAVERSAL"
  mode: "taint"
  pattern-sanitizers:
  - pattern: "org.apache.commons.io.FilenameUtils.getName(...)"
  pattern-sinks:
  - patterns:
    - pattern-inside: |
        $U = new java.net.URI($VAR)
    - pattern-either:
      - pattern-inside: |-
          new java.io.File($U)
      - pattern-inside: |-
          java.nio.file.Paths.get($U)
    - pattern: "$VAR"
  - patterns:
    - pattern-inside: |-
        new java.io.RandomAccessFile($INPUT,...)
    - pattern: "$INPUT"
  - pattern: "new java.io.FileReader(...)"
  - pattern: "new javax.activation.FileDataSource(...)"
  - pattern: "new java.io.FileInputStream(...)"
  - pattern: "new java.io.File(...)"
  - pattern: "java.nio.file.Paths.get(...)"
  - pattern: "java.io.File.createTempFile(...)"
  - pattern: "java.io.File.createTempDirectory(...)"
  - pattern: "java.nio.file.Files.createTempFile(...)"
  - pattern: "java.nio.file.Files.createTempDirectory(...)"
  - patterns:
    - pattern-inside: |-
        new java.io.FileWriter($PATH, ...)
    - pattern: "$PATH"
  - patterns:
    - pattern-inside: |-
        new java.io.FileOutputStream($PATH, ...)
    - pattern: "$PATH"
  pattern-sources:
  - patterns:
    - pattern-inside: |
        $P = ($REQ: HttpServletRequest ).getParameter(...);
        ...
    - pattern-either:
      - pattern: "$P + ..."
      - pattern: "... + $P"
  severity: "WARNING"
- id: "find_sec_bugs_scala.SQL_INJECTION_SPRING_JDBC-1.SQL_INJECTION_JPA-1.SQL_INJECTION_JDO-1.SQL_INJECTION_JDBC-1.SQL_NONCONSTANT_STRING_PASSED_TO_EXECUTE-1.SCALA_SQL_INJECTION_SLICK-1"
  languages:
  - "scala"
  message: |
    The input values included in SQL queries need to be passed in safely. Bind
    variables in prepared statements can be used to easily mitigate the risk of
    SQL injection.
  metadata:
    category: "security"
    cwe: "CWE-89"
    owasp: "A1:2017-Injection"
    shortDescription: "Improper Neutralization of Special Elements used in an SQL
      Command ('SQL Injection')"
    primary_identifier: "find_sec_bugs.SQL_INJECTION_SPRING_JDBC-1.SQL_INJECTION_JPA-1.SQL_INJECTION_JDO-1.SQL_INJECTION_JDBC-1.SQL_NONCONSTANT_STRING_PASSED_TO_EXECUTE-1.SCALA_SQL_INJECTION_SLICK-1"
    secondary_identifiers:
    - name: "Find Security Bugs-SQL_INJECTION_SPRING_JDBC"
      type: "find_sec_bugs_type"
      value: "SQL_INJECTION_SPRING_JDBC"
    - name: "Find Security Bugs-SQL_INJECTION_JPA"
      type: "find_sec_bugs_type"
      value: "SQL_INJECTION_JPA"
    - name: "Find Security Bugs-SQL_INJECTION_JDO"
      type: "find_sec_bugs_type"
      value: "SQL_INJECTION_JDO"
    - name: "Find Security Bugs-SQL_INJECTION_JDBC"
      type: "find_sec_bugs_type"
      value: "SQL_INJECTION_JDBC"
    - name: "Find Security Bugs-SQL_NONCONSTANT_STRING_PASSED_TO_EXECUTE"
      type: "find_sec_bugs_type"
      value: "SQL_NONCONSTANT_STRING_PASSED_TO_EXECUTE"
    - name: "Find Security Bugs-SCALA_SQL_INJECTION_SLICK"
      type: "find_sec_bugs_type"
      value: "SCALA_SQL_INJECTION_SLICK"
  patterns:
  - pattern-not-inside: |
      $ARG = ...
      ...
  - pattern-not-inside: |
      object $CLAZZ {
        ...
        $ARG = ...
        ...
      }
  - pattern-not-inside: |
      class $CLAZZ {
        ...
        $ARG = ...
        ...
      }
  - pattern-either:
    - patterns:
      - pattern: "($PM:javax.jdo.PersistenceManager).newQuery(<...$ARG...>)"
      - pattern-not: "($PM:javax.jdo.PersistenceManager).newQuery(\"...\")"
    - patterns:
      - pattern: "($PM:javax.jdo.PersistenceManager).newQuery(..., <...$ARG...>)"
      - pattern-not: "($PM:javax.jdo.PersistenceManager).newQuery(..., \"...\")"
    - patterns:
      - pattern: "($Q: javax.jdo.Query).setFilter(<...$ARG...>)"
      - pattern-not: "($Q: javax.jdo.Query).setFilter(\"...\")"
    - patterns:
      - pattern: "($Q: javax.jdo.Query).setGrouping(<...$ARG...>)"
      - pattern-not: "($Q: javax.jdo.Query).setGrouping(\"...\")"
    - patterns:
      - pattern: "($Q: javax.jdo.Query).setGrouping(<...$ARG...>)"
      - pattern-not: "($Q: javax.jdo.Query).setGrouping(\"...\")"
    - patterns:
      - pattern: "($H: org.hibernate.criterion.Restrictions).sqlRestriction(<...$ARG...>,
          ...)"
      - pattern-not: "($H: org.hibernate.criterion.Restrictions).sqlRestriction(\"...\",
          ...)"
    - patterns:
      - pattern: "($S: org.hibernate.Session).createQuery(<...$ARG...>, ...)"
      - pattern-not: "($S: org.hibernate.Session).createQuery(\"...\", ...)"
    - patterns:
      - pattern: "($S: org.hibernate.Session).createSQLQuery(<...$ARG...>, ...)"
      - pattern-not: "($S: org.hibernate.Session).createSQLQuery(\"...\", ...)"
    - patterns:
      - pattern: "($S: java.sql.Statement).executeQuery(<...$ARG...>, ...)"
      - pattern-not: "($S: java.sql.Statement).createSQLQuery(\"...\", ...)"
    - patterns:
      - pattern: "($S: java.sql.Statement).execute(<...$ARG...>, ...)"
      - pattern-not: "($S: java.sql.Statement).execute(\"...\", ...)"
    - patterns:
      - pattern: "($S: java.sql.Statement).executeUpdate(<...$ARG...>, ...)"
      - pattern-not: "($S: java.sql.Statement).executeUpdate(\"...\", ...)"
    - patterns:
      - pattern: "($S: java.sql.Statement).executeLargeUpdate(<...$ARG...>, ...)"
      - pattern-not: "($S: java.sql.Statement).executeLargeUpdate(\"...\", ...)"
    - patterns:
      - pattern: "($S: java.sql.Statement).addBatch(<...$ARG...>, ...)"
      - pattern-not: "($S: java.sql.Statement).addBatch(\"...\", ...)"
    - patterns:
      - pattern: "($S: java.sql.PreparedStatement).executeQuery(<...$ARG...>, ...)"
      - pattern-not: "($S: java.sql.PreparedStatement).executeQuery(\"...\", ...)"
    - patterns:
      - pattern: "($S: java.sql.PreparedStatement).execute(<...$ARG...>, ...)"
      - pattern-not: "($S: java.sql.PreparedStatement).execute(\"...\", ...)"
    - patterns:
      - pattern: "($S: java.sql.PreparedStatement).executeUpdate(<...$ARG...>, ...)"
      - pattern-not: "($S: java.sql.PreparedStatement).executeUpdate(\"...\", ...)"
    - patterns:
      - pattern: "($S: java.sql.PreparedStatement).executeLargeUpdate(<...$ARG...>,
          ...)"
      - pattern-not: "($S: java.sql.PreparedStatement).executeLargeUpdate(\"...\",
          ...)"
    - patterns:
      - pattern: "($S: java.sql.PreparedStatement).addBatch(<...$ARG...>, ...)"
      - pattern-not: "($S: java.sql.PreparedStatement).addBatch(\"...\", ...)"
    - patterns:
      - pattern: "($S: java.sql.Connection).prepareCall(<...$ARG...>, ...)"
      - pattern-not: "($S: java.sql.Connection).prepareCall(\"...\", ...)"
    - patterns:
      - pattern: "($S: java.sql.Connection).prepareStatement(<...$ARG...>, ...)"
      - pattern-not: "($S: java.sql.Connection).prepareStatement(\"...\", ...)"
    - patterns:
      - pattern: "($S: java.sql.Connection).nativeSQL(<...$ARG...>, ...)"
      - pattern-not: "($S: java.sql.Connection).nativeSQL(\"...\", ...)"
    - patterns:
      - pattern: "new org.springframework.jdbc.core.PreparedStatementCreatorFactory(<...$ARG...>,
          ...)"
      - pattern-not: "new org.springframework.jdbc.core.PreparedStatementCreatorFactory(\"...\",
          ...)"
    - patterns:
      - pattern: "(org.springframework.jdbc.core.PreparedStatementCreatorFactory $F).newPreparedStatementCreator(<...$ARG...>,
          ...)"
      - pattern-not: "(org.springframework.jdbc.core.PreparedStatementCreatorFactory
          $F).newPreparedStatementCreator(\"...\", ...)"
    - patterns:
      - pattern: "($O: org.springframework.jdbc.core.JdbcOperations).batchUpdate(<...$ARG...>,
          ...)"
      - pattern-not: "($O: org.springframework.jdbc.core.JdbcOperations).batchUpdate(\"...\",
          ...)"
    - patterns:
      - pattern: "($O: org.springframework.jdbc.core.JdbcOperations).execute(<...$ARG...>,
          ...)"
      - pattern-not: "($O: org.springframework.jdbc.core.JdbcOperations).execute(\"...\",
          ...)"
    - patterns:
      - pattern: "($O: org.springframework.jdbc.core.JdbcOperations).query(<...$ARG...>,
          ...)"
      - pattern-not: "($O: org.springframework.jdbc.core.JdbcOperations).query(\"...\",
          ...)"
    - patterns:
      - pattern: "($O: org.springframework.jdbc.core.JdbcOperations).queryForList(<...$ARG...>,
          ...)"
      - pattern-not: "($O: org.springframework.jdbc.core.JdbcOperations).queryForList(\"...\",
          ...)"
    - patterns:
      - pattern: "($O: org.springframework.jdbc.core.JdbcOperations).queryForMap(<...$ARG...>,
          ...)"
      - pattern-not: "($O: org.springframework.jdbc.core.JdbcOperations).queryForMap(\"...\",
          ...)"
    - patterns:
      - pattern: "($O: org.springframework.jdbc.core.JdbcOperations).queryForObject(<...$ARG...>,
          ...)"
      - pattern-not: "($O: org.springframework.jdbc.core.JdbcOperations).queryForObject(\"...\",
          ...)"
    - patterns:
      - pattern: "($O: org.springframework.jdbc.core.JdbcOperations).queryForObject(<...$ARG...>,
          ...)"
      - pattern-not: "($O: org.springframework.jdbc.core.JdbcOperations).queryForObject(\"...\",
          ...)"
    - patterns:
      - pattern: "($O: org.springframework.jdbc.core.JdbcOperations).queryForRowSet(<...$ARG...>,
          ...)"
      - pattern-not: "($O: org.springframework.jdbc.core.JdbcOperations).queryForRowSet(\"...\",
          ...)"
    - patterns:
      - pattern: "($O: org.springframework.jdbc.core.JdbcOperations).queryForInt(<...$ARG...>,
          ...)"
      - pattern-not: "($O: org.springframework.jdbc.core.JdbcOperations).queryForInt(\"...\",
          ...)"
    - patterns:
      - pattern: "($O: org.springframework.jdbc.core.JdbcOperations).queryForLong(<...$ARG...>,
          ...)"
      - pattern-not: "($O: org.springframework.jdbc.core.JdbcOperations).queryForLong(\"...\",
          ...)"
    - patterns:
      - pattern: "($O: org.springframework.jdbc.core.JdbcOperations).udpate(<...$ARG...>,
          ...)"
      - pattern-not: "($O: org.springframework.jdbc.core.JdbcOperations).udpate(\"...\",
          ...)"
    - patterns:
      - pattern: "($O: org.springframework.jdbc.core.JdbcTemplate).batchUpdate(<...$ARG...>,
          ...)"
      - pattern-not: "($O: org.springframework.jdbc.core.JdbcTemplate).batchUpdate(\"...\",
          ...)"
    - patterns:
      - pattern: "($O: org.springframework.jdbc.core.JdbcTemplate).execute(<...$ARG...>,
          ...)"
      - pattern-not: "($O: org.springframework.jdbc.core.JdbcTemplate).execute(\"...\",
          ...)"
    - patterns:
      - pattern: "($O: org.springframework.jdbc.core.JdbcTemplate).query(<...$ARG...>,
          ...)"
      - pattern-not: "($O: org.springframework.jdbc.core.JdbcTemplate).query(\"...\",
          ...)"
    - patterns:
      - pattern: "($O: org.springframework.jdbc.core.JdbcTemplate).queryForList(<...$ARG...>,
          ...)"
      - pattern-not: "($O: org.springframework.jdbc.core.JdbcTemplate).queryForList(\"...\",
          ...)"
    - patterns:
      - pattern: "($O: org.springframework.jdbc.core.JdbcTemplate).queryForMap(<...$ARG...>,
          ...)"
      - pattern-not: "($O: org.springframework.jdbc.core.JdbcTemplate).queryForMap(\"...\",
          ...)"
    - patterns:
      - pattern: "($O: org.springframework.jdbc.core.JdbcTemplate).queryForObject(<...$ARG...>,
          ...)"
      - pattern-not: "($O: org.springframework.jdbc.core.JdbcTemplate).queryForObject(\"...\",
          ...)"
    - patterns:
      - pattern: "($O: org.springframework.jdbc.core.JdbcTemplate).queryForRowSet(<...$ARG...>,
          ...)"
      - pattern-not: "($O: org.springframework.jdbc.core.JdbcTemplate).queryForRowSet(\"...\",
          ...)"
    - patterns:
      - pattern: "($O: org.springframework.jdbc.core.JdbcTemplate).queryForInt(<...$ARG...>,
          ...)"
      - pattern-not: "($O: org.springframework.jdbc.core.JdbcTemplate).queryForInt(\"...\",
          ...)"
    - patterns:
      - pattern: "($O: org.springframework.jdbc.core.JdbcTemplate).queryForLong(<...$ARG...>,
          ...)"
      - pattern-not: "($O: org.springframework.jdbc.core.JdbcTemplate).queryForLong(\"...\",
          ...)"
    - patterns:
      - pattern: "($O: org.springframework.jdbc.core.JdbcTemplate).update(<...$ARG...>,
          ...)"
      - pattern-not: "($O: org.springframework.jdbc.core.JdbcTemplate).update(\"...\",
          ...)"
    - patterns:
      - pattern: "($O: io.vertx.sqlclient.SqlClient).query(<...$ARG...>, ...)"
      - pattern-not: "($O: io.vertx.sqlclient.SqlClient).query(\"...\", ...)"
    - patterns:
      - pattern: "($O: io.vertx.sqlclient.SqlClient).preparedQuery(<...$ARG...>, ...)"
      - pattern-not: "($O: io.vertx.sqlclient.SqlClient).preparedQuery(\"...\", ...)"
    - patterns:
      - pattern: "($O: io.vertx.sqlclient.SqlConnection).prepare(<...$ARG...>, ...)"
      - pattern-not: "($O: io.vertx.sqlclient.SqlConnection).prepare(\"...\", ...)"
    - patterns:
      - pattern: "($O: org.apache.turbine.om.peer.BasePeer).executeQuery(<...$ARG...>,
          ...)"
      - pattern-not: "($O: org.apache.turbine.om.peer.BasePeer).executeQuery(\"...\",
          ...)"
    - patterns:
      - pattern: "($O: org.apache.torque.util.BasePeer).executeQuery(<...$ARG...>,
          ...)"
      - pattern-not: "($O: org.apache.torque.util.BasePeer).executeQuery(\"...\",
          ...)"
    - patterns:
      - pattern: "($O: javax.persistence.EntityManager).createQuery(<...$ARG...>,
          ...)"
      - pattern-not: "($O: javax.persistence.EntityManager).createQuery(\"...\", ...)"
    - patterns:
      - pattern: "($O: javax.persistence.EntityManager).createNativeQuery(<...$ARG...>,
          ...)"
      - pattern-not: "($O: javax.persistence.EntityManager).createNativeQuery(\"...\",
          ...)"
    - patterns:
      - pattern: "anorm.SQL(<...$ARG...>)"
      - pattern-not: "anorm.SQL(\"...\")"
    - patterns:
      - pattern-inside: |
          import anorm._
          ...
      - pattern: "SQL(<...$ARG...>)"
      - pattern-not: "SQL(\"...\")"
  severity: "ERROR"
- id: "find_sec_bugs_scala.LDAP_ANONYMOUS-1"
  languages:
  - "scala"
  message: |
    Without proper access control, executing an LDAP statement that contains a
    user-controlled value can allow an attacker to abuse poorly configured LDAP
    context
  metadata:
    category: "security"
    cwe: "CWE-20"
    shortDescription: "Improper Input Validation"
    primary_identifier: "find_sec_bugs.LDAP_ANONYMOUS"
    secondary_identifiers:
    - name: "Find Security Bugs-LDAP_ANONYMOUS"
      type: "find_sec_bugs_type"
      value: "LDAP_ANONYMOUS"
  patterns:
  - pattern-inside: |
      import javax.naming.Context;
      ...
  - pattern: "$ENV.put(Context.SECURITY_AUTHENTICATION, \"none\");"
  severity: "WARNING"
- id: "find_sec_bugs_scala.LDAP_ENTRY_POISONING-1"
  languages:
  - "scala"
  message: |
    Without proper access control, executing an LDAP statement that contains a
    user-controlled value can allow an attacker to abuse poorly configured LDAP
    context
  metadata:
    category: "security"
    cwe: "CWE-20"
    shortDescription: "Improper Input Validation"
    primary_identifier: "find_sec_bugs.LDAP_ENTRY_POISONING"
    secondary_identifiers:
    - name: "Find Security Bugs-LDAP_ENTRY_POISONING"
      type: "find_sec_bugs_type"
      value: "LDAP_ENTRY_POISONING"
  patterns:
  - pattern: "new javax.naming.directory.SearchControls($SCOPE, $CLIMIT, $TLIMIT,
      $ATTR, true, $DEREF)"
  severity: "ERROR"
- id: "find_sec_bugs_scala.DMI_CONSTANT_DB_PASSWORD-1.HARD_CODE_PASSWORD-3"
  languages:
  - "scala"
  message: |
    This code creates a database connect using a hardcoded, constant password. Anyone with access
    to either the source code or the compiled code can easily learn the password.
  metadata:
    category: "security"
    cwe: "CWE-259"
    shortDescription: "Use of Hard-coded Password"
    technology:
    - "scala"
    primary_identifier: "find_sec_bugs.DMI_CONSTANT_DB_PASSWORD-1.HARD_CODE_PASSWORD-3"
    secondary_identifiers:
    - name: "Find Security Bugs-DMI_CONSTANT_DB_PASSWORD"
      type: "find_sec_bugs_type"
      value: "DMI_CONSTANT_DB_PASSWORD"
    - name: "Find Security Bugs-HARD_CODE_PASSWORD"
      type: "find_sec_bugs_type"
      value: "HARD_CODE_PASSWORD"
  patterns:
  - pattern: "java.sql.DriverManager.getConnection($URI, $USR, \"...\");"
  severity: "WARNING"
- id: "find_sec_bugs_scala.DMI_EMPTY_DB_PASSWORD-1.HARD_CODE_PASSWORD-2"
  languages:
  - "scala"
  message: |
    This code creates a database connect using a blank or empty password. This indicates that the
    database is not protected by a password.
  metadata:
    category: "security"
    cwe: "CWE-259"
    shortDescription: "Use of Hard-coded Password"
    technology:
    - "scala"
    primary_identifier: "find_sec_bugs.DMI_EMPTY_DB_PASSWORD-1.HARD_CODE_PASSWORD-2"
    secondary_identifiers:
    - name: "Find Security Bugs-DMI_EMPTY_DB_PASSWORD"
      type: "find_sec_bugs_type"
      value: "DMI_EMPTY_DB_PASSWORD"
    - name: "Find Security Bugs-HARD_CODE_PASSWORD"
      type: "find_sec_bugs_type"
      value: "HARD_CODE_PASSWORD"
  patterns:
  - pattern: "java.sql.DriverManager.getConnection($URI, $USR, \"\");"
  severity: "WARNING"
- id: "find_sec_bugs_scala.HARD_CODE_PASSWORD-1"
  languages:
  - "scala"
  message: |
    Passwords should not be kept in the source code. The source code can be widely shared in an
    enterprise environment, and is certainly shared in open source. To be managed safely, passwords
    and secret keys should be stored in separate configuration files or keystores.
  metadata:
    category: "security"
    cwe: "CWE-259"
    shortDescription: "Use of Hard-coded Password"
    technology:
    - "scala"
    primary_identifier: "find_sec_bugs.HARD_CODE_PASSWORD"
    secondary_identifiers:
    - name: "Find Security Bugs-HARD_CODE_PASSWORD"
      type: "find_sec_bugs_type"
      value: "HARD_CODE_PASSWORD"
  patterns:
  - pattern-either:
    - pattern-inside: |
        val $PWD = "..."
        ...
    - pattern-inside: |
        val $PWD = Array[Byte](...)
        ...
    - pattern-inside: |
        val $PWD = Array(...)
        ...
    - pattern-inside: |
        val $PWD = new String(...)
        ...
    - pattern-inside: |
        val $PWD: String = ...
        ...
    - pattern-inside: |
        val $PWD: Char = ...
        ...
    - pattern-inside: |
        val $PWD = $VAR.toCharArray
        ...
    - pattern-inside: |
        object $CLAZZ {
            val $PWD = ...
            ...
        }
    - pattern-inside: |
        class $CLAZZ {
            val $PWD = ...
            ...
        }
    - pattern-inside: |
        $S = new SymmetricEncryptionConfig(...)
        ...
  - pattern-either:
    - pattern: "($KS: java.security.KeyStore).load(..., \"...\")"
    - pattern: "($KS: java.security.KeyStore).load(..., \"...\".$FOO(...))"
    - pattern: "($KS: java.security.KeyStore).load(..., $PWD)"
    - pattern: "($KS: java.security.KeyStore).load(..., $PWD.$FOO(...))"
    - pattern: "KeyManagerFactory.getInstance(...).init(..., $PWD)"
    - pattern: "KeyManagerFactory.getInstance(...).init(..., $PWD.$FOO(...))"
    - pattern: "KeyManagerFactory.getInstance(...).init(..., \"...\")"
    - pattern: "KeyManagerFactory.getInstance(...).init(..., \"...\".$FOO(...))"
    - pattern: "($KS: java.security.KeyStore).getInstance(...).load(..., \"...\")"
    - pattern: "($KS: java.security.KeyStore).getInstance(...).load(..., \"...\".$FOO(...))"
    - pattern: "($KS: java.security.KeyStore).getInstance(...).load(..., $PWD)"
    - pattern: "($KS: java.security.KeyStore).getInstance(...).load(..., $PWD.$FOO(...))"
    - pattern: "KeyStore.getInstance(...).load(..., \"...\")"
    - pattern: "KeyStore.getInstance(...).load(..., \"...\".$FOO(...))"
    - pattern: "KeyStore.getInstance(...).load(..., $PWD)"
    - pattern: "KeyStore.getInstance(...).load(..., $PWD.$FOO(...))"
    - pattern: "new PBEKeySpec(\"...\", ...)"
    - pattern: "new PBEKeySpec(\"...\".$FOO(...), ...)"
    - pattern: "new PBEKeySpec($PWD, ...)"
    - pattern: "new PBEKeySpec($PWD.$FOO(...), ...)"
    - pattern: "new PasswordAuthentication(\"...\", \"...\")"
    - pattern: "new PasswordAuthentication(\"...\", \"...\".$FOO(...))"
    - pattern: "new PasswordAuthentication(\"...\", $PWD)"
    - pattern: "new PasswordAuthentication(\"...\", $PWD.$FOO(...))"
    - pattern: "($CB: PasswordCallback).setPassword(\"...\")"
    - pattern: "($CB: PasswordCallback).setPassword(\"...\".$FOO(...))"
    - pattern: "($CB: PasswordCallback).setPassword($PWD)"
    - pattern: "($CB: PasswordCallback).setPassword($PWD.$FOO(...))"
    - pattern: "new KeyStore.PasswordProtection(\"...\")"
    - pattern: "new KeyStore.PasswordProtection(\"...\".$FOO(...))"
    - pattern: "new KeyStore.PasswordProtection($PWD)"
    - pattern: "new KeyStore.PasswordProtection($PWD.$FOO(...))"
    - pattern: "new KerberosKey(...,\"...\",...)"
    - pattern: "new KerberosKey(...,\"...\".$FOO(...),...)"
    - pattern: "new KerberosKey(...,$PWD,...)"
    - pattern: "new KerberosKey(...,$PWD.$FOO(...),...)"
    - pattern: "($KMF: javax.net.ssl.KeyManagerFactory).init(..., $PWD)"
    - pattern: "($KMF: javax.net.ssl.KeyManagerFactory).init(..., \"...\")"
    - pattern: "($KMF: javax.net.ssl.KeyManagerFactory).init(..., \"...\".$FOO(...))"
    - pattern: "($KMF: javax.net.ssl.KeyManagerFactory).init(..., $PWD.$FOO(...))"
    - pattern: "($DM: java.sql.DriverManager).getConnection(..., \"...\")"
    - pattern: "($DM: java.sql.DriverManager).getConnection(..., \"...\".$FOO(...))"
    - pattern: "($DM: java.sql.DriverManager).getConnection(..., $PWD)"
    - pattern: "($DM: java.sql.DriverManager).getConnection(..., $PWD.$FOO(...))"
    - pattern: "($KMF: javax.net.ssl.KeyManagerFactory).init(..., \"...\")"
    - pattern: "($KMF: javax.net.ssl.KeyManagerFactory).init(..., \"...\".$FOO(...))"
    - pattern: "($KMF: javax.net.ssl.KeyManagerFactory).init(..., $PWD)"
    - pattern: "($KMF: javax.net.ssl.KeyManagerFactory).init(..., $PWD.$FOO(...))"
    - pattern: "io.vertx.ext.web.handler.CSRFHandler.create(..., \"...\")"
    - pattern: "io.vertx.ext.web.handler.CSRFHandler.create(..., \"...\".$FOO(...))"
    - pattern: "io.vertx.ext.web.handler.CSRFHandler.create(..., $PWD)"
    - pattern: "io.vertx.ext.web.handler.CSRFHandler.create(..., $PWD.$FOO(...))"
    - pattern: "$S.setPassword($PWD)"
    - pattern: "$S.setPassword($PWD.$FOO(...))"
    - pattern: "$S.setPassword(\"...\")"
  - metavariable-regex:
      metavariable: "$PWD"
      regex: "(?i).*(pass|pwd|psw|secret|key|cipher|crypt|des|aes|mac|private|sign|cert).*"
  severity: "ERROR"
- id: "find_sec_bugs_scala.DANGEROUS_PERMISSION_COMBINATION-1"
  pattern-either:
  - pattern: |
      $RUNVAR = new RuntimePermission("createClassLoader");
      ...
      ($PC: PermissionCollection).add($RUNVAR);
  - pattern: |
      $REFVAR = new ReflectPermission("suppressAccessChecks");
      ...
      ($PC: PermissionCollection).add($REFVAR);
  - pattern: "($PC: PermissionCollection).add(new ReflectPermission (\"suppressAccessChecks\"))"
  - pattern: "($PC: PermissionCollection).add(new RuntimePermission(\"createClassLoader\"))"
  languages:
  - "scala"
  message: |
    Do not grant dangerous combinations of permissions.
  metadata:
    shortDescription: "Improper privilege management"
    category: "security"
    cwe: "CWE-269"
    confidence: "HIGH"
    primary_identifier: "find_sec_bugs.DANGEROUS_PERMISSION_COMBINATION"
    secondary_identifiers:
    - name: "Find Security Bugs-DANGEROUS_PERMISSION_COMBINATION"
      type: "find_sec_bugs_type"
      value: "DANGEROUS_PERMISSION_COMBINATION"
  severity: "WARNING"
- id: "find_sec_bugs_scala.OVERLY_PERMISSIVE_FILE_PERMISSION-1"
  languages:
  - "scala"
  message: |
    Overly permissive file permission
  metadata:
    category: "security"
    confidence: "HIGH"
    cwe: "CWE-732"
    shortDescription: "Incorrect Permission Assignment for Critical Resource"
    primary_identifier: "find_sec_bugs.OVERLY_PERMISSIVE_FILE_PERMISSION"
    secondary_identifiers:
    - name: "Find Security Bugs-OVERLY_PERMISSIVE_FILE_PERMISSION"
      type: "find_sec_bugs_type"
      value: "OVERLY_PERMISSIVE_FILE_PERMISSION"
  patterns:
  - pattern-either:
    - pattern: "java.nio.file.Files.setPosixFilePermissions(..., java.nio.file.attribute.PosixFilePermissions.fromString(\"$PERM_STRING\"));"
    - pattern: |
        $PERMISSIONS = java.nio.file.attribute.PosixFilePermissions.fromString("$PERM_STRING");
        ...
        java.nio.file.Files.setPosixFilePermissions(..., $PERMISSIONS);
  - metavariable-regex:
      metavariable: "$PERM_STRING"
      regex: "[rwx-]{6}[rwx]{1,}"
  severity: "WARNING"
- id: "find_sec_bugs_scala.OVERLY_PERMISSIVE_FILE_PERMISSION-2"
  languages:
  - "scala"
  message: |
    Overly permissive file permission
  metadata:
    category: "security"
    confidence: "HIGH"
    cwe: "CWE-732"
    shortDescription: "Incorrect Permission Assignment for Critical Resource"
    primary_identifier: "find_sec_bugs.OVERLY_PERMISSIVE_FILE_PERMISSION-2"
    secondary_identifiers:
    - name: "Find Security Bugs-OVERLY_PERMISSIVE_FILE_PERMISSION"
      type: "find_sec_bugs_type"
      value: "OVERLY_PERMISSIVE_FILE_PERMISSION"
  patterns:
  - pattern-inside: |
      ...
      java.nio.file.Files.setPosixFilePermissions(..., $PERMS);
  - pattern-either:
    - pattern: "$PERMS.add($P);"
    - pattern: "$A = $B + $P;"
  - metavariable-regex:
      metavariable: "$P"
      regex: "(PosixFilePermission.){0,1}(OTHERS_)"
  severity: "WARNING"
- id: "find_sec_bugs_scala.PREDICTABLE_RANDOM-1.PREDICTABLE_RANDOM_SCALA-1"
  languages:
  - "scala"
  message: |
    The use of a predictable random value can lead to vulnerabilities when used in certain security
    critical contexts. A quick fix could be to replace the use of scala.util.Random with something
    stronger, such as java.security.SecureRandom
  metadata:
    category: "security"
    cwe: "CWE-330"
    shortDescription: "Use of Insufficiently Random Values"
    technology:
    - "scala"
    primary_identifier: "find_sec_bugs.PREDICTABLE_RANDOM-1.PREDICTABLE_RANDOM_SCALA-1"
    secondary_identifiers:
    - name: "Find Security Bugs-PREDICTABLE_RANDOM"
      type: "find_sec_bugs_type"
      value: "PREDICTABLE_RANDOM"
    - name: "Find Security Bugs-PREDICTABLE_RANDOM_SCALA"
      type: "find_sec_bugs_type"
      value: "PREDICTABLE_RANDOM_SCALA"
  pattern-either:
  - patterns:
    - pattern: "$LANG.util.Random.$METHOD"
    - metavariable-regex:
        metavariable: "$METHOD"
        regex: "^(next)"
  - pattern: "Math.random"
  severity: "WARNING"
- id: "find_sec_bugs_scala.SCRIPT_ENGINE_INJECTION-1.SPEL_INJECTION-1.EL_INJECTION-2.SEAM_LOG_INJECTION-1"
  languages:
  - "scala"
  message: |
    The software constructs all or part of a code segment using externally-influenced
    input from an upstream component, but it does not neutralize or incorrectly
    neutralizes special elements that could modify the syntax or behavior of the
    intended code segment.
  metadata:
    cwe: "CWE-94"
    shortDescription: "Improper Control of Generation of Code ('Code Injection')"
    primary_identifier: "find_sec_bugs.SCRIPT_ENGINE_INJECTION-1.SPEL_INJECTION-1.EL_INJECTION-2.SEAM_LOG_INJECTION-1"
    secondary_identifiers:
    - name: "Find Security Bugs-SCRIPT_ENGINE_INJECTION"
      type: "find_sec_bugs_type"
      value: "SCRIPT_ENGINE_INJECTION"
    - name: "Find Security Bugs-SPEL_INJECTION"
      type: "find_sec_bugs_type"
      value: "SPEL_INJECTION"
    - name: "Find Security Bugs-EL_INJECTION"
      type: "find_sec_bugs_type"
      value: "EL_INJECTION"
    - name: "Find Security Bugs-SEAM_LOG_INJECTION"
      type: "find_sec_bugs_type"
      value: "SEAM_LOG_INJECTION"
  patterns:
  - pattern: "($ENGINE: javax.script.ScriptEngine).eval($ARG)"
  - pattern-not: "($ENGINE: javax.script.ScriptEngine).eval(\"...\")"
  severity: "ERROR"
- id: "find_sec_bugs_scala.SCRIPT_ENGINE_INJECTION-2"
  languages:
  - "scala"
  message: |
    The software constructs all or part of a code segment using externally-influenced
    input from an upstream component, but it does not neutralize or incorrectly
    neutralizes special elements that could modify the syntax or behavior of the
    intended code segment.
  metadata:
    cwe: "CWE-94"
    shortDescription: "Improper Control of Generation of Code ('Code Injection')"
    primary_identifier: "find_sec_bugs.SCRIPT_ENGINE_INJECTION-2"
    secondary_identifiers:
    - name: "Find Security Bugs-SCRIPT_ENGINE_INJECTION"
      type: "find_sec_bugs_type"
      value: "SCRIPT_ENGINE_INJECTION"
  patterns:
  - pattern: "($P: org.springframework.expression.spel.standard.SpelExpressionParser).parseExpression($ARG);"
  - pattern-not: "($P: org.springframework.expression.spel.standard.SpelExpressionParser
      ).parseExpression(\"...\");"
  severity: "ERROR"
- id: "find_sec_bugs_scala.INSECURE_SMTP_SSL-1"
  languages:
  - "scala"
  message: |
    Server identity verification is disabled when making SSL connections.
  metadata:
    cwe: "CWE-297"
    shortDescription: "Improper Validation of Certificate with Host Mismatch"
    primary_identifier: "find_sec_bugs.INSECURE_SMTP_SSL"
    secondary_identifiers:
    - name: "Find Security Bugs-INSECURE_SMTP_SSL"
      type: "find_sec_bugs_type"
      value: "INSECURE_SMTP_SSL"
  patterns:
  - pattern-either:
    - pattern-inside: |
        $E = new org.apache.commons.mail.SimpleEmail(...);
        ...
    - pattern-inside: |
        $E = new org.apache.commons.mail.Email(...);
        ...
    - pattern-inside: |
        $E = new org.apache.commons.mail.MultiPartEmail(...);
        ...
    - pattern-inside: |
        $E = new org.apache.commons.mail.HtmlEmail(...);
        ...
    - pattern-inside: |
        $E = new org.apache.commons.mail.ImageHtmlEmail(...);
        ...
  - pattern-not: |
      $E.setSSLOnConnect(true);
      ...
      $E.setSSLCheckServerIdentity(true);
  severity: "ERROR"
- id: "find_sec_bugs_scala.SMTP_HEADER_INJECTION-1"
  languages:
  - "scala"
  message: |
    Simple Mail Transfer Protocol (SMTP) is a the text based protocol used for
    email delivery. Like with HTTP, headers are separate by new line separator. If
    kuser input is place in a header line, the application should remove or replace
    new line characters (CR / LF). You should use a safe wrapper such as Apache
    Common Email and Simple Java Mail which filter special characters that can lead
    to header injection.
  metadata:
    category: "security"
    cwe: "CWE-77"
    shortDescription: "Improper Neutralization of Special Elements used in a Command"
    primary_identifier: "find_sec_bugs.SMTP_HEADER_INJECTION"
    secondary_identifiers:
    - name: "Find Security Bugs-SMTP_HEADER_INJECTION"
      type: "find_sec_bugs_type"
      value: "SMTP_HEADER_INJECTION"
  patterns:
  - pattern-either:
    - patterns:
      - pattern-inside: |
          $M = new MimeMessage(...);
          ...
      - pattern: "$M.setSubject($ARG);"
      - pattern-not: "$M.setSubject(\"...\")"
    - patterns:
      - pattern-inside: |
          $M = new MimeMessage(...);
          ...
      - pattern: "$M.addHeader($ARG1, $ARG2)"
      - pattern-not: "$M.addHeader(\"...\", \"...\")"
    - patterns:
      - pattern-inside: |
          $M = new MimeMessage(...);
          ...
      - pattern: "$M.setDescription($ARG)"
      - pattern-not: "$M.setDescription(\"...\")"
    - patterns:
      - pattern-inside: |
          $M = new MimeMessage(...);
          ...
      - pattern: "$M.setDisposition($ARG)"
      - pattern-not: "$M.setDisposition(\"...\")"
  severity: "ERROR"
- id: "find_sec_bugs_scala.SCALA_PLAY_SSRF-1"
  languages:
  - "scala"
  message: |
    Server-Side Request Forgery occur when a web server executes a request to a user supplied
    destination parameter that is not validated. Such vulnerabilities could allow an attacker to
    access internal services or to launch attacks from your web server.
  metadata:
    category: "security"
    cwe: "CWE-918"
    shortDescription: "Server-Side Request Forgery (SSRF)"
    primary_identifier: "find_sec_bugs.SCALA_PLAY_SSRF"
    secondary_identifiers:
    - name: "Find Security Bugs-SCALA_PLAY_SSRF"
      type: "find_sec_bugs_type"
      value: "SCALA_PLAY_SSRF"
  patterns:
  - pattern-not-inside: |
      object $CLAZZ {
        ...
        $ARG = ...
        ...
      }
  - pattern-not-inside: |
      class $CLAZZ {
        ...
        $ARG = ...
        ...
      }
  - pattern-either:
    - patterns:
      - pattern-inside: |
          import play.api.libs.ws._
          ...
      - pattern-not: "($W:WSClient).url(\"...\")"
      - pattern-not: "($W:WSClient).url(\"...\" + \"...\")"
      - pattern: "($W:WSClient).url(<...$ARG...>)"
    - patterns:
      - pattern: "($W:play.api.libs.ws.WSClient).url(<...$ARG...>)"
      - pattern-not: "($W:play.api.libs.ws.WSClient).url(\"...\")"
      - pattern-not: "($W:play.api.libs.ws.WSClient).url(\"...\" + \"...\")"
  severity: "ERROR"
- id: "find_sec_bugs_scala.URLCONNECTION_SSRF_FD-1"
  languages:
  - "scala"
  message: |
    Server-Side Request Forgery occur when a web server executes a request to a user supplied
    destination parameter that is not validated. Such vulnerabilities could allow an attacker to
    access internal services or to launch attacks from your web server.
  metadata:
    category: "security"
    cwe: "CWE-918"
    shortDescription: "Server-Side Request Forgery (SSRF)"
    primary_identifier: "find_sec_bugs.URLCONNECTION_SSRF_FD"
    secondary_identifiers:
    - name: "Find Security Bugs-URLCONNECTION_SSRF_FD"
      type: "find_sec_bugs_type"
      value: "URLCONNECTION_SSRF_FD"
  pattern-either:
  - patterns:
    - pattern-either:
      - pattern-inside: |
          import java.net._
          ...
      - pattern-inside: |
          import java.net.URL
          ...
      - pattern-inside: |
          import java.net.URI
          ...
    - pattern: "new $TYPE(...). ... .$FUNC"
    - pattern-not: "new $TYPE(\"...\"). ... .$FUNC"
    - metavariable-pattern:
        metavariable: "$FUNC"
        pattern-either:
        - pattern: "connect"
        - pattern: "GetContent"
        - pattern: "openConnection"
        - pattern: "openStream"
        - pattern: "getContent"
    - metavariable-pattern:
        metavariable: "$TYPE"
        pattern-either:
        - pattern: "URL"
        - pattern: "java.net.URL"
        - pattern: "URI"
        - pattern: "java.net.URI"
  - patterns:
    - pattern-either:
      - pattern-inside: |
          import java.net.*;
          ...
      - pattern-inside: |
          import java.net.InetSocketAddress;
          ...
    - pattern: |
        new InetSocketAddress(..., $PORT)
    - pattern-not: |
        new InetSocketAddress("...", $PORT)
  severity: "ERROR"
- id: "find_sec_bugs_scala.BAD_HEXA_CONVERSION-1"
  languages:
  - "scala"
  message: |
    When converting a byte array containing a hash signature to a human readable string, a
    conversion mistake can be made if the array is read byte by byte.
  metadata:
    category: "security"
    confidence: "HIGH"
    cwe: "CWE-704"
    shortDescription: "Incorrect Type Conversion or Cast"
    primary_identifier: "find_sec_bugs.BAD_HEXA_CONVERSION"
    secondary_identifiers:
    - name: "Find Security Bugs-BAD_HEXA_CONVERSION"
      type: "find_sec_bugs_type"
      value: "BAD_HEXA_CONVERSION"
  pattern-either:
  - pattern: |
      $B_ARR = ($MD: java.security.MessageDigest).digest(...);
      ...
      for(...) {
        ...
        Integer.toHexString(...);
      }
  - pattern: |
      $B_ARR = ($MD: java.security.MessageDigest).digest(...);
      ...
      while(...) {
        ...
        Integer.toHexString(...);
      }
  severity: "WARNING"
- id: "find_sec_bugs_scala.FORMAT_STRING_MANIPULATION-1"
  languages:
  - "scala"
  message: |
    Allowing user input to control format parameters could enable an attacker to cause exceptions
    to be thrown or leak information.Attackers may be able  to modify the format string argument,
    such that an exception is thrown. If this exception is left uncaught, it may crash the
    application. Alternatively, if sensitive information is used within the unused arguments,
    attackers may change the format string to reveal this information.
  metadata:
    category: "security"
    confidence: "HIGH"
    cwe: "CWE-134"
    shortDescription: "Use of Externally-Controlled Format String"
    primary_identifier: "find_sec_bugs.FORMAT_STRING_MANIPULATION"
    secondary_identifiers:
    - name: "Find Security Bugs-FORMAT_STRING_MANIPULATION"
      type: "find_sec_bugs_type"
      value: "FORMAT_STRING_MANIPULATION"
  patterns:
  - pattern-either:
    - patterns:
      - pattern-inside: |
          $INPUT = ($REQ: javax.servlet.http.HttpServletRequest).getParameter(...);
          ...
      - pattern-inside: |
          $FORMAT_STR = <... $INPUT ...>;
    - patterns:
      - pattern-inside: |
          val $INPUT = ($REQ: javax.servlet.http.HttpServletRequest).getParameter(...);
          ...
      - pattern-inside: |
          val $FORMAT_STR = <... $INPUT ...>;
          ...
    - pattern-inside: |
        val $FORMAT_STR = ... + ($REQ: javax.servlet.http.HttpServletRequest).getParameter(...) + ...; ...
    - pattern-inside: |
        val $FORMAT_STR = ... + ($REQ: javax.servlet.http.HttpServletRequest).getParameter(...); ...
  - pattern-either:
    - pattern: "$VAL = <... $INPUT ...>"
    - pattern: "String.format($FORMAT_STR, ...);"
    - pattern: "String.format(java.util.Locale.$LOCALE, $FORMAT_STR, ...);"
    - pattern: "($F: java.util.Formatter).format($FORMAT_STR, ...);"
    - pattern: "($F: java.util.Formatter).format(java.util.Locale.$LOCALE, $FORMAT_STR,
        ...);"
    - pattern: "($F: java.io.PrintStream).printf($FORMAT_STR, ...);"
    - pattern: "($F: java.io.PrintStream).printf(java.util.Locale.$LOCALE, $FORMAT_STR,
        ...);"
    - pattern: "($F: java.io.PrintStream).format($FORMAT_STR, ...);"
    - pattern: "($F: java.io.PrintStream).format(java.util.Locale.$LOCALE, $FORMAT_STR,
        ...);"
    - pattern: "System.out.printf($FORMAT_STR, ...);"
    - pattern: "System.out.printf(java.util.Locale.$LOCALE, $FORMAT_STR, ...);"
    - pattern: "System.out.format($FORMAT_STR, ...);"
    - pattern: "System.out.format(java.util.Locale.$LOCALE, $FORMAT_STR, ...);"
  severity: "ERROR"
- id: "find_sec_bugs_scala.IMPROPER_UNICODE-1"
  languages:
  - "scala"
  message: |
    Improper Handling of Unicode Encoding
  metadata:
    category: "security"
    confidence: "HIGH"
    cwe: "CWE-176"
    shortDescription: "Improper Handling of Unicode Encoding"
    primary_identifier: "find_sec_bugs.IMPROPER_UNICODE"
    secondary_identifiers:
    - name: "Find Security Bugs-IMPROPER_UNICODE"
      type: "find_sec_bugs_type"
      value: "IMPROPER_UNICODE"
  pattern-either:
  - patterns:
    - pattern-either:
      - pattern: |
          $S = ($INPUT: String).$TRANSFORM(...);
          ...
          $S.$METHOD(...);
      - pattern: "($INPUT: String).$TRANSFORM().$METHOD(...);"
    - metavariable-regex:
        metavariable: "$METHOD"
        regex: "(equals|equalsIgnoreCase|indexOf)"
    - metavariable-regex:
        metavariable: "$TRANSFORM"
        regex: "(toLowerCase|toUpperCase)"
  - pattern: "java.text.Normalizer.normalize(...);"
  - pattern: "java.net.IDN.toASCII(...);"
  - pattern: "($U: URI).toASCIIString()"
  severity: "ERROR"
- id: "find_sec_bugs_scala.MODIFICATION_AFTER_VALIDATION-1"
  patterns:
  - pattern: |
      $Y.matcher($VAR);
      ...
      $VAR.$METHOD(...);
  - metavariable-regex:
      metavariable: "$METHOD"
      regex: "(replace)"
  languages:
  - "scala"
  message: |
    CERT: IDS11-J. Perform any string modifications before validation
  metadata:
    shortDescription: "Collapse of data into unsafe value"
    category: "security"
    cwe: "CWE-182"
    confidence: "HIGH"
    primary_identifier: "find_sec_bugs.MODIFICATION_AFTER_VALIDATION"
    secondary_identifiers:
    - name: "Find Security Bugs-MODIFICATION_AFTER_VALIDATION"
      type: "find_sec_bugs_type"
      value: "MODIFICATION_AFTER_VALIDATION"
  severity: "WARNING"
- id: "find_sec_bugs_scala.NORMALIZATION_AFTER_VALIDATION-1"
  patterns:
  - pattern: |
      $Y = java.util.regex.Pattern.compile("[<>]");
      ...
      $Y.matcher($VAR);
      ...
      java.text.Normalizer.normalize($VAR, ...);
  languages:
  - "scala"
  message: |
    IDS01-J. Normalize strings before validating them
  metadata:
    shortDescription: "Collapse of data into unsafe value"
    category: "security"
    cwe: "CWE-182"
    confidence: "HIGH"
    primary_identifier: "find_sec_bugs.NORMALIZATION_AFTER_VALIDATION"
    secondary_identifiers:
    - name: "Find Security Bugs-NORMALIZATION_AFTER_VALIDATION"
      type: "find_sec_bugs_type"
      value: "NORMALIZATION_AFTER_VALIDATION"
  severity: "WARNING"
- id: "find_sec_bugs_scala.TEMPLATE_INJECTION_PEBBLE-1.TEMPLATE_INJECTION_FREEMARKER-1.TEMPLATE_INJECTION_VELOCITY-1"
  languages:
  - "scala"
  message: |
    A malicious user in control of a template can run malicious code on the
    server-side. Velocity templates should be seen as scripts.
  metadata:
    category: "security"
    cwe: "CWE-94"
    shortDescription: "Improper Control of Generation of Code ('Code Injection')"
    primary_identifier: "find_sec_bugs.TEMPLATE_INJECTION_PEBBLE-1.TEMPLATE_INJECTION_FREEMARKER-1.TEMPLATE_INJECTION_VELOCITY-1"
    secondary_identifiers:
    - name: "Find Security Bugs-TEMPLATE_INJECTION_PEBBLE"
      type: "find_sec_bugs_type"
      value: "TEMPLATE_INJECTION_PEBBLE"
    - name: "Find Security Bugs-TEMPLATE_INJECTION_FREEMARKER"
      type: "find_sec_bugs_type"
      value: "TEMPLATE_INJECTION_FREEMARKER"
    - name: "Find Security Bugs-TEMPLATE_INJECTION_VELOCITY"
      type: "find_sec_bugs_type"
      value: "TEMPLATE_INJECTION_VELOCITY"
  pattern-either:
  - patterns:
    - pattern: "org.apache.velocity.app.Velocity.evaluate(..., $VAR)"
    - pattern-not: "org.apache.velocity.app.Velocity.evaluate(..., \"...\")"
  - patterns:
    - pattern-not-inside: |
        $C = ($CFG: freemarker.template.Configuration).getTemplate("...");
        ...
    - pattern-inside: |
        $C = ($CFG: freemarker.template.Configuration).getTemplate($IN);
        ...
    - pattern: "$C.process(...)"
  - patterns:
    - pattern-inside: |
        import com.mitchellbosecke.pebble.PebbleEngine;
        ...
    - pattern-inside: |
        $C = $T.getTemplate($IN);
        ...
    - pattern-not-inside: |
        $C = $T.getTemplate("...");
        ...
    - pattern: "$C.evaluate(...)"
  severity: "ERROR"
- id: "find_sec_bugs_scala.EXTERNAL_CONFIG_CONTROL-1"
  languages:
  - "scala"
  message: |
    Allowing external control of system settings can disrupt service or cause an application to
    behave in unexpected, and potentially malicious ways. An attacker could cause an error by
    providing a nonexistent catalog name or connect to an unauthorized portion of the database.
  metadata:
    category: "security"
    cwe: "CWE-15"
    shortDescription: "External Control of System or Configuration Setting"
    technology:
    - "scala"
    primary_identifier: "find_sec_bugs.EXTERNAL_CONFIG_CONTROL"
    secondary_identifiers:
    - name: "Find Security Bugs-EXTERNAL_CONFIG_CONTROL"
      type: "find_sec_bugs_type"
      value: "EXTERNAL_CONFIG_CONTROL"
  patterns:
  - pattern: |
      $TAINTED = ($REQ: HttpServletRequest).getParameter(...);
      ...
      ($CONN: java.sql.Connection).setCatalog($TAINTED);
  severity: "WARNING"
- id: "find_sec_bugs_scala.INFORMATION_EXPOSURE_THROUGH_AN_ERROR_MESSAGE-1"
  languages:
  - "scala"
  message: |
    The sensitive information may be valuable information on its own (such as a password), or it
    may be useful for launching other, more deadly attacks. If an attack fails, an attacker may use
    error information provided by the server to launch another more focused attack. For example, an
    attempt to exploit a path traversal weakness (CWE-22) might yield the full pathname of the
    installed application.
  metadata:
    category: "security"
    cwe: "CWE-209"
    shortDescription: "Information Exposure Through an Error Message"
    technology:
    - "scala"
    primary_identifier: "find_sec_bugs.INFORMATION_EXPOSURE_THROUGH_AN_ERROR_MESSAGE"
    secondary_identifiers:
    - name: "Find Security Bugs-INFORMATION_EXPOSURE_THROUGH_AN_ERROR_MESSAGE"
      type: "find_sec_bugs_type"
      value: "INFORMATION_EXPOSURE_THROUGH_AN_ERROR_MESSAGE"
  patterns:
  - pattern: "$E.printStackTrace(...)"
  severity: "WARNING"
- id: "find_sec_bugs_scala.SCALA_SENSITIVE_DATA_EXPOSURE-1"
  languages:
  - "scala"
  message: |
    Applications can unintentionally leak information about their configuration, internal
    workings, or violate privacy through a variety of application problems. Pages that provide
    different responses based on the validity of the data can lead to Information Leakage;
    specifically when data deemed confidential is being revealed as a result of the web
    application's design.
  metadata:
    category: "security"
    cwe: "CWE-200"
    shortDescription: "Information Exposure"
    technology:
    - "scala"
    - "play"
    primary_identifier: "find_sec_bugs.SCALA_SENSITIVE_DATA_EXPOSURE"
    secondary_identifiers:
    - name: "Find Security Bugs-SCALA_SENSITIVE_DATA_EXPOSURE"
      type: "find_sec_bugs_type"
      value: "SCALA_SENSITIVE_DATA_EXPOSURE"
  patterns:
  - pattern-inside: |
      def $FUNC(..., $ARG: String, ...) = $TYPE {
        ...
      }
  - pattern-inside: |
      $VAL = ($C: play.api.Configuration).underlying.getString($ARG)
      ...
  - pattern: "Ok(<...$VAL...>)"
  severity: "WARNING"
- id: "find_sec_bugs_scala.RPC_ENABLED_EXTENSIONS-1"
  languages:
  - "scala"
  message: |
    Enabling extensions in Apache XML RPC server or client can lead to deserialization
    vulnerability which would allow an attacker to execute arbitrary code.
  metadata:
    category: "security"
    cwe: "CWE-502"
    shortDescription: "Deserialization of Untrusted Data"
    primary_identifier: "find_sec_bugs.RPC_ENABLED_EXTENSIONS"
    secondary_identifiers:
    - name: "Find Security Bugs-RPC_ENABLED_EXTENSIONS"
      type: "find_sec_bugs_type"
      value: "RPC_ENABLED_EXTENSIONS"
  patterns:
  - pattern-either:
    - patterns:
      - pattern-inside: |
          val $VAR = new XmlRpcServerConfigImpl();
          ...
      - pattern: "$VAR.setEnabledForExtensions(true);"
    - patterns:
      - pattern-inside: |
          val $VAR = new org.apache.xmlrpc.client.XmlRpcClientConfigImpl();
          ...
      - pattern: "$VAR.setEnabledForExtensions(true);"
  severity: "WARNING"
- id: "find_sec_bugs_scala.SAML_IGNORE_COMMENTS-1"
  languages:
  - "scala"
  message: |
    Ignoring XML comments in SAML may lead to authentication bypass
  metadata:
    category: "security"
    cwe: "CWE-287"
    shortDescription: "Improper Authentication"
    primary_identifier: "find_sec_bugs.SAML_IGNORE_COMMENTS"
    secondary_identifiers:
    - name: "Find Security Bugs-SAML_IGNORE_COMMENTS"
      type: "find_sec_bugs_type"
      value: "SAML_IGNORE_COMMENTS"
  pattern: "($POOL: BasicParserPool).setIgnoreComments(false);"
  severity: "WARNING"
- id: "find_sec_bugs_scala.XML_DECODER-1"
  languages:
  - "scala"
  message: |
    Avoid using XMLDecoder to parse content from an untrusted source.
  metadata:
    category: "security"
    cwe: "CWE-502"
    shortDescription: "Deserialization of Untrusted Data"
    primary_identifier: "find_sec_bugs.XML_DECODER"
    secondary_identifiers:
    - name: "Find Security Bugs-XML_DECODER"
      type: "find_sec_bugs_type"
      value: "XML_DECODER"
  patterns:
  - pattern-inside: |
      $D = new java.beans.XMLDecoder($IN);
      ...
  - pattern-not-inside: |
      $DX = new java.beans.XMLDecoder("...");
      ...
  - pattern: "$D.readObject"
  severity: "WARNING"
- id: "find_sec_bugs_scala.MALICIOUS_XSLT-1"
  mode: "taint"
  pattern-sources:
  - patterns:
    - pattern-either:
      - patterns:
        - pattern-inside: |
            $FUNC(...,String $VAR, ...) {
              ...
            }
        - pattern-either:
          - pattern: "new FileInputStream(<... $VAR ...>);"
          - pattern: "getClass.getResourceAsStream(<... $VAR ...>)"
      - patterns:
        - pattern-inside: |
            class $CLZ {
              String $X = "...";
              ...
            }
        - pattern-inside: |
            $FUNC(...,String $Y, ...) {
              ...
            }
        - pattern-either:
          - pattern: "new FileInputStream($X + $Y);"
          - pattern: "getClass.getResourceAsStream($X + $Y)"
  pattern-sinks:
  - patterns:
    - pattern-either:
      - pattern-inside: |-
          (javax.xml.transform.TransformerFactory $T).newTransformer($SRC, ...)
      - pattern-inside: |-
          (javax.xml.transform.Transformer $T).transform($SRC, ...)
    - pattern: "$SRC"
  languages:
  - "java"
  message: |
    It is possible to attach malicious behavior to those style sheets. Therefore, if an attacker
    can control the content or the source of the style sheet, he might be able to trigger remote
    code execution.
  metadata:
    shortDescription: "Improper neutralization of special elements in output used
      by a downstream component ('Injection')"
    category: "security"
    cwe: "CWE-74"
    primary_identifier: "find_sec_bugs.MALICIOUS_XSLT"
    secondary_identifiers:
    - name: "Find Security Bugs-MALICIOUS_XSLT"
      type: "find_sec_bugs_type"
      value: "MALICIOUS_XSLT"
  severity: "WARNING"
- id: "find_sec_bugs_scala.XPATH_INJECTION-1"
  languages:
  - "scala"
  message: |
    The input values included in SQL queries need to be passed in safely. Bind
    variables in prepared statements can be used to easily mitigate the risk of
    SQL injection.
  metadata:
    category: "security"
    cwe: "CWE-611"
    shortDescription: "Improper Restriction of XML External Entity Reference ('XXE')"
    primary_identifier: "find_sec_bugs.XPATH_INJECTION"
    secondary_identifiers:
    - name: "Find Security Bugs-XPATH_INJECTION"
      type: "find_sec_bugs_type"
      value: "XPATH_INJECTION"
  mode: "taint"
  pattern-sinks:
  - patterns:
    - pattern-either:
      - pattern-inside: |-
          import javax.xml.xpath._
          ...
      - pattern-inside: |-
          import javax.xml.xpath.XPath
          ...
    - pattern-either:
      - pattern: "$Y.compile(...)"
      - pattern: "$X.evaluate(..., $ARG2)"
  pattern-sources:
  - patterns:
    - pattern-inside: |
        def $FUNC(..., $ARG: $TYPE,...): $RET = {
          ...
        }
    - pattern: "$ARG"
  severity: "ERROR"
- id: "find_sec_bugs_scala.SCALA_XSS_MVC_API-1"
  languages:
  - "scala"
  message: |
    Disabling HTML escaping put the application at risk for Cross-Site Scripting (XSS).
  metadata:
    category: "security"
    cwe: "CWE-79"
    shortDescription: "Improper Neutralization of Input During Web Page Generation
      ('Cross-site Scripting')"
    primary_identifier: "find_sec_bugs.SCALA_XSS_MVC_API"
    secondary_identifiers:
    - name: "Find Security Bugs-SCALA_XSS_MVC_API"
      type: "find_sec_bugs_type"
      value: "SCALA_XSS_MVC_API"
  mode: "taint"
  pattern-sanitizers:
  - pattern: "org.owasp.encoder.Encode.forHtml(...)"
  pattern-sinks:
  - pattern: "Ok(...)"
  pattern-sources:
  - patterns:
    - pattern-inside: |
        def $FUNC(..., $ARG: String, ...) = Action {
          ...
        }
    - focus-metavariable: "$ARG"
  severity: "WARNING"
- id: "find_sec_bugs_scala.XSS_REQUEST_WRAPPER-1"
  languages:
  - "scala"
  message: |
    Avoid using custom XSS filtering. Please use standard sanitization functions.
  metadata:
    category: "security"
    cwe: "CWE-79"
    shortDescription: "Improper Neutralization of Input During Web Page Generation
      ('Cross-site Scripting')"
    primary_identifier: "find_sec_bugs.XSS_REQUEST_WRAPPER"
    secondary_identifiers:
    - name: "Find Security Bugs-XSS_REQUEST_WRAPPER"
      type: "find_sec_bugs_type"
      value: "XSS_REQUEST_WRAPPER"
  patterns:
  - pattern-inside: |
      class $CLASS(...) extends HttpServletRequestWrapper(...) {
      ...
      }
  - pattern: "def stripXSS(...) = { ... }"
  severity: "INFO"
- id: "find_sec_bugs_scala.WICKET_XSS1-1"
  languages:
  - "scala"
  message: |
    Disabling HTML escaping put the application at risk for Cross-Site Scripting (XSS).
  metadata:
    category: "security"
    cwe: "CWE-79"
    shortDescription: "Improper Neutralization of Input During Web Page Generation
      ('Cross-site Scripting')"
    primary_identifier: "find_sec_bugs.WICKET_XSS1"
    secondary_identifiers:
    - name: "Find Security Bugs-WICKET_XSS1"
      type: "find_sec_bugs_type"
      value: "WICKET_XSS1"
  patterns:
  - pattern: "($X: Label).setEscapeModelStrings(false);"
  severity: "WARNING"
- id: "find_sec_bugs_scala.XSS_REQUEST_PARAMETER_TO_SERVLET_WRITER-1"
  languages:
  - "scala"
  message: |
    Servlet reflected cross site scripting vulnerability
  metadata:
    category: "security"
    cwe: "CWE-79"
    shortDescription: "Improper Neutralization of Input During Web Page Generation"
    technology:
    - "scala"
    primary_identifier: "find_sec_bugs.XSS_REQUEST_PARAMETER_TO_SERVLET_WRITER"
    secondary_identifiers:
    - name: "Find Security Bugs-XSS_REQUEST_PARAMETER_TO_SERVLET_WRITER"
      type: "find_sec_bugs_type"
      value: "XSS_REQUEST_PARAMETER_TO_SERVLET_WRITER"
  mode: "taint"
  pattern-sanitizers:
  - pattern: "Encode.forHtml(...)"
  - pattern: "org.owasp.esapi.Encoder.encodeForSQL(...)"
  pattern-sinks:
  - patterns:
    - pattern-inside: |-
        def $FUNC(..., $RES: HttpServletResponse, ...): $TYPE = {...}
    - pattern-inside: |
        $WRITER = $RES.getWriter
        ...
    - pattern: "$WRITER.write(...)"
  - patterns:
    - pattern-inside: |-
        def $FUNC(..., $RES: HttpServletResponse, ...): $TYPE = {...}
    - pattern: "$RES.getWriter.write(...)"
  - patterns:
    - pattern-inside: |-
        def $FUNC(..., $RES: HttpServletResponse, ...): $TYPE = {...}
    - pattern: "$RES.getWriter.print(...)"
  pattern-sources:
  - patterns:
    - pattern-inside: |-
        def $FUNC(..., $REQ: HttpServletRequest, ...): $TYPE = {...}
    - pattern-either:
      - pattern: "$REQ.getParameter(...)"
      - pattern: "$REQ.getQueryString"
  severity: "WARNING"
- id: "find_sec_bugs_scala.XSS_SERVLET-1"
  languages:
  - "scala"
  message: |
    A potential XSS was found. It could be used to execute unwanted JavaScript in a
    client's browser.
  metadata:
    category: "security"
    cwe: "CWE-79"
    shortDescription: "Improper Neutralization of Input During Web Page Generation
      ('Cross-site Scripting')"
    primary_identifier: "find_sec_bugs.XSS_SERVLET"
    secondary_identifiers:
    - name: "Find Security Bugs-XSS_SERVLET"
      type: "find_sec_bugs_type"
      value: "XSS_SERVLET"
  mode: "taint"
  pattern-sanitizers:
  - patterns:
    - pattern-inside: |-
        org.owasp.encoder.Encode.forHtml($TAINTED);
    - pattern: "$TAINTED"
  pattern-sinks:
  - patterns:
    - pattern-inside: |-
        def $FUNC(..., $RES: HttpServletResponse, ...): $TYPE = {...}
    - pattern-inside: |
        $WRITER = $RES.getWriter;
        ...
    - pattern: "$WRITER.write($DATA,...);"
    - pattern: "$DATA"
  - patterns:
    - pattern-inside: |-
        def $FUNC(..., $RES: HttpServletResponse, ...): $TYPE = {...}
    - pattern: "$RES.getWriter.write($DATA,...);"
    - pattern: "$DATA"
  pattern-sources:
  - patterns:
    - pattern-inside: |-
        def $FUNC(..., $REQ: HttpServletRequest, ...): $TYPE = {...}
    - pattern: "$REQ.getParameter(...);"
  severity: "WARNING"
- id: "find_sec_bugs_scala.XXE_DOCUMENT-1"
  languages:
  - "scala"
  message: |
    XML External Entity (XXE) attacks can occur when an XML parser supports XML
    entities while processing XML received from an untrusted source.
  metadata:
    category: "security"
    cwe: "CWE-611"
    shortDescription: "Improper Restriction of XML External Entity Reference ('XXE')"
    primary_identifier: "find_sec_bugs.XXE_DOCUMENT"
    secondary_identifiers:
    - name: "Find Security Bugs-XXE_DOCUMENT"
      type: "find_sec_bugs_type"
      value: "XXE_DOCUMENT"
  patterns:
  - pattern-inside: |
      $DF = DocumentBuilderFactory.newInstance
      ...
  - pattern-not-inside: |
      $DF.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true)
      ...
  - pattern-not-inside: |
      $DF.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true)
      ...
  - pattern: "$DB.parse(...)"
  severity: "ERROR"
- id: "find_sec_bugs_scala.XXE_SAXPARSER-1"
  languages:
  - "scala"
  message: |
    XML External Entity (XXE) attacks can occur when an XML parser supports XML
    entities while processing XML received from an untrusted source.
  metadata:
    category: "security"
    cwe: "CWE-611"
    shortDescription: "Improper Restriction of XML External Entity Reference ('XXE')"
    primary_identifier: "find_sec_bugs.XXE_SAXPARSER"
    secondary_identifiers:
    - name: "Find Security Bugs-XXE_SAXPARSER"
      type: "find_sec_bugs_type"
      value: "XXE_SAXPARSER"
  patterns:
  - pattern-inside: |
      val $SF = SAXParserFactory.newInstance
      ...
  - pattern-not-inside: |
      $SF.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true)
      ...
  - pattern-not-inside: |
      $SF.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true)
      ...
  - pattern-inside: |
      val $P = $SFP.newSAXParser
      ...
  - pattern: "$P.parse(...);"
  severity: "ERROR"
- id: "find_sec_bugs_scala.XXE_DTD_TRANSFORM_FACTORY-1.XXE_XSLT_TRANSFORM_FACTORY-1"
  languages:
  - "scala"
  message: |
    XML External Entity (XXE) attacks can occur when an XML parser supports XML
    entities while processing XML received from an untrusted source.
  metadata:
    category: "security"
    cwe: "CWE-611"
    shortDescription: "Improper Restriction of XML External Entity Reference ('XXE')"
    primary_identifier: "find_sec_bugs.XXE_DTD_TRANSFORM_FACTORY-1.XXE_XSLT_TRANSFORM_FACTORY-1"
    secondary_identifiers:
    - name: "Find Security Bugs-XXE_DTD_TRANSFORM_FACTORY"
      type: "find_sec_bugs_type"
      value: "XXE_DTD_TRANSFORM_FACTORY"
    - name: "Find Security Bugs-XXE_XSLT_TRANSFORM_FACTORY"
      type: "find_sec_bugs_type"
      value: "XXE_XSLT_TRANSFORM_FACTORY"
  mode: "taint"
  pattern-sanitizers:
  - pattern: "$T.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, \"\");"
  - pattern: "$T.setAttribute(XMLConstants.ACCESS_EXTERNAL_SCHEMA, \"\");"
  - pattern: "$T.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);"
  pattern-sinks:
  - pattern: "$T.transform(...)"
  pattern-sources:
  - patterns:
    - pattern-either:
      - pattern-inside: |-
          import javax.xml.transform._
          ...
      - pattern-inside: |-
          import javax.xml.transform.Transformer
          ...
    - pattern: "$FACT.newTransformer"
  severity: "ERROR"
- id: "find_sec_bugs_scala.XXE_XMLREADER-1"
  languages:
  - "scala"
  message: |
    XML External Entity (XXE) attacks can occur when an XML parser supports XML
    entities while processing XML received from an untrusted source.
  metadata:
    category: "security"
    cwe: "CWE-611"
    shortDescription: "Improper Restriction of XML External Entity Reference ('XXE')"
    primary_identifier: "find_sec_bugs.XXE_XMLREADER"
    secondary_identifiers:
    - name: "Find Security Bugs-XXE_XMLREADER"
      type: "find_sec_bugs_type"
      value: "XXE_XMLREADER"
  patterns:
  - pattern-inside: |
      val $R = XMLReaderFactory.createXMLReader
      ...
  - pattern-not-inside: |
      $R.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true)
      ...
  - pattern: "$R.parse(...)"
  severity: "ERROR"
- id: "find_sec_bugs_scala.XXE_XMLSTREAMREADER-1"
  languages:
  - "scala"
  message: |
    XML External Entity (XXE) attacks can occur when an XML parser supports XML
    entities while processing XML received from an untrusted source.
  metadata:
    category: "security"
    cwe: "CWE-611"
    shortDescription: "Improper Restriction of XML External Entity Reference ('XXE')"
    primary_identifier: "find_sec_bugs.XXE_XMLSTREAMREADER"
    secondary_identifiers:
    - name: "Find Security Bugs-XXE_XMLSTREAMREADER"
      type: "find_sec_bugs_type"
      value: "XXE_XMLSTREAMREADER"
  patterns:
  - pattern-inside: |
      $SF = XMLInputFactory.newFactory
      ...
  - pattern-not-inside: |
      $SF.setProperty(XMLInputFactory.SUPPORT_DTD, false)
      ...
  - pattern-not-inside: |
      $SF.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, false)
      ...
  - pattern: "$SF.createXMLStreamReader(...)"
  severity: "ERROR"
- id: "find_sec_bugs_scala.XXE_XPATH-1"
  languages:
  - "scala"
  message: |
    XML External Entity (XXE) attacks can occur when an XML parser supports XML
    entities while processing XML received from an untrusted source.
  metadata:
    category: "security"
    cwe: "CWE-611"
    shortDescription: "Improper Restriction of XML External Entity Reference ('XXE')"
    primary_identifier: "find_sec_bugs.XXE_XPATH"
    secondary_identifiers:
    - name: "Find Security Bugs-XXE_XPATH"
      type: "find_sec_bugs_type"
      value: "XXE_XPATH"
  patterns:
  - pattern-inside: |
      val $DF = DocumentBuilderFactory.newInstance
      ...
  - pattern-not-inside: |
      $DF.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, "")
      ...
  - pattern-not-inside: |
      $DF.setAttribute(XMLConstants.ACCESS_EXTERNAL_SCHEMA, "")
      ...
  - pattern-not-inside: |
      $DF.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true)
      ...
  - pattern-not-inside: |
      $DF.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true)
      ...
  - pattern-inside: |
      $B = $DF.newDocumentBuilder
      ...
  - pattern: "$XPATH.evaluate(...)"
  severity: "ERROR"
